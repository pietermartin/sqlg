== Indexes

=== Basic indexing

Sqlg supports adding a unique or non-unique index to any property or properties.

To add an index one has to use Sqlg's topology interface.

[source,java,options="nowrap"]
----
@Test
public void testIndex() {
    VertexLabel personVertexLabel = this.sqlgGraph.getTopology().getPublicSchema().ensureVertexLabelExist("Person", new HashMap<String, PropertyType>() {{
        put("name", PropertyType.STRING);
    }}); # <1>
    Optional<PropertyColumn> namePropertyOptional = personVertexLabel.getProperty("name");
    assertTrue(namePropertyOptional.isPresent());
    Index index = personVertexLabel.ensureIndexExists(IndexType.NON_UNIQUE, Collections.singletonList(namePropertyOptional.get())); $ <2>
    this.sqlgGraph.tx().commit(); # <3>

    this.sqlgGraph.addVertex(T.label, "Person", "name", "John");
    List<Vertex> johns = this.sqlgGraph.traversal().V()
            .hasLabel("Person")
            .has("name", "John")
            .toList(); # <4>

    /* This will execute the following sql.
    SELECT
        "public"."V_Person"."ID" AS "alias1",
        "public"."V_Person"."name" AS "alias2"
    FROM
        "public"."V_Person"
    WHERE
        ( "public"."V_Person"."name" = ?)
    */ # <5>

    assertEquals(1, johns.size());
}
----
<1> Create the 'Person' VertexLabel.
<2> On the 'Person' VertexLabel create a non unique index on the 'name' property.
<3> Index creation is transactional on Postgresql.
<4> The given gremlin query will use the index.
<5> The underlying RDBMS will use the index for the executed sql.

.postgresql V_Person sql definition
image:sqlg/V_Person_name_index.png[image of tinkerpop-classic]

==== Composite indexes

It is possible to create composite indexes.

[source,java,options="nowrap"]
----
@Test
public void testCompositeIndex() {
    VertexLabel personVertexLabel = this.sqlgGraph.getTopology().getPublicSchema().ensureVertexLabelExist("Person", new HashMap<String, PropertyType>() {{
        put("firstName", PropertyType.STRING);
        put("lastName", PropertyType.STRING);
    }}); # <1>
    personVertexLabel.ensureIndexExists(IndexType.NON_UNIQUE, new ArrayList<>(personVertexLabel.getProperties().values())); # <2>
    this.sqlgGraph.tx().commit();
    this.sqlgGraph.addVertex(T.label, "Person", "firstName", "John", "lastName", "Smith");
    List<Vertex> johnSmiths = this.sqlgGraph.traversal().V()
            .hasLabel("Person")
            .has("firstName", "John")
            .has("lastName", "Smith")
            .toList();
    assertEquals(1, johnSmiths.size());
}
----
<1> Create the 'Person' VertexLabel with 2 properties, 'firstName' and 'lastName'.
<2> Create a composite index on 'firstName' and 'lastName'

.postgresql V_Person composite index sql definition
image:sqlg/postgresql_composite_index.png[image of tinkerpop-classic]

Outside of creating the index Sqlg has no further direct interaction with the index. However gremlin queries with a
`HasStep` targeting a property with an index on it will translate to a sql `where` clause on that property and
the underlying RDBMS will utilize the index.

[NOTE]
The index does not need to be created upfront. It can be added any time.


[[anchor-full-text-indexing, full text indexing]]
=== Full-text indexing

On postgresql full text indexing is supported.

[source,java,options="nowrap"]
----
@Test
public void testFullTextIndex() {
    Vertex v0 = this.sqlgGraph.addVertex(T.label, "Sentence", "name", "a fat cat sat on a mat and ate a fat rat");
    Vertex v1 = this.sqlgGraph.addVertex(T.label, "Sentence", "name", "fatal error");
    Vertex v2 = this.sqlgGraph.addVertex(T.label, "Sentence", "name", "error is not fatal");

    VertexLabel vl = this.sqlgGraph.getTopology().getVertexLabel("public", "Sentence").get();
    vl.ensureIndexExists(IndexType.getFullTextGIN("english"), Collections.singletonList(vl.getProperty("name").get())); <1>
    this.sqlgGraph.tx().commit();

    List<Vertex> vts = this.sqlgGraph.traversal()
            .V().hasLabel("Sentence")
            .has("name", FullText.fullTextMatch("english", "fat & rat")) <2>
            .toList();
    Assert.assertEquals(1, vts.size());
    Assert.assertTrue(vts.contains(v0));
}
----
<1> Create a full-text gin index.
<2> Query the full-text index using Sqlg's custom FullText predicate.

=== Global unique indexing

Global unique indexing is a way of specifying that multiple properties across different labels are unique.
For every `GlobalUniqueIndex` Sqlg maintains a separate table with a unique index defined on it.
Every property that partakes in the GlobalUniqueIndex will have its value duplicated in this table.
These tables are kept in the `gui_schema`

[source,java,options="nowrap"]
----
@Test
public void testPersonAndDogDoNotHaveTheSameName() {
    Map<String, PropertyType> properties = new HashMap<String, PropertyType>() {{
        put("name", PropertyType.STRING);
    }}; # <1>
    VertexLabel personVertexLabel = this.sqlgGraph.getTopology().getPublicSchema().ensureVertexLabelExist("Person", properties); # <2>
    VertexLabel dogVertexLabel = this.sqlgGraph.getTopology().getPublicSchema().ensureVertexLabelExist("Dog", properties); # <3>
    PropertyColumn personName = personVertexLabel.getProperty("name").get(); # <4>
    PropertyColumn dogName = dogVertexLabel.getProperty("name").get(); # <5>
    this.sqlgGraph.getTopology().ensureGlobalUniqueIndexExist(new HashSet<PropertyColumn>() {{
        add(personName);
        add(dogName);
    }}); # <6>
    this.sqlgGraph.tx().commit();

    this.sqlgGraph.addVertex(T.label, "Person", "name", "Tyson"); # <7>
    try {
        //This will fail
        this.sqlgGraph.addVertex(T.label, "Dog", "name", "Tyson"); # <8>
        fail("Duplicate key violation suppose to prevent this from executing");
    } catch (RuntimeException e) {
        //swallow
        this.sqlgGraph.tx().rollback();
    }
}
----
<1> A map of the properties to add.
<2> Create the 'Person' VertexLabel with its properties.
<3> Create the 'Dog' VertexLabel with its properties.
<4> Get the `PropertyColumn` for the 'name' property of 'Person'.
<5> Get the `PropertyColumn` for the 'name' property of 'Dog'.
<6> Create the `GlobalUniqueIndex` on the 'name' property of 'Person' and 'Dog'. This will ensure that 'Person's and 'Dog's do not have the same name.
<7> Add a 'Person' with the name "Tyson".
<8> Try to add a 'Dog' with the name "Tyson". This will fail as the `GlobalUniqueIndex' will prevent 'Person's and 'Dog's from having the same name.


GlobalUniqueIndexes do not support composite indexes.