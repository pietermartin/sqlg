


<!DOCTYPE html>
<html id="htmlId">
<head>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8"> 
  <title>Coverage Report > TestMultiThread</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope:     <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">org.umlg.sqlg.test.schema</a>
</div>

<h1>Coverage Summary for Class: TestMultiThread (org.umlg.sqlg.test.schema)</h1>

<table class="coverageStats">

<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Branch, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">TestMultiThread</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (22/22)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    78.6%
  </span>
  <span class="absValue">
    (55/70)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    89.3%
  </span>
  <span class="absValue">
    (208/233)
  </span>
</td>
</tr>
  <tr>
    <td class="name">TestMultiThread$1</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    75%
  </span>
  <span class="absValue">
    (6/8)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TestMultiThread$10</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (1/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TestMultiThread$11</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (1/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TestMultiThread$2</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    66.7%
  </span>
  <span class="absValue">
    (4/6)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TestMultiThread$3</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (1/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TestMultiThread$4</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (1/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TestMultiThread$5</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (4/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    90%
  </span>
  <span class="absValue">
    (27/30)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TestMultiThread$6</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (1/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TestMultiThread$7</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (1/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TestMultiThread$8</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (1/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TestMultiThread$9</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (1/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
  </tr>
<tr>
  <td class="name"><strong>Total</strong></td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (36/36)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    79.7%
  </span>
  <span class="absValue">
    (59/74)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    89.1%
  </span>
  <span class="absValue">
    (262/294)
  </span>
</td>
</tr>
</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode">&nbsp;package org.umlg.sqlg.test.schema;
&nbsp;
&nbsp;import org.umlg.sqlg.util.Preconditions;
&nbsp;import org.apache.commons.configuration2.builder.fluent.Configurations;
&nbsp;import org.apache.commons.configuration2.ex.ConfigurationException;
&nbsp;import org.apache.tinkerpop.gremlin.structure.Edge;
&nbsp;import org.apache.tinkerpop.gremlin.structure.Graph;
&nbsp;import org.apache.tinkerpop.gremlin.structure.T;
&nbsp;import org.apache.tinkerpop.gremlin.structure.Vertex;
&nbsp;import org.apache.tinkerpop.gremlin.util.iterator.IteratorUtils;
&nbsp;import org.junit.Assert;
&nbsp;import org.junit.Assume;
&nbsp;import org.junit.Test;
&nbsp;import org.slf4j.Logger;
&nbsp;import org.slf4j.LoggerFactory;
&nbsp;import org.umlg.sqlg.structure.PropertyDefinition;
&nbsp;import org.umlg.sqlg.structure.PropertyType;
&nbsp;import org.umlg.sqlg.structure.SqlgGraph;
&nbsp;import org.umlg.sqlg.structure.topology.VertexLabel;
&nbsp;import org.umlg.sqlg.test.BaseTest;
&nbsp;
&nbsp;import java.net.URL;
&nbsp;import java.util.*;
&nbsp;import java.util.concurrent.*;
&nbsp;import java.util.concurrent.atomic.AtomicBoolean;
&nbsp;import java.util.concurrent.atomic.AtomicInteger;
&nbsp;import java.util.function.Consumer;
&nbsp;
&nbsp;/**
&nbsp; * Date: 2014/09/24
&nbsp; * Time: 10:46 AM
&nbsp; */
<b class="fc">&nbsp;public class TestMultiThread extends BaseTest {</b>
&nbsp;
<b class="fc">&nbsp;    private static final Logger LOGGER = LoggerFactory.getLogger(TestMultiThread.class);</b>
&nbsp;
&nbsp;    /**
&nbsp;     * This test is a duplicate of TransactionTest.shouldSupportTransactionIsolationCommitCheck but with the schema created upfront else it deadlocks.
&nbsp;     */
&nbsp;    @Test
&nbsp;    public void shouldSupportTransactionIsolationCommitCheck() throws Exception {
<b class="fc">&nbsp;        Vertex v1 = this.sqlgGraph.addVertex();</b>
<b class="fc">&nbsp;        this.sqlgGraph.tx().commit();</b>
<b class="fc">&nbsp;        v1.remove();</b>
<b class="fc">&nbsp;        this.sqlgGraph.tx().commit();</b>
&nbsp;        // the purpose of this test is to simulate gremlin server access to a graph instance, where one thread modifies
&nbsp;        // the graph and a separate thread cannot affect the transaction of the first
<b class="fc">&nbsp;        final CountDownLatch latchCommittedInOtherThread = new CountDownLatch(1);</b>
<b class="fc">&nbsp;        final CountDownLatch latchCommitInOtherThread = new CountDownLatch(1);</b>
&nbsp;
<b class="fc">&nbsp;        final AtomicBoolean noVerticesInFirstThread = new AtomicBoolean(false);</b>
&nbsp;
&nbsp;        // this thread starts a transaction then waits while the second thread tries to commit it.
<b class="fc">&nbsp;        final Thread threadTxStarter = new Thread(&quot;thread1&quot;) {</b>
&nbsp;            @Override
&nbsp;            public void run() {
<b class="fc">&nbsp;                TestMultiThread.this.sqlgGraph.addVertex();</b>
<b class="fc">&nbsp;                latchCommitInOtherThread.countDown();</b>
&nbsp;
&nbsp;                try {
<b class="fc">&nbsp;                    latchCommittedInOtherThread.await();</b>
<b class="nc">&nbsp;                } catch (InterruptedException ie) {</b>
<b class="nc">&nbsp;                    throw new RuntimeException(ie);</b>
&nbsp;                }
&nbsp;
<b class="fc">&nbsp;                TestMultiThread.this.sqlgGraph.tx().rollback();</b>
&nbsp;
&nbsp;                // there should be no vertices here
<b class="fc">&nbsp;                noVerticesInFirstThread.set(!TestMultiThread.this.sqlgGraph.vertices().hasNext());</b>
&nbsp;            }
&nbsp;        };
&nbsp;
<b class="fc">&nbsp;        threadTxStarter.start();</b>
&nbsp;
&nbsp;        // this thread tries to commit the transaction started in the first thread above.
<b class="fc">&nbsp;        final Thread threadTryCommitTx = new Thread(&quot;thread2&quot;) {</b>
&nbsp;            @Override
&nbsp;            public void run() {
&nbsp;                try {
<b class="fc">&nbsp;                    latchCommitInOtherThread.await();</b>
<b class="nc">&nbsp;                } catch (InterruptedException ie) {</b>
<b class="nc">&nbsp;                    throw new RuntimeException(ie);</b>
&nbsp;                }
&nbsp;
&nbsp;                // try to commit the other transaction
<b class="fc">&nbsp;                TestMultiThread.this.sqlgGraph.tx().commit();</b>
&nbsp;
<b class="fc">&nbsp;                latchCommittedInOtherThread.countDown();</b>
&nbsp;            }
&nbsp;        };
&nbsp;
<b class="fc">&nbsp;        threadTryCommitTx.start();</b>
&nbsp;
<b class="fc">&nbsp;        threadTxStarter.join();</b>
<b class="fc">&nbsp;        threadTryCommitTx.join();</b>
&nbsp;
<b class="fc">&nbsp;        Assert.assertTrue(noVerticesInFirstThread.get());</b>
<b class="fc">&nbsp;        assertVertexEdgeCounts(sqlgGraph, 0, 0);</b>
&nbsp;    }
&nbsp;
&nbsp;    @Test
&nbsp;    public void shouldExecuteWithCompetingThreads() throws InterruptedException {
&nbsp;        //Create the schema upfront so that graphs (Hsqldb, H2, Mysql...) that do not support transactional schema&#39;s can succeed.
<b class="fc">&nbsp;        VertexLabel vertexLabel = this.sqlgGraph.getTopology().ensureVertexLabelExist(&quot;vertex&quot;, new HashMap&lt;&gt;() {{</b>
<b class="fc">&nbsp;            put(&quot;test&quot;, PropertyDefinition.of(PropertyType.LONG));</b>
<b class="fc">&nbsp;            put(&quot;blah&quot;, PropertyDefinition.of(PropertyType.DOUBLE));</b>
&nbsp;        }});
<b class="fc">&nbsp;        vertexLabel.ensureEdgeLabelExist(&quot;friend&quot;, vertexLabel, new HashMap&lt;&gt;() {{</b>
<b class="fc">&nbsp;            put(&quot;bloop&quot;, PropertyDefinition.of(PropertyType.INTEGER));</b>
&nbsp;        }});
<b class="fc">&nbsp;        this.sqlgGraph.tx().commit();</b>
<b class="fc">&nbsp;        final Graph graph = this.sqlgGraph;</b>
<b class="fc">&nbsp;        int totalThreads = 250;</b>
<b class="fc">&nbsp;        final AtomicInteger vertices = new AtomicInteger(0);</b>
<b class="fc">&nbsp;        final AtomicInteger edges = new AtomicInteger(0);</b>
<b class="fc">&nbsp;        final AtomicInteger completedThreads = new AtomicInteger(0);</b>
<b class="fc">&nbsp;        CountDownLatch countDownLatch = new CountDownLatch(totalThreads);</b>
<b class="fc">&nbsp;        for (int i = 0; i &lt; totalThreads; i++) {</b>
<b class="fc">&nbsp;            new Thread() {</b>
&nbsp;                @Override
&nbsp;                public void run() {
&nbsp;                    try {
<b class="fc">&nbsp;                        final Random random = new Random();</b>
<b class="fc">&nbsp;                        if (random.nextBoolean()) {</b>
<b class="fc">&nbsp;                            final Vertex a = graph.addVertex();</b>
<b class="fc">&nbsp;                            final Vertex b = graph.addVertex();</b>
<b class="fc">&nbsp;                            final Edge e = a.addEdge(&quot;friend&quot;, b);</b>
&nbsp;
<b class="fc">&nbsp;                            vertices.getAndAdd(2);</b>
<b class="fc">&nbsp;                            a.property(&quot;test&quot;, this.getId());</b>
<b class="fc">&nbsp;                            b.property(&quot;blah&quot;, random.nextDouble());</b>
<b class="fc">&nbsp;                            e.property(&quot;bloop&quot;, random.nextInt());</b>
<b class="fc">&nbsp;                            edges.getAndAdd(1);</b>
<b class="fc">&nbsp;                            graph.tx().commit();</b>
&nbsp;                        } else {
<b class="fc">&nbsp;                            final Vertex a = graph.addVertex();</b>
<b class="fc">&nbsp;                            final Vertex b = graph.addVertex();</b>
<b class="fc">&nbsp;                            final Edge e = a.addEdge(&quot;friend&quot;, b);</b>
&nbsp;
<b class="fc">&nbsp;                            a.property(&quot;test&quot;, this.getId());</b>
<b class="fc">&nbsp;                            b.property(&quot;blah&quot;, random.nextDouble());</b>
<b class="fc">&nbsp;                            e.property(&quot;bloop&quot;, random.nextInt());</b>
&nbsp;
<b class="fc">&nbsp;                            if (random.nextBoolean()) {</b>
<b class="fc">&nbsp;                                graph.tx().commit();</b>
<b class="fc">&nbsp;                                vertices.getAndAdd(2);</b>
<b class="fc">&nbsp;                                edges.getAndAdd(1);</b>
&nbsp;                            } else {
<b class="fc">&nbsp;                                graph.tx().rollback();</b>
&nbsp;                            }
&nbsp;                        }
<b class="fc">&nbsp;                        completedThreads.getAndAdd(1);</b>
<b class="fc">&nbsp;                        LOGGER.info(&quot;shouldExecuteWithCompetingThreads &quot; + completedThreads.get());</b>
&nbsp;
<b class="nc">&nbsp;                    } catch (Exception e) {</b>
<b class="nc">&nbsp;                        LOGGER.error(&quot;failure&quot;, e);</b>
<b class="nc">&nbsp;                        Assert.fail(e.getMessage());</b>
&nbsp;                    } finally {
<b class="fc">&nbsp;                        countDownLatch.countDown();</b>
<b class="fc">&nbsp;                    }</b>
&nbsp;                }
<b class="fc">&nbsp;            }.start();</b>
&nbsp;        }
<b class="fc">&nbsp;        boolean success = countDownLatch.await(5, TimeUnit.MINUTES);</b>
<b class="fc">&nbsp;        Assert.assertTrue(success);</b>
<b class="fc">&nbsp;        Assert.assertEquals(completedThreads.get(), totalThreads);</b>
<b class="fc">&nbsp;        System.out.println(vertices.get());</b>
<b class="fc">&nbsp;        assertVertexEdgeCounts(graph, vertices.get(), edges.get());</b>
&nbsp;    }
&nbsp;
&nbsp;    private static void assertVertexEdgeCounts(final Graph graph, final int expectedVertexCount, final int expectedEdgeCount) {
<b class="fc">&nbsp;        getAssertVertexEdgeCounts(expectedVertexCount, expectedEdgeCount).accept(graph);</b>
&nbsp;    }
&nbsp;
&nbsp;    private static Consumer&lt;Graph&gt; getAssertVertexEdgeCounts(final int expectedVertexCount, final int expectedEdgeCount) {
<b class="fc">&nbsp;        return (g) -&gt; {</b>
<b class="fc">&nbsp;            Assert.assertEquals(expectedVertexCount, IteratorUtils.count(g.vertices()));</b>
<b class="fc">&nbsp;            Assert.assertEquals(expectedEdgeCount, IteratorUtils.count(g.edges()));</b>
&nbsp;        };
&nbsp;    }
&nbsp;
&nbsp;    @Test
&nbsp;    public void testMultiThreadVertices() throws InterruptedException {
<b class="fc">&nbsp;        Set&lt;Integer&gt; tables = new ConcurrentSkipListSet&lt;&gt;();</b>
<b class="fc">&nbsp;        ExecutorService executorService = Executors.newFixedThreadPool(10);</b>
<b class="fc">&nbsp;        for (int j = 0; j &lt; 20; j++) {</b>
<b class="fc">&nbsp;            int finalJ = j;</b>
<b class="fc">&nbsp;            executorService.submit(() -&gt; {</b>
&nbsp;                try {
<b class="fc">&nbsp;                    final Random random = new Random();</b>
<b class="fc">&nbsp;                    random.nextInt();</b>
<b class="fc">&nbsp;                    for (int i = 0; i &lt; 10; i++) {</b>
<b class="fc">&nbsp;                        sqlgGraph.addVertex(T.label, &quot;Person&quot; + finalJ, &quot;name&quot;, String.valueOf(finalJ));</b>
&nbsp;                    }
<b class="fc">&nbsp;                    sqlgGraph.tx().commit();</b>
<b class="fc">&nbsp;                    tables.add(finalJ);</b>
<b class="nc">&nbsp;                } catch (Exception e) {</b>
<b class="nc">&nbsp;                    sqlgGraph.tx().rollback();</b>
<b class="nc">&nbsp;                    LOGGER.error(e.getMessage(), e);</b>
<b class="nc">&nbsp;                    Assert.fail(e.getMessage());</b>
&nbsp;                }
&nbsp;            });
&nbsp;        }
<b class="fc">&nbsp;        executorService.shutdown();</b>
<b class="pc">&nbsp;        if (executorService.awaitTermination(6000, TimeUnit.SECONDS)) {</b>
<b class="fc">&nbsp;            LOGGER.info(&quot;normal termination&quot;);</b>
&nbsp;        } else {
<b class="nc">&nbsp;            Assert.fail(&quot;failed to terminate executor service normally&quot;);</b>
&nbsp;        }
<b class="fc">&nbsp;        for (Integer i : tables) {</b>
<b class="fc">&nbsp;            LOGGER.info(String.format(&quot;looking for &#39;Person%d&#39;&quot;, i));</b>
<b class="fc">&nbsp;            Assert.assertTrue(String.format(&quot;Person%d not found&quot;, i), this.sqlgGraph.getTopology().getVertexLabel(this.sqlgGraph.getSqlDialect().getPublicSchema(), &quot;Person&quot; + i).isPresent());</b>
<b class="fc">&nbsp;            Assert.assertEquals(10, this.sqlgGraph.traversal().V().has(T.label, &quot;Person&quot; + i).has(&quot;name&quot;, String.valueOf(i)).count().next().intValue());</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    @Test
&nbsp;    public void testMultiThreadEdges() throws InterruptedException {
&nbsp;        //For some reason Maria don&#39;t like this one on teamcity
<b class="fc">&nbsp;        Assume.assumeFalse(isMariaDb());</b>
<b class="fc">&nbsp;        Assume.assumeFalse(isH2());</b>
<b class="fc">&nbsp;        Assume.assumeFalse(isHsqldb());</b>
<b class="fc">&nbsp;        Vertex v1 = sqlgGraph.addVertex(T.label, &quot;Person&quot;, &quot;name&quot;, &quot;0&quot;);</b>
<b class="fc">&nbsp;        sqlgGraph.tx().commit();</b>
<b class="fc">&nbsp;        Set&lt;Integer&gt; tables = new ConcurrentSkipListSet&lt;&gt;();</b>
<b class="fc">&nbsp;        ExecutorService executorService = Executors.newFixedThreadPool(10);</b>
<b class="fc">&nbsp;        for (int j = 0; j &lt; 100; j++) {</b>
<b class="fc">&nbsp;            executorService.submit(() -&gt; {</b>
<b class="fc">&nbsp;                final Random random = new Random();</b>
<b class="fc">&nbsp;                int randomInt = random.nextInt();</b>
<b class="fc">&nbsp;                for (int i = 0; i &lt; 10; i++) {</b>
<b class="fc">&nbsp;                    Vertex v2 = sqlgGraph.addVertex(T.label, &quot;Person&quot; + randomInt, &quot;name&quot;, String.valueOf(randomInt));</b>
<b class="fc">&nbsp;                    v1.addEdge(&quot;test&quot; + randomInt, v2);</b>
<b class="fc">&nbsp;                    tables.add(randomInt);</b>
&nbsp;                }
<b class="fc">&nbsp;                sqlgGraph.tx().commit();</b>
&nbsp;            });
&nbsp;        }
<b class="fc">&nbsp;        executorService.shutdown();</b>
<b class="fc">&nbsp;        boolean success = executorService.awaitTermination(60, TimeUnit.SECONDS);</b>
<b class="fc">&nbsp;        Assert.assertTrue(success);</b>
<b class="fc">&nbsp;        for (Integer i : tables) {</b>
<b class="fc">&nbsp;            Assert.assertTrue(this.sqlgGraph.getTopology().getVertexLabel(this.sqlgGraph.getSqlDialect().getPublicSchema(), &quot;Person&quot; + i).isPresent());</b>
<b class="fc">&nbsp;            Assert.assertEquals(10, this.sqlgGraph.traversal().V().has(T.label, &quot;Person&quot; + i).has(&quot;name&quot;, String.valueOf(i)).count().next().intValue());</b>
<b class="fc">&nbsp;            Assert.assertEquals(10, vertexTraversal(this.sqlgGraph, v1).out(&quot;test&quot; + i).count().next().intValue());</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    @Test
&nbsp;    public void testMultiThreadCreateSchemas() throws InterruptedException, ExecutionException {
<b class="fc">&nbsp;        Set&lt;Integer&gt; schemas = new HashSet&lt;&gt;();</b>
<b class="fc">&nbsp;        ExecutorService executorService = Executors.newFixedThreadPool(200);</b>
<b class="fc">&nbsp;        for (int i = 0; i &lt; 10_000; i++) {</b>
<b class="fc">&nbsp;            Integer schema = new Random().nextInt(99);</b>
<b class="fc">&nbsp;            schemas.add(schema);</b>
<b class="fc">&nbsp;            Future&lt;?&gt; f = executorService.submit(() -&gt; {</b>
<b class="fc">&nbsp;                this.sqlgGraph.getTopology().ensureSchemaExist(&quot;schema_&quot; + schema);</b>
<b class="fc">&nbsp;                this.sqlgGraph.tx().commit();</b>
&nbsp;            });
<b class="fc">&nbsp;            f.get();</b>
&nbsp;        }
<b class="fc">&nbsp;        executorService.shutdown();</b>
<b class="fc">&nbsp;        boolean terminated = executorService.awaitTermination(5, TimeUnit.SECONDS);</b>
<b class="fc">&nbsp;        Assert.assertTrue(terminated);</b>
&nbsp;        //+ 1 for the public schema
<b class="fc">&nbsp;        Assert.assertEquals(schemas.size() + 1, this.sqlgGraph.getTopology().getSchemas().size());</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * test when each graph is created in its own thread, in distributed mode
&nbsp;     */
&nbsp;    @Test
&nbsp;    public void testMultipleGraphs() throws Exception {
<b class="fc">&nbsp;        URL sqlProperties = Thread.currentThread().getContextClassLoader().getResource(&quot;sqlg.properties&quot;);</b>
&nbsp;        try {
<b class="fc">&nbsp;            Configurations configs = new Configurations();</b>
<b class="fc">&nbsp;            configuration = configs.properties(sqlProperties);</b>
<b class="fc">&nbsp;            Assume.assumeTrue(isPostgres());</b>
<b class="fc">&nbsp;            configuration.addProperty(&quot;distributed&quot;, true);</b>
<b class="pc">&nbsp;            if (!configuration.containsKey(&quot;jdbc.url&quot;))</b>
<b class="nc">&nbsp;                throw new IllegalArgumentException(String.format(&quot;SqlGraph configuration requires that the %s be set&quot;, &quot;jdbc.url&quot;));</b>
&nbsp;
<b class="nc">&nbsp;        } catch (ConfigurationException e) {</b>
<b class="nc">&nbsp;            throw new RuntimeException(e);</b>
&nbsp;        }
<b class="fc">&nbsp;        VertexLabel personTrue = this.sqlgGraph.getTopology().getPublicSchema().ensureVertexLabelExist(&quot;Person_True&quot;, new LinkedHashMap&lt;&gt;() {{</b>
<b class="fc">&nbsp;            put(&quot;name&quot;, PropertyDefinition.of(PropertyType.STRING));</b>
&nbsp;        }});
<b class="fc">&nbsp;        VertexLabel addressTrue = this.sqlgGraph.getTopology().getPublicSchema().ensureVertexLabelExist(&quot;Address_True&quot;, new LinkedHashMap&lt;&gt;() {{</b>
<b class="fc">&nbsp;            put(&quot;name&quot;, PropertyDefinition.of(PropertyType.STRING));</b>
&nbsp;        }});
<b class="fc">&nbsp;        personTrue.ensureEdgeLabelExist(&quot;address_True&quot;, addressTrue, new LinkedHashMap&lt;&gt;() {{</b>
<b class="fc">&nbsp;            put(&quot;name&quot;, PropertyDefinition.of(PropertyType.STRING));</b>
&nbsp;        }});
<b class="fc">&nbsp;        VertexLabel personLabel = this.sqlgGraph.getTopology().getPublicSchema().ensureVertexLabelExist(&quot;Person&quot;, new LinkedHashMap&lt;&gt;() {{</b>
<b class="fc">&nbsp;            put(&quot;name&quot;, PropertyDefinition.of(PropertyType.STRING));</b>
&nbsp;        }});
<b class="fc">&nbsp;        VertexLabel addressLabel = this.sqlgGraph.getTopology().getPublicSchema().ensureVertexLabelExist(&quot;Address&quot;, new LinkedHashMap&lt;&gt;() {{</b>
<b class="fc">&nbsp;            put(&quot;name&quot;, PropertyDefinition.of(PropertyType.STRING));</b>
&nbsp;        }});
<b class="fc">&nbsp;        personLabel.ensureEdgeLabelExist(&quot;address&quot;, addressLabel, new LinkedHashMap&lt;&gt;() {{</b>
<b class="fc">&nbsp;            put(&quot;name&quot;, PropertyDefinition.of(PropertyType.STRING));</b>
&nbsp;        }});
<b class="fc">&nbsp;        this.sqlgGraph.tx().commit();</b>
<b class="fc">&nbsp;        ExecutorService executorService = Executors.newFixedThreadPool(50);</b>
<b class="fc">&nbsp;        int loop = 400;</b>
<b class="fc">&nbsp;        for (int i = 0; i &lt; loop; i++) {</b>
<b class="fc">&nbsp;            String n = &quot;person&quot; + i;</b>
<b class="fc">&nbsp;            executorService.submit(() -&gt; {</b>
&nbsp;                try {
<b class="pc">&nbsp;                    try (SqlgGraph sqlgGraph1 = SqlgGraph.open(configuration)) {</b>
<b class="fc">&nbsp;                        final Random random = new Random();</b>
<b class="fc">&nbsp;                        if (random.nextBoolean()) {</b>
<b class="fc">&nbsp;                            Vertex person = sqlgGraph1.addVertex(T.label, &quot;Person_True&quot;, &quot;name&quot;, n);</b>
<b class="fc">&nbsp;                            Vertex address = sqlgGraph1.addVertex(T.label, &quot;Address_True&quot;, &quot;name&quot;, n);</b>
<b class="fc">&nbsp;                            person.addEdge(&quot;address_True&quot;, address, &quot;name&quot;, n);</b>
&nbsp;                        } else {
<b class="fc">&nbsp;                            Vertex person = sqlgGraph1.addVertex(T.label, &quot;Person&quot;, &quot;name&quot;, n);</b>
<b class="fc">&nbsp;                            Vertex address = sqlgGraph1.addVertex(T.label, &quot;Address&quot;, &quot;name&quot;, n);</b>
<b class="fc">&nbsp;                            person.addEdge(&quot;address&quot;, address, &quot;name&quot;, n);</b>
&nbsp;                        }
<b class="fc">&nbsp;                        sqlgGraph1.tx().commit();</b>
<b class="pc">&nbsp;                    }</b>
<b class="nc">&nbsp;                } catch (Exception e) {</b>
<b class="nc">&nbsp;                    LOGGER.error(e.getMessage(), e);</b>
<b class="nc">&nbsp;                    Assert.fail(e.getMessage());</b>
&nbsp;                }
&nbsp;            });
&nbsp;        }
<b class="fc">&nbsp;        executorService.shutdown();</b>
<b class="fc">&nbsp;        boolean terminated = executorService.awaitTermination(100, TimeUnit.SECONDS);</b>
<b class="fc">&nbsp;        Assert.assertTrue(terminated);</b>
<b class="pc">&nbsp;        try (SqlgGraph sqlgGraph1 = SqlgGraph.open(configuration)) {</b>
<b class="fc">&nbsp;            Assert.assertEquals(400, sqlgGraph1.traversal().V().hasLabel(&quot;Person_True&quot;).count().next() + sqlgGraph1.traversal().V().hasLabel(&quot;Person&quot;).count().next());</b>
<b class="fc">&nbsp;            Assert.assertEquals(400, sqlgGraph1.traversal().V().hasLabel(&quot;Address_True&quot;).count().next() + sqlgGraph1.traversal().V().hasLabel(&quot;Address&quot;).count().next());</b>
<b class="fc">&nbsp;            Assert.assertEquals(400, sqlgGraph1.traversal().E().hasLabel(&quot;address_True&quot;).count().next() + sqlgGraph1.traversal().E().hasLabel(&quot;address&quot;).count().next());</b>
<b class="pc">&nbsp;        }</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * test when each graph is created in its own thread, in distributed mode
&nbsp;     * each thread created a different label
&nbsp;     */
&nbsp;    @Test
&nbsp;    public void testMultipleGraphsMultipleLabels() throws Exception {
<b class="fc">&nbsp;        Assume.assumeTrue(isPostgres());</b>
<b class="fc">&nbsp;        URL sqlProperties = Thread.currentThread().getContextClassLoader().getResource(&quot;sqlg.properties&quot;);</b>
&nbsp;        try {
<b class="fc">&nbsp;            Configurations configs = new Configurations();</b>
<b class="fc">&nbsp;            configuration = configs.properties(sqlProperties);</b>
<b class="fc">&nbsp;            configuration.addProperty(&quot;distributed&quot;, true);</b>
<b class="fc">&nbsp;            configuration.addProperty(&quot;c3p0.maxPoolSize&quot;, 3);</b>
<b class="fc">&nbsp;            configuration.addProperty(&quot;dataSource.maximumPoolSize&quot;, 3);</b>
<b class="pc">&nbsp;            if (!configuration.containsKey(&quot;jdbc.url&quot;))</b>
<b class="nc">&nbsp;                throw new IllegalArgumentException(String.format(&quot;SqlGraph configuration requires that the %s be set&quot;, &quot;jdbc.url&quot;));</b>
&nbsp;
<b class="nc">&nbsp;        } catch (ConfigurationException e) {</b>
<b class="nc">&nbsp;            Assert.fail(e.getMessage());</b>
&nbsp;        }
&nbsp;
<b class="fc">&nbsp;        ExecutorService executorService = Executors.newFixedThreadPool(200);</b>
<b class="fc">&nbsp;        int loop = 200;</b>
&nbsp;//        int loop = 2;
<b class="fc">&nbsp;        for (int i = 0; i &lt; loop; i++) {</b>
<b class="fc">&nbsp;            String n = &quot;person&quot; + i;</b>
<b class="fc">&nbsp;            executorService.submit(() -&gt; {</b>
&nbsp;                try {
<b class="pc">&nbsp;                    try (SqlgGraph sqlgGraph2 = SqlgGraph.open(configuration)) {</b>
<b class="fc">&nbsp;                        sqlgGraph2.addVertex(T.label, &quot;Person&quot; + n, &quot;name&quot;, n);</b>
<b class="fc">&nbsp;                        sqlgGraph2.tx().commit();</b>
<b class="pc">&nbsp;                    }</b>
<b class="nc">&nbsp;                } catch (Exception e) {</b>
<b class="nc">&nbsp;                    Assert.fail(e.getMessage());</b>
&nbsp;                }
&nbsp;            });
&nbsp;        }
<b class="fc">&nbsp;        executorService.shutdown();</b>
<b class="fc">&nbsp;        boolean terminatedNormally = executorService.awaitTermination(1, TimeUnit.MINUTES);</b>
<b class="fc">&nbsp;        Preconditions.checkState(terminatedNormally);</b>
&nbsp;
<b class="pc">&nbsp;        try (SqlgGraph sqlgGraph2 = SqlgGraph.open(configuration)) {</b>
<b class="fc">&nbsp;            for (int i = 0; i &lt; loop; i++) {</b>
<b class="fc">&nbsp;                String n = &quot;person&quot; + i;</b>
<b class="fc">&nbsp;                Assert.assertEquals(1, sqlgGraph2.traversal().V().hasLabel(&quot;Person&quot; + n).count().next().longValue());</b>
&nbsp;            }
<b class="pc">&nbsp;        }</b>
&nbsp;    }
&nbsp;
&nbsp;    @Test
&nbsp;    public void testLoadsOfSchemaChanges() throws InterruptedException, ExecutionException {
<b class="fc">&nbsp;        Assume.assumeFalse(isH2());</b>
<b class="fc">&nbsp;        ExecutorService executorService = Executors.newFixedThreadPool(10);</b>
<b class="fc">&nbsp;        List&lt;Future&lt;Integer&gt;&gt; futureList = new ArrayList&lt;&gt;();</b>
<b class="fc">&nbsp;        int loop = 1000;</b>
<b class="fc">&nbsp;        for (int i = 0; i &lt; loop; i++) {</b>
<b class="fc">&nbsp;            String n = &quot;person&quot; + i;</b>
<b class="fc">&nbsp;            String edge = &quot;e&quot; + i;</b>
<b class="fc">&nbsp;            int current = i;</b>
<b class="fc">&nbsp;            futureList.add(executorService.submit(() -&gt; {</b>
&nbsp;                try {
<b class="fc">&nbsp;                    Vertex v1 = this.sqlgGraph.addVertex(T.label, n, &quot;name&quot;, n);</b>
<b class="fc">&nbsp;                    Vertex v2 = this.sqlgGraph.addVertex(T.label, n, &quot;name&quot;, n);</b>
<b class="fc">&nbsp;                    final Random random = new Random();</b>
<b class="fc">&nbsp;                    if (random.nextBoolean()) {</b>
<b class="fc">&nbsp;                        v1.property(&quot;another&quot; + n, &quot;asd&quot;);</b>
&nbsp;                    }
<b class="fc">&nbsp;                    if (random.nextBoolean()) {</b>
<b class="fc">&nbsp;                        Edge e = v1.addEdge(edge, v2);</b>
<b class="fc">&nbsp;                        if (random.nextBoolean()) {</b>
<b class="fc">&nbsp;                            e.property(&quot;yetanother&quot; + n, &quot;asd&quot;);</b>
&nbsp;                        }
&nbsp;                    }
<b class="fc">&nbsp;                    this.sqlgGraph.tx().commit();</b>
<b class="nc">&nbsp;                } catch (Exception e) {</b>
<b class="nc">&nbsp;                    LOGGER.error(e.getMessage(), e);</b>
<b class="nc">&nbsp;                    Assert.fail(e.getMessage());</b>
&nbsp;                }
<b class="fc">&nbsp;                return current;</b>
&nbsp;            }));
&nbsp;        }
<b class="fc">&nbsp;        executorService.shutdown();</b>
<b class="fc">&nbsp;        for (Future&lt;Integer&gt; future : futureList) {</b>
<b class="fc">&nbsp;            LOGGER.info(&quot;Completed &quot; + future.get());</b>
&nbsp;        }
<b class="fc">&nbsp;        boolean terminated = executorService.awaitTermination(1, TimeUnit.SECONDS);</b>
<b class="fc">&nbsp;        Preconditions.checkState(terminated, &quot;executorService terminated via timeout&quot;);</b>
<b class="fc">&nbsp;        for (int i = 0; i &lt; loop; i++) {</b>
<b class="fc">&nbsp;            String n = &quot;person&quot; + i;</b>
<b class="fc">&nbsp;            Assert.assertEquals(n + &quot; failed&quot;, 2, this.sqlgGraph.traversal().V().hasLabel(n).count().next().longValue());</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    @Test
&nbsp;    public void simulateReadWriteChange() throws ExecutionException, InterruptedException {
&nbsp;        //Sleep here, help with testing connections from previous test staying idle on postgres.
<b class="fc">&nbsp;        Thread.sleep(3_000);</b>
<b class="fc">&nbsp;        List&lt;String&gt; labels = new ArrayList&lt;&gt;();</b>
<b class="fc">&nbsp;        List&lt;String&gt; properties = new ArrayList&lt;&gt;();</b>
<b class="fc">&nbsp;        for (int i = 0; i &lt; 1000; i++) {</b>
<b class="fc">&nbsp;            labels.add(&quot;label&quot; + i);</b>
<b class="fc">&nbsp;            properties.add(&quot;property&quot; + i);</b>
&nbsp;        }
<b class="fc">&nbsp;        ExecutorService executorService = Executors.newFixedThreadPool(1);</b>
<b class="fc">&nbsp;        List&lt;Future&lt;Integer&gt;&gt; futureList = new ArrayList&lt;&gt;();</b>
&nbsp;
<b class="fc">&nbsp;        for (int i = 0; i &lt; 3; i++) {</b>
<b class="fc">&nbsp;            int count = i;</b>
<b class="fc">&nbsp;            futureList.add(executorService.submit(() -&gt; {</b>
&nbsp;                try {
<b class="fc">&nbsp;                    for (int i1 = 0; i1 &lt; 1000; i1++) {</b>
<b class="fc">&nbsp;                        sqlgGraph.addVertex(T.label, labels.get(i1), properties.get(i1), &quot;asd&quot;);</b>
<b class="fc">&nbsp;                        sqlgGraph.tx().commit();</b>
&nbsp;                    }
<b class="fc">&nbsp;                    return count;</b>
<b class="nc">&nbsp;                } catch (Exception e) {</b>
<b class="nc">&nbsp;                    sqlgGraph.tx().rollback();</b>
<b class="nc">&nbsp;                    throw new RuntimeException(e);</b>
&nbsp;                }
&nbsp;            }));
&nbsp;        }
<b class="fc">&nbsp;        for (int i = 0; i &lt; 3; i++) {</b>
<b class="fc">&nbsp;            int count = i;</b>
<b class="fc">&nbsp;            futureList.add(executorService.submit(() -&gt; {</b>
&nbsp;                try {
<b class="fc">&nbsp;                    for (int i12 = 0; i12 &lt; 1000; i12++) {</b>
<b class="fc">&nbsp;                        sqlgGraph.traversal().V().hasLabel(labels.get(i12)).iterate();</b>
<b class="fc">&nbsp;                        sqlgGraph.tx().rollback();</b>
&nbsp;                    }
<b class="fc">&nbsp;                    return count;</b>
<b class="nc">&nbsp;                } catch (Exception e) {</b>
<b class="nc">&nbsp;                    sqlgGraph.tx().rollback();</b>
<b class="nc">&nbsp;                    throw new RuntimeException(e);</b>
&nbsp;                }
&nbsp;            }));
&nbsp;        }
<b class="fc">&nbsp;        executorService.shutdown();</b>
<b class="fc">&nbsp;        for (Future&lt;Integer&gt; integerFuture : futureList) {</b>
<b class="fc">&nbsp;            LOGGER.info(&quot;done &quot; + integerFuture.get());</b>
&nbsp;        }
<b class="fc">&nbsp;        Assert.assertEquals(1000, this.sqlgGraph.getTopology().getPublicSchema().getVertexLabels().size());</b>
&nbsp;    }
&nbsp;
&nbsp;}
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2024-04-27 19:01</div>
</div>
</body>
</html>
