


<!DOCTYPE html>
<html id="htmlId">
<head>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8"> 
  <title>Coverage Report > TestUserSuppliedPKTopology</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope:     <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">org.umlg.sqlg.test.usersuppliedpk.topology</a>
</div>

<h1>Coverage Summary for Class: TestUserSuppliedPKTopology (org.umlg.sqlg.test.usersuppliedpk.topology)</h1>

<table class="coverageStats">

<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Branch, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">TestUserSuppliedPKTopology</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    50%
  </span>
  <span class="absValue">
    (6/12)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    95.2%
  </span>
  <span class="absValue">
    (60/63)
  </span>
</td>
</tr>
  <tr>
    <td class="name">TestUserSuppliedPKTopology$1</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (1/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (4/4)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TestUserSuppliedPKTopology$2</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (1/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (5/5)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TestUserSuppliedPKTopology$3</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (1/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TestUserSuppliedPKTopology$4</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (1/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
  </tr>
<tr>
  <td class="name"><strong>Total</strong></td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (7/7)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    50%
  </span>
  <span class="absValue">
    (6/12)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    96.2%
  </span>
  <span class="absValue">
    (75/78)
  </span>
</td>
</tr>
</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode">&nbsp;package org.umlg.sqlg.test.usersuppliedpk.topology;
&nbsp;
&nbsp;import com.google.common.base.Preconditions;
&nbsp;import org.apache.commons.collections4.set.ListOrderedSet;
&nbsp;import org.apache.commons.configuration2.builder.fluent.Configurations;
&nbsp;import org.apache.commons.configuration2.ex.ConfigurationException;
&nbsp;import org.apache.tinkerpop.gremlin.structure.Vertex;
&nbsp;import org.junit.Assert;
&nbsp;import org.junit.BeforeClass;
&nbsp;import org.junit.Test;
&nbsp;import org.umlg.sqlg.structure.PropertyDefinition;
&nbsp;import org.umlg.sqlg.structure.PropertyType;
&nbsp;import org.umlg.sqlg.structure.SqlgGraph;
&nbsp;import org.umlg.sqlg.structure.topology.EdgeLabel;
&nbsp;import org.umlg.sqlg.structure.topology.Topology;
&nbsp;import org.umlg.sqlg.structure.topology.VertexLabel;
&nbsp;import org.umlg.sqlg.test.BaseTest;
&nbsp;
&nbsp;import java.net.URL;
&nbsp;import java.util.*;
&nbsp;
&nbsp;import static org.umlg.sqlg.structure.topology.Topology.*;
&nbsp;
&nbsp;/**
&nbsp; * @author &lt;a href=&quot;https://github.com/pietermartin&quot;&gt;Pieter Martin&lt;/a&gt;
&nbsp; * Date: 2018/03/17
&nbsp; */
&nbsp;@SuppressWarnings(&quot;unused&quot;)
<b class="fc">&nbsp;public class TestUserSuppliedPKTopology extends BaseTest {</b>
&nbsp;
&nbsp;    @SuppressWarnings(&quot;Duplicates&quot;)
&nbsp;    @BeforeClass
&nbsp;    public static void beforeClass() {
<b class="fc">&nbsp;        URL sqlProperties = Thread.currentThread().getContextClassLoader().getResource(&quot;sqlg.properties&quot;);</b>
&nbsp;        try {
<b class="fc">&nbsp;            Configurations configs = new Configurations();</b>
<b class="fc">&nbsp;            configuration = configs.properties(sqlProperties);</b>
<b class="pc">&nbsp;            if (isPostgres()) {</b>
<b class="fc">&nbsp;                configuration.addProperty(SqlgGraph.DISTRIBUTED, true);</b>
<b class="pc">&nbsp;                if (!configuration.containsKey(SqlgGraph.JDBC_URL))</b>
<b class="nc">&nbsp;                    throw new IllegalArgumentException(String.format(&quot;SqlGraph configuration requires that the %s be set&quot;, SqlgGraph.JDBC_URL));</b>
&nbsp;            }
<b class="nc">&nbsp;        } catch (ConfigurationException e) {</b>
<b class="nc">&nbsp;            throw new IllegalStateException(e);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;//    @Test
&nbsp;//    public void testUserSuppliedIds() {
&nbsp;//        VertexLabel personVertexLabel = this.sqlgGraph.getTopology().getPublicSchema().ensureVertexLabelExist(
&nbsp;//                &quot;Person&quot;,
&nbsp;//                new LinkedHashMap&lt;&gt;() {{
&nbsp;//                    put(&quot;name&quot;, PropertyDefinition.of(PropertyType.varChar(100)));
&nbsp;//                    put(&quot;surname&quot;, PropertyDefinition.of(PropertyType.varChar(100)));
&nbsp;//                    put(&quot;nickname&quot;, PropertyDefinition.of(PropertyType.varChar(100)));
&nbsp;//                }},
&nbsp;//                ListOrderedSet.listOrderedSet(Arrays.asList(&quot;name&quot;, &quot;surname&quot;))
&nbsp;//        );
&nbsp;//        personVertexLabel.ensureEdgeLabelExist(
&nbsp;//                &quot;marriedTo&quot;,
&nbsp;//                personVertexLabel,
&nbsp;//                new LinkedHashMap&lt;&gt;() {{
&nbsp;//                    put(&quot;place&quot;, PropertyDefinition.of(PropertyType.varChar(100)));
&nbsp;//                    put(&quot;when&quot;, PropertyDefinition.of(PropertyType.LOCALDATETIME));
&nbsp;//                }},
&nbsp;//                ListOrderedSet.listOrderedSet(List.of(&quot;place&quot;, &quot;when&quot;))
&nbsp;//        );
&nbsp;//        this.sqlgGraph.tx().commit();
&nbsp;//
&nbsp;//        Vertex john = this.sqlgGraph.addVertex(T.label, &quot;Person&quot;, &quot;name&quot;, &quot;John&quot;, &quot;surname&quot;, &quot;Longfellow&quot;, &quot;nickname&quot;, &quot;Longboy&quot;);
&nbsp;//        Vertex sue = this.sqlgGraph.addVertex(T.label, &quot;Person&quot;, &quot;name&quot;, &quot;Sue&quot;, &quot;surname&quot;, &quot;Pretty&quot;);
&nbsp;//        john.addEdge(&quot;marriedTo&quot;, sue, &quot;place&quot;, &quot;Timbuck2&quot;, &quot;when&quot;, LocalDateTime.now());
&nbsp;//        this.sqlgGraph.tx().commit();
&nbsp;//
&nbsp;//        List&lt;Vertex&gt; marriedTo = this.sqlgGraph.traversal().V().hasLabel(&quot;Person&quot;)
&nbsp;//                .has(&quot;name&quot;, &quot;John&quot;)
&nbsp;//                .out(&quot;marriedTo&quot;)
&nbsp;//                .toList();
&nbsp;//        Assert.assertEquals(1, marriedTo.size());
&nbsp;//        Assert.assertEquals(sue, marriedTo.get(0));
&nbsp;//    }
&nbsp;//
&nbsp;//    @Test
&nbsp;//    public void testUserSuppliedLongKeys() {
&nbsp;//        VertexLabel aVertexLabel = this.sqlgGraph.getTopology().getPublicSchema().ensureVertexLabelExist(
&nbsp;//                &quot;A&quot;,
&nbsp;//                new LinkedHashMap&lt;&gt;() {{
&nbsp;//                    put(&quot;uid1&quot;, PropertyDefinition.of(PropertyType.LONG));
&nbsp;//                    put(&quot;uid2&quot;, PropertyDefinition.of(PropertyType.LONG));
&nbsp;//                    put(&quot;name&quot;, PropertyDefinition.of(PropertyType.varChar(100)));
&nbsp;//                }},
&nbsp;//                ListOrderedSet.listOrderedSet(Arrays.asList(&quot;uid1&quot;, &quot;uid2&quot;))
&nbsp;//        );
&nbsp;//        VertexLabel bVertexLabel = this.sqlgGraph.getTopology().getPublicSchema().ensureVertexLabelExist(
&nbsp;//                &quot;B&quot;,
&nbsp;//                new LinkedHashMap&lt;&gt;() {{
&nbsp;//                    put(&quot;uid1&quot;, PropertyDefinition.of(PropertyType.INTEGER));
&nbsp;//                    put(&quot;uid2&quot;, PropertyDefinition.of(PropertyType.INTEGER));
&nbsp;//                    put(&quot;name&quot;, PropertyDefinition.of(PropertyType.varChar(100)));
&nbsp;//                }},
&nbsp;//                ListOrderedSet.listOrderedSet(Arrays.asList(&quot;uid1&quot;, &quot;uid2&quot;))
&nbsp;//        );
&nbsp;//        this.sqlgGraph.tx().commit();
&nbsp;//        Vertex vLong = this.sqlgGraph.addVertex(T.label, &quot;A&quot;, &quot;uid1&quot;, 1L, &quot;uid2&quot;, 1L);
&nbsp;//        Vertex vInteger = this.sqlgGraph.addVertex(T.label, &quot;B&quot;, &quot;uid1&quot;, 1, &quot;uid2&quot;, 1);
&nbsp;//        RecordId recordIdLong = (RecordId) vLong.id();
&nbsp;//        RecordId recordIdInteger = (RecordId) vInteger.id();
&nbsp;//        this.sqlgGraph.tx().commit();
&nbsp;//
&nbsp;//        RecordId recordIdLong1 = RecordId.from(this.sqlgGraph, recordIdLong.toString());
&nbsp;//        Assert.assertTrue(this.sqlgGraph.traversal().V(recordIdLong1).hasNext());
&nbsp;//        RecordId recordIdInteger1 = RecordId.from(this.sqlgGraph, recordIdInteger.toString());
&nbsp;//        Assert.assertTrue(this.sqlgGraph.traversal().V(recordIdInteger1).hasNext());
&nbsp;//    }
&nbsp;//
&nbsp;//    @Test
&nbsp;//    public void testAddEdgeUserSuppliedPK() {
&nbsp;//        VertexLabel aVertexLabel = this.sqlgGraph.getTopology().getPublicSchema().ensureVertexLabelExist(
&nbsp;//                &quot;A&quot;,
&nbsp;//                new LinkedHashMap&lt;&gt;() {{
&nbsp;//                    put(&quot;uid1&quot;, PropertyDefinition.of(PropertyType.varChar(100)));
&nbsp;//                    put(&quot;uid2&quot;, PropertyDefinition.of(PropertyType.varChar(100)));
&nbsp;//                    put(&quot;name&quot;, PropertyDefinition.of(PropertyType.varChar(100)));
&nbsp;//                }},
&nbsp;//                ListOrderedSet.listOrderedSet(Arrays.asList(&quot;uid1&quot;, &quot;uid2&quot;))
&nbsp;//        );
&nbsp;//        VertexLabel bVertexLabel = this.sqlgGraph.getTopology().getPublicSchema().ensureVertexLabelExist(
&nbsp;//                &quot;B&quot;,
&nbsp;//                new LinkedHashMap&lt;&gt;() {{
&nbsp;//                    put(&quot;uid1&quot;, PropertyDefinition.of(PropertyType.varChar(100)));
&nbsp;//                    put(&quot;uid2&quot;, PropertyDefinition.of(PropertyType.varChar(100)));
&nbsp;//                    put(&quot;name&quot;, PropertyDefinition.of(PropertyType.varChar(100)));
&nbsp;//                }},
&nbsp;//                ListOrderedSet.listOrderedSet(Arrays.asList(&quot;uid1&quot;, &quot;uid2&quot;))
&nbsp;//        );
&nbsp;//        VertexLabel cVertexLabel = this.sqlgGraph.getTopology().getPublicSchema().ensureVertexLabelExist(
&nbsp;//                &quot;C&quot;,
&nbsp;//                new LinkedHashMap&lt;&gt;() {{
&nbsp;//                    put(&quot;uid1&quot;, PropertyDefinition.of(PropertyType.varChar(100)));
&nbsp;//                    put(&quot;uid2&quot;, PropertyDefinition.of(PropertyType.varChar(100)));
&nbsp;//                    put(&quot;name&quot;, PropertyDefinition.of(PropertyType.varChar(100)));
&nbsp;//                }},
&nbsp;//                ListOrderedSet.listOrderedSet(Arrays.asList(&quot;uid1&quot;, &quot;uid2&quot;))
&nbsp;//        );
&nbsp;//        aVertexLabel.ensureEdgeLabelExist(
&nbsp;//                &quot;e1&quot;,
&nbsp;//                bVertexLabel,
&nbsp;//                new LinkedHashMap&lt;&gt;() {{
&nbsp;//                    put(&quot;uid1&quot;, PropertyDefinition.of(PropertyType.varChar(100)));
&nbsp;//                    put(&quot;uid2&quot;, PropertyDefinition.of(PropertyType.varChar(100)));
&nbsp;//                }},
&nbsp;//                ListOrderedSet.listOrderedSet(Arrays.asList(&quot;uid1&quot;, &quot;uid2&quot;))
&nbsp;//        );
&nbsp;//        aVertexLabel.ensureEdgeLabelExist(
&nbsp;//                &quot;e1&quot;,
&nbsp;//                cVertexLabel,
&nbsp;//                new LinkedHashMap&lt;&gt;() {{
&nbsp;//                    put(&quot;uid1&quot;, PropertyDefinition.of(PropertyType.varChar(100)));
&nbsp;//                    put(&quot;uid2&quot;, PropertyDefinition.of(PropertyType.varChar(100)));
&nbsp;//                }},
&nbsp;//                ListOrderedSet.listOrderedSet(Arrays.asList(&quot;uid1&quot;, &quot;uid2&quot;))
&nbsp;//        );
&nbsp;//        this.sqlgGraph.tx().commit();
&nbsp;//
&nbsp;//
&nbsp;//        Vertex a1 = this.sqlgGraph.addVertex(T.label, &quot;A&quot;, &quot;uid1&quot;, UUID.randomUUID().toString(), &quot;uid2&quot;, UUID.randomUUID().toString(), &quot;name&quot;, &quot;a1&quot;);
&nbsp;//        Vertex b1 = this.sqlgGraph.addVertex(T.label, &quot;B&quot;, &quot;uid1&quot;, UUID.randomUUID().toString(), &quot;uid2&quot;, UUID.randomUUID().toString(), &quot;name&quot;, &quot;b1&quot;);
&nbsp;//        a1.addEdge(&quot;e1&quot;, b1, &quot;uid1&quot;, UUID.randomUUID().toString(), &quot;uid2&quot;, UUID.randomUUID().toString());
&nbsp;//
&nbsp;//        Vertex a2 = this.sqlgGraph.addVertex(T.label, &quot;A&quot;, &quot;uid1&quot;, UUID.randomUUID().toString(), &quot;uid2&quot;, UUID.randomUUID().toString(), &quot;name&quot;, &quot;a2&quot;);
&nbsp;//        Vertex c2 = this.sqlgGraph.addVertex(T.label, &quot;C&quot;, &quot;uid1&quot;, UUID.randomUUID().toString(), &quot;uid2&quot;, UUID.randomUUID().toString(), &quot;name&quot;, &quot;c2&quot;);
&nbsp;//        a2.addEdge(&quot;e1&quot;, c2, &quot;uid1&quot;, UUID.randomUUID().toString(), &quot;uid2&quot;, UUID.randomUUID().toString());
&nbsp;//
&nbsp;//        this.sqlgGraph.tx().commit();
&nbsp;//
&nbsp;//
&nbsp;//    }
&nbsp;//
&nbsp;//    @Test
&nbsp;//    public void testVertexCompositeIds() throws Exception {
&nbsp;//        this.sqlgGraph.getTopology().ensureVertexLabelExist(
&nbsp;//                &quot;Person&quot;,
&nbsp;//                new LinkedHashMap&lt;&gt;() {{
&nbsp;//                    put(&quot;name&quot;, PropertyDefinition.of(PropertyType.varChar(100)));
&nbsp;//                    put(&quot;surname&quot;, PropertyDefinition.of(PropertyType.varChar(100)));
&nbsp;//                    put(&quot;country&quot;, PropertyDefinition.of(PropertyType.varChar(100)));
&nbsp;//                }},
&nbsp;//                ListOrderedSet.listOrderedSet(Arrays.asList(&quot;name&quot;, &quot;surname&quot;))
&nbsp;//        );
&nbsp;//
&nbsp;//        Optional&lt;VertexLabel&gt; personVertexLabel = this.sqlgGraph.getTopology().getPublicSchema().getVertexLabel(&quot;Person&quot;);
&nbsp;//        Assert.assertTrue(personVertexLabel.isPresent());
&nbsp;//        Assert.assertEquals(2, personVertexLabel.get().getIdentifiers().size());
&nbsp;//        Assert.assertEquals(&quot;name&quot;, personVertexLabel.get().getIdentifiers().get(0));
&nbsp;//        Assert.assertEquals(&quot;surname&quot;, personVertexLabel.get().getIdentifiers().get(1));
&nbsp;//
&nbsp;//        //HSQLDB does not support transactional schema creation.
&nbsp;//        if (this.sqlgGraph.getSqlDialect().supportsTransactionalSchema()) {
&nbsp;//            this.sqlgGraph.tx().rollback();
&nbsp;//            personVertexLabel = this.sqlgGraph.getTopology().getPublicSchema().getVertexLabel(&quot;Person&quot;);
&nbsp;//            Assert.assertFalse(personVertexLabel.isPresent());
&nbsp;//            if (this.sqlgGraph.getSqlDialect().supportsDistribution()) {
&nbsp;//                personVertexLabel = this.sqlgGraph1.getTopology().getPublicSchema().getVertexLabel(&quot;Person&quot;);
&nbsp;//                Assert.assertFalse(personVertexLabel.isPresent());
&nbsp;//            }
&nbsp;//        }
&nbsp;//
&nbsp;//        this.sqlgGraph.getTopology().ensureVertexLabelExist(
&nbsp;//                &quot;Person&quot;,
&nbsp;//                new LinkedHashMap&lt;&gt;() {{
&nbsp;//                    put(&quot;name&quot;, PropertyDefinition.of(PropertyType.varChar(100)));
&nbsp;//                    put(&quot;surname&quot;, PropertyDefinition.of(PropertyType.varChar(100)));
&nbsp;//                    put(&quot;country&quot;, PropertyDefinition.of(PropertyType.varChar(100)));
&nbsp;//                }},
&nbsp;//                ListOrderedSet.listOrderedSet(Arrays.asList(&quot;name&quot;, &quot;surname&quot;))
&nbsp;//        );
&nbsp;//        this.sqlgGraph.tx().commit();
&nbsp;//        Thread.sleep(1000);
&nbsp;//
&nbsp;//        personVertexLabel = this.sqlgGraph.getTopology().getPublicSchema().getVertexLabel(&quot;Person&quot;);
&nbsp;//        Assert.assertTrue(personVertexLabel.isPresent());
&nbsp;//        Assert.assertEquals(2, personVertexLabel.get().getIdentifiers().size());
&nbsp;//        Assert.assertEquals(&quot;name&quot;, personVertexLabel.get().getIdentifiers().get(0));
&nbsp;//        Assert.assertEquals(&quot;surname&quot;, personVertexLabel.get().getIdentifiers().get(1));
&nbsp;//
&nbsp;//        if (isPostgres()) {
&nbsp;//            personVertexLabel = this.sqlgGraph1.getTopology().getPublicSchema().getVertexLabel(&quot;Person&quot;);
&nbsp;//            Assert.assertTrue(personVertexLabel.isPresent());
&nbsp;//            Assert.assertEquals(2, personVertexLabel.get().getIdentifiers().size());
&nbsp;//            Assert.assertEquals(&quot;name&quot;, personVertexLabel.get().getIdentifiers().get(0));
&nbsp;//            Assert.assertEquals(&quot;surname&quot;, personVertexLabel.get().getIdentifiers().get(1));
&nbsp;//        }
&nbsp;//
&nbsp;//        this.sqlgGraph.close();
&nbsp;//        this.sqlgGraph = SqlgGraph.open(configuration);
&nbsp;//        personVertexLabel = sqlgGraph.getTopology().getPublicSchema().getVertexLabel(&quot;Person&quot;);
&nbsp;//        Assert.assertTrue(personVertexLabel.isPresent());
&nbsp;//        Assert.assertEquals(2, personVertexLabel.get().getIdentifiers().size());
&nbsp;//        Assert.assertEquals(&quot;name&quot;, personVertexLabel.get().getIdentifiers().get(0));
&nbsp;//        Assert.assertEquals(&quot;surname&quot;, personVertexLabel.get().getIdentifiers().get(1));
&nbsp;//
&nbsp;//        Thread.sleep(1000);
&nbsp;//        dropSqlgSchema(sqlgGraph);
&nbsp;//        this.sqlgGraph.tx().commit();
&nbsp;//        this.sqlgGraph.close();
&nbsp;//        try (SqlgGraph sqlgGraph = SqlgGraph.open(configuration)) {
&nbsp;//            personVertexLabel = sqlgGraph.getTopology().getPublicSchema().getVertexLabel(&quot;Person&quot;);
&nbsp;//            Assert.assertTrue(personVertexLabel.isPresent());
&nbsp;//            Assert.assertEquals(2, personVertexLabel.get().getIdentifiers().size());
&nbsp;//            Assert.assertEquals(&quot;name&quot;, personVertexLabel.get().getIdentifiers().get(0));
&nbsp;//            Assert.assertEquals(&quot;surname&quot;, personVertexLabel.get().getIdentifiers().get(1));
&nbsp;//        }
&nbsp;//    }
&nbsp;
&nbsp;    @Test
&nbsp;    public void testEdgeCompositeIds() throws Exception {
<b class="fc">&nbsp;        VertexLabel personVertexLabel = this.sqlgGraph.getTopology().ensureVertexLabelExist(</b>
&nbsp;                &quot;Person&quot;,
<b class="fc">&nbsp;                new LinkedHashMap&lt;&gt;() {{</b>
<b class="fc">&nbsp;                    put(&quot;name&quot;, PropertyDefinition.of(PropertyType.varChar(100)));</b>
<b class="fc">&nbsp;                    put(&quot;surname&quot;, PropertyDefinition.of(PropertyType.varChar(100)));</b>
<b class="fc">&nbsp;                    put(&quot;country&quot;, PropertyDefinition.of(PropertyType.varChar(100)));</b>
&nbsp;                }},
<b class="fc">&nbsp;                ListOrderedSet.listOrderedSet(Arrays.asList(&quot;name&quot;, &quot;surname&quot;))</b>
&nbsp;        );
<b class="fc">&nbsp;        VertexLabel addressVertexLabel = this.sqlgGraph.getTopology().ensureVertexLabelExist(</b>
&nbsp;                &quot;Address&quot;,
<b class="fc">&nbsp;                new LinkedHashMap&lt;&gt;() {{</b>
<b class="fc">&nbsp;                    put(&quot;street&quot;, PropertyDefinition.of(PropertyType.varChar(100)));</b>
<b class="fc">&nbsp;                    put(&quot;suburb&quot;, PropertyDefinition.of(PropertyType.varChar(100)));</b>
<b class="fc">&nbsp;                    put(&quot;country&quot;, PropertyDefinition.of(PropertyType.varChar(100)));</b>
<b class="fc">&nbsp;                    put(&quot;province&quot;, PropertyDefinition.of(PropertyType.varChar(100)));</b>
&nbsp;                }},
<b class="fc">&nbsp;                ListOrderedSet.listOrderedSet(Arrays.asList(&quot;street&quot;, &quot;suburb&quot;))</b>
&nbsp;        );
<b class="fc">&nbsp;        this.sqlgGraph.tx().commit();</b>
<b class="fc">&nbsp;        this.sqlgGraph.getTopology().ensureEdgeLabelExist(</b>
&nbsp;                &quot;livesAt&quot;,
&nbsp;                personVertexLabel,
&nbsp;                addressVertexLabel,
<b class="fc">&nbsp;                new HashMap&lt;&gt;() {{</b>
<b class="fc">&nbsp;                    put(&quot;uid1&quot;, PropertyDefinition.of(PropertyType.varChar(100)));</b>
<b class="fc">&nbsp;                    put(&quot;uid2&quot;, PropertyDefinition.of(PropertyType.varChar(100)));</b>
&nbsp;                }},
<b class="fc">&nbsp;                ListOrderedSet.listOrderedSet(Arrays.asList(&quot;uid1&quot;, &quot;uid2&quot;)));</b>
&nbsp;
<b class="pc">&nbsp;        if (this.sqlgGraph.getSqlDialect().supportsTransactionalSchema()) {</b>
<b class="fc">&nbsp;            this.sqlgGraph.tx().rollback();</b>
<b class="fc">&nbsp;            Optional&lt;EdgeLabel&gt; livesAt = this.sqlgGraph.getTopology().getEdgeLabel(this.sqlgGraph.getSqlDialect().getPublicSchema(), &quot;livesAt&quot;);</b>
<b class="fc">&nbsp;            Assert.assertFalse(livesAt.isPresent());</b>
<b class="pc">&nbsp;            if (this.sqlgGraph.getSqlDialect().supportsDistribution()) {</b>
<b class="fc">&nbsp;                livesAt = this.sqlgGraph1.getTopology().getEdgeLabel(this.sqlgGraph1.getSqlDialect().getPublicSchema(), &quot;livesAt&quot;);</b>
<b class="fc">&nbsp;                Assert.assertFalse(livesAt.isPresent());</b>
&nbsp;            }
&nbsp;        }
&nbsp;
<b class="fc">&nbsp;        this.sqlgGraph.getTopology().ensureEdgeLabelExist(</b>
&nbsp;                &quot;livesAt&quot;,
&nbsp;                personVertexLabel,
&nbsp;                addressVertexLabel,
<b class="fc">&nbsp;                new HashMap&lt;&gt;() {{</b>
<b class="fc">&nbsp;                    put(&quot;uid1&quot;, PropertyDefinition.of(PropertyType.varChar(100)));</b>
<b class="fc">&nbsp;                    put(&quot;uid2&quot;, PropertyDefinition.of(PropertyType.varChar(100)));</b>
&nbsp;                }},
<b class="fc">&nbsp;                ListOrderedSet.listOrderedSet(Arrays.asList(&quot;uid1&quot;, &quot;uid2&quot;)));</b>
<b class="fc">&nbsp;        this.sqlgGraph.tx().commit();</b>
&nbsp;
<b class="fc">&nbsp;        Thread.sleep(1000);</b>
&nbsp;
<b class="fc">&nbsp;        Optional&lt;EdgeLabel&gt; livesAt = this.sqlgGraph.getTopology().getEdgeLabel(this.sqlgGraph.getSqlDialect().getPublicSchema(), &quot;livesAt&quot;);</b>
<b class="fc">&nbsp;        Assert.assertTrue(livesAt.isPresent());</b>
<b class="fc">&nbsp;        Assert.assertEquals(2, livesAt.get().getIdentifiers().size());</b>
<b class="fc">&nbsp;        Assert.assertEquals(&quot;uid1&quot;, livesAt.get().getIdentifiers().get(0));</b>
<b class="fc">&nbsp;        Assert.assertEquals(&quot;uid2&quot;, livesAt.get().getIdentifiers().get(1));</b>
&nbsp;
<b class="pc">&nbsp;        if (this.sqlgGraph.getSqlDialect().supportsDistribution()) {</b>
<b class="fc">&nbsp;            livesAt = this.sqlgGraph1.getTopology().getEdgeLabel(this.sqlgGraph1.getSqlDialect().getPublicSchema(), &quot;livesAt&quot;);</b>
<b class="fc">&nbsp;            Assert.assertTrue(livesAt.isPresent());</b>
<b class="fc">&nbsp;            Assert.assertEquals(2, livesAt.get().getIdentifiers().size());</b>
<b class="fc">&nbsp;            Assert.assertEquals(&quot;uid1&quot;, livesAt.get().getIdentifiers().get(0));</b>
<b class="fc">&nbsp;            Assert.assertEquals(&quot;uid2&quot;, livesAt.get().getIdentifiers().get(1));</b>
&nbsp;        }
&nbsp;
<b class="fc">&nbsp;        this.sqlgGraph.close();</b>
<b class="fc">&nbsp;        this.sqlgGraph = SqlgGraph.open(configuration);</b>
<b class="fc">&nbsp;        livesAt = this.sqlgGraph.getTopology().getEdgeLabel(this.sqlgGraph.getSqlDialect().getPublicSchema(), &quot;livesAt&quot;);</b>
<b class="fc">&nbsp;        Assert.assertTrue(livesAt.isPresent());</b>
<b class="fc">&nbsp;        Assert.assertEquals(2, livesAt.get().getIdentifiers().size());</b>
<b class="fc">&nbsp;        Assert.assertEquals(&quot;uid1&quot;, livesAt.get().getIdentifiers().get(0));</b>
<b class="fc">&nbsp;        Assert.assertEquals(&quot;uid2&quot;, livesAt.get().getIdentifiers().get(1));</b>
&nbsp;
<b class="fc">&nbsp;        Thread.sleep(1000);</b>
&nbsp;
<b class="fc">&nbsp;        dropSqlgSchema(this.sqlgGraph);</b>
<b class="fc">&nbsp;        this.sqlgGraph.tx().commit();</b>
<b class="fc">&nbsp;        this.sqlgGraph.close();</b>
&nbsp;
<b class="fc">&nbsp;        this.sqlgGraph = SqlgGraph.open(configuration);</b>
<b class="fc">&nbsp;        livesAt = this.sqlgGraph.getTopology().getEdgeLabel(this.sqlgGraph.getSqlDialect().getPublicSchema(), &quot;livesAt&quot;);</b>
<b class="fc">&nbsp;        Assert.assertTrue(livesAt.isPresent());</b>
&nbsp;
<b class="fc">&nbsp;        List&lt;Vertex&gt; edgeLabels = sqlgGraph.topology()</b>
<b class="fc">&nbsp;                .V().hasLabel(SQLG_SCHEMA + &quot;.&quot; + Topology.SQLG_SCHEMA_SCHEMA).has(Topology.SQLG_SCHEMA_SCHEMA_NAME, this.sqlgGraph.getSqlDialect().getPublicSchema())</b>
<b class="fc">&nbsp;                .out(SQLG_SCHEMA_SCHEMA_VERTEX_EDGE)</b>
<b class="fc">&nbsp;                .out(SQLG_SCHEMA_OUT_EDGES_EDGE)</b>
<b class="fc">&nbsp;                .has(Topology.SQLG_SCHEMA_EDGE_LABEL_NAME, &quot;livesAt&quot;)</b>
<b class="fc">&nbsp;                .toList();</b>
<b class="pc">&nbsp;        Preconditions.checkState(edgeLabels.size() == 1, &quot;BUG: There can only ever be one EdgeLabel vertex, found %s&quot;, edgeLabels.size());</b>
&nbsp;
<b class="fc">&nbsp;        Assert.assertEquals(2, livesAt.get().getIdentifiers().size());</b>
<b class="fc">&nbsp;        Assert.assertEquals(&quot;uid1&quot;, livesAt.get().getIdentifiers().get(0));</b>
<b class="fc">&nbsp;        Assert.assertEquals(&quot;uid2&quot;, livesAt.get().getIdentifiers().get(1));</b>
&nbsp;    }
&nbsp;
&nbsp;//    @Test
&nbsp;//    public void testEdgeNormal() throws Exception {
&nbsp;//        VertexLabel personVertexLabel = this.sqlgGraph.getTopology().ensureVertexLabelExist(
&nbsp;//                &quot;Person&quot;,
&nbsp;//                new LinkedHashMap&lt;&gt;() {{
&nbsp;//                    put(&quot;name&quot;, PropertyDefinition.of(PropertyType.varChar(100)));
&nbsp;//                    put(&quot;surname&quot;, PropertyDefinition.of(PropertyType.varChar(100)));
&nbsp;//                    put(&quot;country&quot;, PropertyDefinition.of(PropertyType.varChar(100)));
&nbsp;//                }});
&nbsp;//        VertexLabel addressVertexLabel = this.sqlgGraph.getTopology().ensureVertexLabelExist(
&nbsp;//                &quot;Address&quot;,
&nbsp;//                new LinkedHashMap&lt;&gt;() {{
&nbsp;//                    put(&quot;street&quot;, PropertyDefinition.of(PropertyType.varChar(100)));
&nbsp;//                    put(&quot;suburb&quot;, PropertyDefinition.of(PropertyType.varChar(100)));
&nbsp;//                    put(&quot;country&quot;, PropertyDefinition.of(PropertyType.varChar(100)));
&nbsp;//                    put(&quot;province&quot;, PropertyDefinition.of(PropertyType.varChar(100)));
&nbsp;//                }});
&nbsp;//        this.sqlgGraph.tx().commit();
&nbsp;//        this.sqlgGraph.getTopology().ensureEdgeLabelExist(
&nbsp;//                &quot;livesAt&quot;,
&nbsp;//                personVertexLabel,
&nbsp;//                addressVertexLabel,
&nbsp;//                new HashMap&lt;&gt;() {{
&nbsp;//                    put(&quot;uid1&quot;, PropertyDefinition.of(PropertyType.varChar(100)));
&nbsp;//                    put(&quot;uid2&quot;, PropertyDefinition.of(PropertyType.varChar(100)));
&nbsp;//                }});
&nbsp;//        this.sqlgGraph.tx().rollback();
&nbsp;//
&nbsp;//        if (this.sqlgGraph.getSqlDialect().supportsTransactionalSchema()) {
&nbsp;//            Optional&lt;EdgeLabel&gt; livesAt = this.sqlgGraph.getTopology().getEdgeLabel(this.sqlgGraph.getSqlDialect().getPublicSchema(), &quot;livesAt&quot;);
&nbsp;//            Assert.assertFalse(livesAt.isPresent());
&nbsp;//        }
&nbsp;//        if (this.sqlgGraph.getSqlDialect().supportsDistribution()) {
&nbsp;//            Optional&lt;EdgeLabel&gt; livesAt = this.sqlgGraph1.getTopology().getEdgeLabel(this.sqlgGraph1.getSqlDialect().getPublicSchema(), &quot;livesAt&quot;);
&nbsp;//            Assert.assertFalse(livesAt.isPresent());
&nbsp;//        }
&nbsp;//
&nbsp;//        this.sqlgGraph.getTopology().ensureEdgeLabelExist(
&nbsp;//                &quot;livesAt&quot;,
&nbsp;//                personVertexLabel,
&nbsp;//                addressVertexLabel,
&nbsp;//                new HashMap&lt;&gt;() {{
&nbsp;//                    put(&quot;uid1&quot;, PropertyDefinition.of(PropertyType.varChar(100)));
&nbsp;//                    put(&quot;uid2&quot;, PropertyDefinition.of(PropertyType.varChar(100)));
&nbsp;//                }});
&nbsp;//        this.sqlgGraph.tx().commit();
&nbsp;//
&nbsp;//        Thread.sleep(1000);
&nbsp;//
&nbsp;//        Optional&lt;EdgeLabel&gt; livesAt = this.sqlgGraph.getTopology().getEdgeLabel(this.sqlgGraph.getSqlDialect().getPublicSchema(), &quot;livesAt&quot;);
&nbsp;//        Assert.assertTrue(livesAt.isPresent());
&nbsp;//
&nbsp;//        if (this.sqlgGraph.getSqlDialect().supportsDistribution()) {
&nbsp;//            livesAt = this.sqlgGraph1.getTopology().getEdgeLabel(this.sqlgGraph1.getSqlDialect().getPublicSchema(), &quot;livesAt&quot;);
&nbsp;//            Assert.assertTrue(livesAt.isPresent());
&nbsp;//        }
&nbsp;//
&nbsp;//        this.sqlgGraph.close();
&nbsp;//        this.sqlgGraph = SqlgGraph.open(configuration);
&nbsp;//        livesAt = this.sqlgGraph.getTopology().getEdgeLabel(this.sqlgGraph.getSqlDialect().getPublicSchema(), &quot;livesAt&quot;);
&nbsp;//        Assert.assertTrue(livesAt.isPresent());
&nbsp;//
&nbsp;//        Thread.sleep(1000);
&nbsp;//
&nbsp;//        dropSqlgSchema(this.sqlgGraph);
&nbsp;//        this.sqlgGraph.tx().commit();
&nbsp;//        this.sqlgGraph.close();
&nbsp;//
&nbsp;//        this.sqlgGraph = SqlgGraph.open(configuration);
&nbsp;//        livesAt = this.sqlgGraph.getTopology().getEdgeLabel(this.sqlgGraph.getSqlDialect().getPublicSchema(), &quot;livesAt&quot;);
&nbsp;//        Assert.assertTrue(livesAt.isPresent());
&nbsp;//    }
&nbsp;//
&nbsp;//    @SuppressWarnings(&quot;unchecked&quot;)
&nbsp;//    @Test
&nbsp;//    public void testDuplicatePath() {
&nbsp;//        VertexLabel vertexLabel = this.sqlgGraph.getTopology().getPublicSchema().ensureVertexLabelExist(
&nbsp;//                &quot;A&quot;,
&nbsp;//                new LinkedHashMap&lt;&gt;() {{
&nbsp;//                    put(&quot;uid&quot;, PropertyDefinition.of(PropertyType.varChar(100)));
&nbsp;//                    put(&quot;name&quot;, PropertyDefinition.of(PropertyType.varChar(100)));
&nbsp;//                    put(&quot;age&quot;, PropertyDefinition.of(PropertyType.INTEGER));
&nbsp;//                }},
&nbsp;//                ListOrderedSet.listOrderedSet(List.of(&quot;uid&quot;))
&nbsp;//        );
&nbsp;//        vertexLabel.ensureEdgeLabelExist(
&nbsp;//                &quot;aa&quot;,
&nbsp;//                vertexLabel,
&nbsp;//                new LinkedHashMap&lt;&gt;() {{
&nbsp;//                    put(&quot;uid&quot;, PropertyDefinition.of(PropertyType.varChar(100)));
&nbsp;//                }},
&nbsp;//                ListOrderedSet.listOrderedSet(List.of(&quot;uid&quot;)));
&nbsp;//        this.sqlgGraph.tx().commit();
&nbsp;//        Vertex a1 = this.sqlgGraph.addVertex(T.label, &quot;A&quot;, &quot;uid&quot;, UUID.randomUUID().toString(), &quot;name&quot;, &quot;a1&quot;, &quot;age&quot;, 1);
&nbsp;//        Vertex a2 = this.sqlgGraph.addVertex(T.label, &quot;A&quot;, &quot;uid&quot;, UUID.randomUUID().toString(), &quot;name&quot;, &quot;a2&quot;, &quot;age&quot;, 5);
&nbsp;//        Vertex a3 = this.sqlgGraph.addVertex(T.label, &quot;A&quot;, &quot;uid&quot;, UUID.randomUUID().toString(), &quot;name&quot;, &quot;a3&quot;, &quot;age&quot;, 7);
&nbsp;//        Vertex a4 = this.sqlgGraph.addVertex(T.label, &quot;A&quot;, &quot;uid&quot;, UUID.randomUUID().toString(), &quot;name&quot;, &quot;a4&quot;, &quot;age&quot;, 5);
&nbsp;//        a1.addEdge(&quot;aa&quot;, a2, &quot;uid&quot;, UUID.randomUUID().toString());
&nbsp;//        a1.addEdge(&quot;aa&quot;, a3, &quot;uid&quot;, UUID.randomUUID().toString());
&nbsp;//        a1.addEdge(&quot;aa&quot;, a4, &quot;uid&quot;, UUID.randomUUID().toString());
&nbsp;//        this.sqlgGraph.tx().commit();
&nbsp;//
&nbsp;//        DefaultTraversal&lt;Vertex, Integer&gt; traversal = (DefaultTraversal) this.sqlgGraph.traversal().V(a1).out(&quot;aa&quot;).values(&quot;age&quot;);
&nbsp;//        String sql = getSQL(traversal);
&nbsp;//        List&lt;Integer&gt; results = traversal.toList();
&nbsp;//        Assert.assertEquals(2, traversal.getSteps().size());
&nbsp;//        Assert.assertTrue(traversal.getSteps().get(0) instanceof SqlgGraphStep);
&nbsp;//        Assert.assertTrue(traversal.getSteps().get(1) instanceof SqlgPropertiesStep);
&nbsp;//        Assert.assertEquals(3, results.size(), 0);
&nbsp;//        Assert.assertTrue(results.remove(Integer.valueOf(5)));
&nbsp;//        Assert.assertTrue(results.remove(Integer.valueOf(7)));
&nbsp;//        Assert.assertTrue(results.remove(Integer.valueOf(5)));
&nbsp;//
&nbsp;//    }
&nbsp;}
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2024-04-27 19:01</div>
</div>
</body>
</html>
