<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 2.0.23">
<meta name="description" content="Sqlg's documentation">
<meta name="keywords" content="Sqlg, TinkerPop, Gremlin, Graph, Database">
<meta name="author" content="Pieter Martin">
<title>Sqlg Documentation</title>
<style>
/* Asciidoctor default stylesheet | MIT License | https://asciidoctor.org */
/* Uncomment @import statement to use as custom stylesheet */
/*@import "https://fonts.googleapis.com/css?family=Open+Sans:300,300italic,400,400italic,600,600italic%7CNoto+Serif:400,400italic,700,700italic%7CDroid+Sans+Mono:400,700";*/
article, aside, details, figcaption, figure, footer, header, hgroup, main, nav, section {
    display: block
}

audio, video {
    display: inline-block
}

audio:not([controls]) {
    display: none;
    height: 0
}

html {
    font-family: sans-serif;
    -ms-text-size-adjust: 100%;
    -webkit-text-size-adjust: 100%
}

a {
    background: none
}

a:focus {
    outline: thin dotted
}

a:active, a:hover {
    outline: 0
}

h1 {
    font-size: 2em;
    margin: .67em 0
}

abbr[title] {
    border-bottom: 1px dotted
}

b, strong {
    font-weight: bold
}

dfn {
    font-style: italic
}

hr {
    -moz-box-sizing: content-box;
    box-sizing: content-box;
    height: 0
}

mark {
    background: #ff0;
    color: #000
}

code, kbd, pre, samp {
    font-family: monospace;
    font-size: 1em
}

pre {
    white-space: pre-wrap
}

q {
    quotes: "\201C" "\201D" "\2018" "\2019"
}

small {
    font-size: 80%
}

sub, sup {
    font-size: 75%;
    line-height: 0;
    position: relative;
    vertical-align: baseline
}

sup {
    top: -.5em
}

sub {
    bottom: -.25em
}

img {
    border: 0
}

svg:not(:root) {
    overflow: hidden
}

figure {
    margin: 0
}

fieldset {
    border: 1px solid silver;
    margin: 0 2px;
    padding: .35em .625em .75em
}

legend {
    border: 0;
    padding: 0
}

button, input, select, textarea {
    font-family: inherit;
    font-size: 100%;
    margin: 0
}

button, input {
    line-height: normal
}

button, select {
    text-transform: none
}

button, html input[type="button"], input[type="reset"], input[type="submit"] {
    -webkit-appearance: button;
    cursor: pointer
}

button[disabled], html input[disabled] {
    cursor: default
}

input[type="checkbox"], input[type="radio"] {
    box-sizing: border-box;
    padding: 0
}

button::-moz-focus-inner, input::-moz-focus-inner {
    border: 0;
    padding: 0
}

textarea {
    overflow: auto;
    vertical-align: top
}

table {
    border-collapse: collapse;
    border-spacing: 0
}

*, *::before, *::after {
    -moz-box-sizing: border-box;
    -webkit-box-sizing: border-box;
    box-sizing: border-box
}

html, body {
    font-size: 100%
}

body {
    background: #fff;
    color: rgba(0, 0, 0, .8);
    padding: 0;
    margin: 0;
    font-family: "Noto Serif", "DejaVu Serif", serif;
    font-weight: 400;
    font-style: normal;
    line-height: 1;
    position: relative;
    cursor: auto;
    tab-size: 4;
    word-wrap: anywhere;
    -moz-osx-font-smoothing: grayscale;
    -webkit-font-smoothing: antialiased
}

a:hover {
    cursor: pointer
}

img, object, embed {
    max-width: 100%;
    height: auto
}

object, embed {
    height: 100%
}

img {
    -ms-interpolation-mode: bicubic
}

.left {
    float: left !important
}

.right {
    float: right !important
}

.text-left {
    text-align: left !important
}

.text-right {
    text-align: right !important
}

.text-center {
    text-align: center !important
}

.text-justify {
    text-align: justify !important
}

.hide {
    display: none
}

img, object, svg {
    display: inline-block;
    vertical-align: middle
}

textarea {
    height: auto;
    min-height: 50px
}

select {
    width: 100%
}

.subheader, .admonitionblock td.content > .title, .audioblock > .title, .exampleblock > .title, .imageblock > .title, .listingblock > .title, .literalblock > .title, .stemblock > .title, .openblock > .title, .paragraph > .title, .quoteblock > .title, table.tableblock > .title, .verseblock > .title, .videoblock > .title, .dlist > .title, .olist > .title, .ulist > .title, .qlist > .title, .hdlist > .title {
    line-height: 1.45;
    color: #7a2518;
    font-weight: 400;
    margin-top: 0;
    margin-bottom: .25em
}

div, dl, dt, dd, ul, ol, li, h1, h2, h3, #toctitle, .sidebarblock > .content > .title, h4, h5, h6, pre, form, p, blockquote, th, td {
    margin: 0;
    padding: 0
}

a {
    color: #2156a5;
    text-decoration: underline;
    line-height: inherit
}

a:hover, a:focus {
    color: #1d4b8f
}

a img {
    border: 0
}

p {
    font-family: inherit;
    font-weight: 400;
    font-size: 1em;
    line-height: 1.6;
    margin-bottom: 1.25em;
    text-rendering: optimizeLegibility
}

p aside {
    font-size: .875em;
    line-height: 1.35;
    font-style: italic
}

h1, h2, h3, #toctitle, .sidebarblock > .content > .title, h4, h5, h6 {
    font-family: "Open Sans", "DejaVu Sans", sans-serif;
    font-weight: 300;
    font-style: normal;
    color: #ba3925;
    text-rendering: optimizeLegibility;
    margin-top: 1em;
    margin-bottom: .5em;
    line-height: 1.0125em
}

h1 small, h2 small, h3 small, #toctitle small, .sidebarblock > .content > .title small, h4 small, h5 small, h6 small {
    font-size: 60%;
    color: #e99b8f;
    line-height: 0
}

h1 {
    font-size: 2.125em
}

h2 {
    font-size: 1.6875em
}

h3, #toctitle, .sidebarblock > .content > .title {
    font-size: 1.375em
}

h4, h5 {
    font-size: 1.125em
}

h6 {
    font-size: 1em
}

hr {
    border: solid #dddddf;
    border-width: 1px 0 0;
    clear: both;
    margin: 1.25em 0 1.1875em;
    height: 0
}

em, i {
    font-style: italic;
    line-height: inherit
}

strong, b {
    font-weight: bold;
    line-height: inherit
}

small {
    font-size: 60%;
    line-height: inherit
}

code {
    font-family: "Droid Sans Mono", "DejaVu Sans Mono", monospace;
    font-weight: 400;
    color: rgba(0, 0, 0, .9)
}

ul, ol, dl {
    font-size: 1em;
    line-height: 1.6;
    margin-bottom: 1.25em;
    list-style-position: outside;
    font-family: inherit
}

ul, ol {
    margin-left: 1.5em
}

ul li ul, ul li ol {
    margin-left: 1.25em;
    margin-bottom: 0;
    font-size: 1em
}

ul.square li ul, ul.circle li ul, ul.disc li ul {
    list-style: inherit
}

ul.square {
    list-style-type: square
}

ul.circle {
    list-style-type: circle
}

ul.disc {
    list-style-type: disc
}

ol li ul, ol li ol {
    margin-left: 1.25em;
    margin-bottom: 0
}

dl dt {
    margin-bottom: .3125em;
    font-weight: bold
}

dl dd {
    margin-bottom: 1.25em
}

abbr, acronym {
    text-transform: uppercase;
    font-size: 90%;
    color: rgba(0, 0, 0, .8);
    border-bottom: 1px dotted #ddd;
    cursor: help
}

abbr {
    text-transform: none
}

blockquote {
    margin: 0 0 1.25em;
    padding: .5625em 1.25em 0 1.1875em;
    border-left: 1px solid #ddd
}

blockquote, blockquote p {
    line-height: 1.6;
    color: rgba(0, 0, 0, .85)
}

@media screen and (min-width: 768px) {
    h1, h2, h3, #toctitle, .sidebarblock > .content > .title, h4, h5, h6 {
        line-height: 1.2
    }

    h1 {
        font-size: 2.75em
    }

    h2 {
        font-size: 2.3125em
    }

    h3, #toctitle, .sidebarblock > .content > .title {
        font-size: 1.6875em
    }

    h4 {
        font-size: 1.4375em
    }
}

table {
    background: #fff;
    margin-bottom: 1.25em;
    border: solid 1px #dedede;
    word-wrap: normal
}

table thead, table tfoot {
    background: #f7f8f7
}

table thead tr th, table thead tr td, table tfoot tr th, table tfoot tr td {
    padding: .5em .625em .625em;
    font-size: inherit;
    color: rgba(0, 0, 0, .8);
    text-align: left
}

table tr th, table tr td {
    padding: .5625em .625em;
    font-size: inherit;
    color: rgba(0, 0, 0, .8)
}

table tr.even, table tr.alt {
    background: #f8f8f7
}

table thead tr th, table tfoot tr th, table tbody tr td, table tr td, table tfoot tr td {
    line-height: 1.6
}

h1, h2, h3, #toctitle, .sidebarblock > .content > .title, h4, h5, h6 {
    line-height: 1.2;
    word-spacing: -.05em
}

h1 strong, h2 strong, h3 strong, #toctitle strong, .sidebarblock > .content > .title strong, h4 strong, h5 strong, h6 strong {
    font-weight: 400
}

.center {
    margin-left: auto;
    margin-right: auto
}

.stretch {
    width: 100%
}

.clearfix::before, .clearfix::after, .float-group::before, .float-group::after {
    content: " ";
    display: table
}

.clearfix::after, .float-group::after {
    clear: both
}

:not(pre).nobreak {
    word-wrap: normal
}

:not(pre).nowrap {
    white-space: nowrap
}

:not(pre).pre-wrap {
    white-space: pre-wrap
}

:not(pre):not([class^=L]) > code {
    font-size: .9375em;
    font-style: normal !important;
    letter-spacing: 0;
    padding: .1em .5ex;
    word-spacing: -.15em;
    background: #f7f7f8;
    -webkit-border-radius: 4px;
    border-radius: 4px;
    line-height: 1.45;
    text-rendering: optimizeSpeed
}

pre {
    color: rgba(0, 0, 0, .9);
    font-family: "Droid Sans Mono", "DejaVu Sans Mono", monospace;
    line-height: 1.45;
    text-rendering: optimizeSpeed
}

pre code, pre pre {
    color: inherit;
    font-size: inherit;
    line-height: inherit
}

pre > code {
    display: block
}

pre.nowrap, pre.nowrap pre {
    white-space: pre;
    word-wrap: normal
}

em em {
    font-style: normal
}

strong strong {
    font-weight: 400
}

.keyseq {
    color: rgba(51, 51, 51, .8)
}

kbd {
    font-family: "Droid Sans Mono", "DejaVu Sans Mono", monospace;
    display: inline-block;
    color: rgba(0, 0, 0, .8);
    font-size: .65em;
    line-height: 1.45;
    background: #f7f7f7;
    border: 1px solid #ccc;
    -webkit-border-radius: 3px;
    border-radius: 3px;
    -webkit-box-shadow: 0 1px 0 rgba(0, 0, 0, .2), 0 0 0 .1em white inset;
    box-shadow: 0 1px 0 rgba(0, 0, 0, .2), 0 0 0 .1em #fff inset;
    margin: 0 .15em;
    padding: .2em .5em;
    vertical-align: middle;
    position: relative;
    top: -.1em;
    white-space: nowrap
}

.keyseq kbd:first-child {
    margin-left: 0
}

.keyseq kbd:last-child {
    margin-right: 0
}

.menuseq, .menuref {
    color: #000
}

.menuseq b:not(.caret), .menuref {
    font-weight: inherit
}

.menuseq {
    word-spacing: -.02em
}

.menuseq b.caret {
    font-size: 1.25em;
    line-height: .8
}

.menuseq i.caret {
    font-weight: bold;
    text-align: center;
    width: .45em
}

b.button::before, b.button::after {
    position: relative;
    top: -1px;
    font-weight: 400
}

b.button::before {
    content: "[";
    padding: 0 3px 0 2px
}

b.button::after {
    content: "]";
    padding: 0 2px 0 3px
}

p a > code:hover {
    color: rgba(0, 0, 0, .9)
}

#header, #content, #footnotes, #footer {
    width: 100%;
    margin-left: auto;
    margin-right: auto;
    margin-top: 0;
    margin-bottom: 0;
    max-width: 62.5em;
    *zoom: 1;
    position: relative;
    padding-left: .9375em;
    padding-right: .9375em
}

#header::before, #header::after, #content::before, #content::after, #footnotes::before, #footnotes::after, #footer::before, #footer::after {
    content: " ";
    display: table
}

#header::after, #content::after, #footnotes::after, #footer::after {
    clear: both
}

#content {
    margin-top: 1.25em
}

#content::before {
    content: none
}

#header > h1:first-child {
    color: rgba(0, 0, 0, .85);
    margin-top: 2.25rem;
    margin-bottom: 0
}

#header > h1:first-child + #toc {
    margin-top: 8px;
    border-top: 1px solid #dddddf
}

#header > h1:only-child, body.toc2 #header > h1:nth-last-child(2) {
    border-bottom: 1px solid #dddddf;
    padding-bottom: 8px
}

#header .details {
    border-bottom: 1px solid #dddddf;
    line-height: 1.45;
    padding-top: .25em;
    padding-bottom: .25em;
    padding-left: .25em;
    color: rgba(0, 0, 0, .6);
    display: -ms-flexbox;
    display: -webkit-flex;
    display: flex;
    -ms-flex-flow: row wrap;
    -webkit-flex-flow: row wrap;
    flex-flow: row wrap
}

#header .details span:first-child {
    margin-left: -.125em
}

#header .details span.email a {
    color: rgba(0, 0, 0, .85)
}

#header .details br {
    display: none
}

#header .details br + span::before {
    content: "\00a0\2013\00a0"
}

#header .details br + span.author::before {
    content: "\00a0\22c5\00a0";
    color: rgba(0, 0, 0, .85)
}

#header .details br + span#revremark::before {
    content: "\00a0|\00a0"
}

#header #revnumber {
    text-transform: capitalize
}

#header #revnumber::after {
    content: "\00a0"
}

#content > h1:first-child:not([class]) {
    color: rgba(0, 0, 0, .85);
    border-bottom: 1px solid #dddddf;
    padding-bottom: 8px;
    margin-top: 0;
    padding-top: 1rem;
    margin-bottom: 1.25rem
}

#toc {
    border-bottom: 1px solid #e7e7e9;
    padding-bottom: .5em
}

#toc > ul {
    margin-left: .125em
}

#toc ul.sectlevel0 > li > a {
    font-style: italic
}

#toc ul.sectlevel0 ul.sectlevel1 {
    margin: .5em 0
}

#toc ul {
    font-family: "Open Sans", "DejaVu Sans", sans-serif;
    list-style-type: none
}

#toc li {
    line-height: 1.3334;
    margin-top: .3334em;
    list-style: none;
}

#toc a {
    text-decoration: none
}

#toc a:active {
    text-decoration: underline
}

#toctitle {
    color: #7a2518;
    font-size: 1.2em
}

@media screen and (min-width: 768px) {
    #toctitle {
        font-size: 1.375em
    }

    body.toc2 {
        padding-left: 15em;
        padding-right: 0
    }

    #toc.toc2 {
        margin-top: 0 !important;
        background: #f8f8f7;
        position: fixed;
        width: 15em;
        left: 0;
        top: 0;
        border-right: 1px solid #e7e7e9;
        border-top-width: 0 !important;
        border-bottom-width: 0 !important;
        z-index: 1000;
        padding: 1.25em 1em;
        height: 100%;
        overflow: auto
    }

    #toc.toc2 #toctitle {
        margin-top: 0;
        margin-bottom: .8rem;
        font-size: 1.2em
    }

    #toc.toc2 > ul {
        font-size: .9em;
        margin-bottom: 0
    }

    #toc.toc2 ul ul {
        margin-left: 0;
        padding-left: 1em
    }

    #toc.toc2 ul.sectlevel0 ul.sectlevel1 {
        padding-left: 0;
        margin-top: .5em;
        margin-bottom: .5em
    }

    body.toc2.toc-right {
        padding-left: 0;
        padding-right: 15em
    }

    body.toc2.toc-right #toc.toc2 {
        border-right-width: 0;
        border-left: 1px solid #e7e7e9;
        left: auto;
        right: 0
    }
}

@media screen and (min-width: 1280px) {
    body.toc2 {
        padding-left: 20em;
        padding-right: 0
    }

    #toc.toc2 {
        width: 20em
    }

    #toc.toc2 #toctitle {
        font-size: 1.375em
    }

    #toc.toc2 > ul {
        font-size: .95em
    }

    #toc.toc2 ul ul {
        padding-left: 1.25em
    }

    body.toc2.toc-right {
        padding-left: 0;
        padding-right: 20em
    }
}

#content #toc {
    border-style: solid;
    border-width: 1px;
    border-color: #e0e0dc;
    margin-bottom: 1.25em;
    padding: 1.25em;
    background: #f8f8f7;
    -webkit-border-radius: 4px;
    border-radius: 4px
}

#content #toc > :first-child {
    margin-top: 0
}

#content #toc > :last-child {
    margin-bottom: 0
}

#footer {
    max-width: none;
    background: rgba(0, 0, 0, .8);
    padding: 1.25em
}

#footer-text {
    color: rgba(255, 255, 255, .8);
    line-height: 1.44
}

#content {
    margin-bottom: .625em
}

.sect1 {
    padding-bottom: .625em
}

@media screen and (min-width: 768px) {
    #content {
        margin-bottom: 1.25em
    }

    .sect1 {
        padding-bottom: 1.25em
    }
}

.sect1:last-child {
    padding-bottom: 0
}

.sect1 + .sect1 {
    border-top: 1px solid #e7e7e9
}

#content h1 > a.anchor, h2 > a.anchor, h3 > a.anchor, #toctitle > a.anchor, .sidebarblock > .content > .title > a.anchor, h4 > a.anchor, h5 > a.anchor, h6 > a.anchor {
    position: absolute;
    z-index: 1001;
    width: 1.5ex;
    margin-left: -1.5ex;
    display: block;
    text-decoration: none !important;
    visibility: hidden;
    text-align: center;
    font-weight: 400
}

#content h1 > a.anchor::before, h2 > a.anchor::before, h3 > a.anchor::before, #toctitle > a.anchor::before, .sidebarblock > .content > .title > a.anchor::before, h4 > a.anchor::before, h5 > a.anchor::before, h6 > a.anchor::before {
    content: "\00A7";
    font-size: .85em;
    display: block;
    padding-top: .1em
}

#content h1:hover > a.anchor, #content h1 > a.anchor:hover, h2:hover > a.anchor, h2 > a.anchor:hover, h3:hover > a.anchor, #toctitle:hover > a.anchor, .sidebarblock > .content > .title:hover > a.anchor, h3 > a.anchor:hover, #toctitle > a.anchor:hover, .sidebarblock > .content > .title > a.anchor:hover, h4:hover > a.anchor, h4 > a.anchor:hover, h5:hover > a.anchor, h5 > a.anchor:hover, h6:hover > a.anchor, h6 > a.anchor:hover {
    visibility: visible
}

#content h1 > a.link, h2 > a.link, h3 > a.link, #toctitle > a.link, .sidebarblock > .content > .title > a.link, h4 > a.link, h5 > a.link, h6 > a.link {
    color: #ba3925;
    text-decoration: none
}

#content h1 > a.link:hover, h2 > a.link:hover, h3 > a.link:hover, #toctitle > a.link:hover, .sidebarblock > .content > .title > a.link:hover, h4 > a.link:hover, h5 > a.link:hover, h6 > a.link:hover {
    color: #a53221
}

details, .audioblock, .imageblock, .literalblock, .listingblock, .stemblock, .videoblock {
    margin-bottom: 1.25em
}

details > summary:first-of-type {
    cursor: pointer;
    display: list-item;
    outline: none;
    margin-bottom: .75em
}

.admonitionblock td.content > .title, .audioblock > .title, .exampleblock > .title, .imageblock > .title, .listingblock > .title, .literalblock > .title, .stemblock > .title, .openblock > .title, .paragraph > .title, .quoteblock > .title, table.tableblock > .title, .verseblock > .title, .videoblock > .title, .dlist > .title, .olist > .title, .ulist > .title, .qlist > .title, .hdlist > .title {
    text-rendering: optimizeLegibility;
    text-align: left;
    font-family: "Noto Serif", "DejaVu Serif", serif;
    font-size: 1rem;
    font-style: italic
}

table.tableblock.fit-content > caption.title {
    white-space: nowrap;
    width: 0
}

.paragraph.lead > p, #preamble > .sectionbody > [class="paragraph"]:first-of-type p {
    font-size: 1.21875em;
    line-height: 1.6;
    color: rgba(0, 0, 0, .85)
}

table.tableblock #preamble > .sectionbody > [class="paragraph"]:first-of-type p {
    font-size: inherit
}

.admonitionblock > table {
    border-collapse: separate;
    border: 0;
    background: none;
    width: 100%
}

.admonitionblock > table td.icon {
    text-align: center;
    width: 80px
}

.admonitionblock > table td.icon img {
    max-width: none
}

.admonitionblock > table td.icon .title {
    font-weight: bold;
    font-family: "Open Sans", "DejaVu Sans", sans-serif;
    text-transform: uppercase
}

.admonitionblock > table td.content {
    padding-left: 1.125em;
    padding-right: 1.25em;
    border-left: 1px solid #dddddf;
    color: rgba(0, 0, 0, .6);
    word-wrap: anywhere
}

.admonitionblock > table td.content > :last-child > :last-child {
    margin-bottom: 0
}

.exampleblock > .content {
    border-style: solid;
    border-width: 1px;
    border-color: #e6e6e6;
    margin-bottom: 1.25em;
    padding: 1.25em;
    background: #fff;
    -webkit-border-radius: 4px;
    border-radius: 4px
}

.exampleblock > .content > :first-child {
    margin-top: 0
}

.exampleblock > .content > :last-child {
    margin-bottom: 0
}

.sidebarblock {
    border-style: solid;
    border-width: 1px;
    border-color: #dbdbd6;
    margin-bottom: 1.25em;
    padding: 1.25em;
    background: #f3f3f2;
    -webkit-border-radius: 4px;
    border-radius: 4px
}

.sidebarblock > :first-child {
    margin-top: 0
}

.sidebarblock > :last-child {
    margin-bottom: 0
}

.sidebarblock > .content > .title {
    color: #7a2518;
    margin-top: 0;
    text-align: center
}

.exampleblock > .content > :last-child > :last-child, .exampleblock > .content .olist > ol > li:last-child > :last-child, .exampleblock > .content .ulist > ul > li:last-child > :last-child, .exampleblock > .content .qlist > ol > li:last-child > :last-child, .sidebarblock > .content > :last-child > :last-child, .sidebarblock > .content .olist > ol > li:last-child > :last-child, .sidebarblock > .content .ulist > ul > li:last-child > :last-child, .sidebarblock > .content .qlist > ol > li:last-child > :last-child {
    margin-bottom: 0
}

.literalblock pre, .listingblock > .content > pre {
    -webkit-border-radius: 4px;
    border-radius: 4px;
    overflow-x: auto;
    padding: 1em;
    font-size: .8125em
}

@media screen and (min-width: 768px) {
    .literalblock pre, .listingblock > .content > pre {
        font-size: .90625em
    }
}

@media screen and (min-width: 1280px) {
    .literalblock pre, .listingblock > .content > pre {
        font-size: 1em
    }
}

.literalblock pre, .listingblock > .content > pre:not(.highlight), .listingblock > .content > pre[class="highlight"], .listingblock > .content > pre[class^="highlight "] {
    background: #f7f7f8
}

.literalblock.output pre {
    color: #f7f7f8;
    background: rgba(0, 0, 0, .9)
}

.listingblock > .content {
    position: relative
}

.listingblock code[data-lang]::before {
    display: none;
    content: attr(data-lang);
    position: absolute;
    font-size: .75em;
    top: .425rem;
    right: .5rem;
    line-height: 1;
    text-transform: uppercase;
    color: inherit;
    opacity: .5
}

.listingblock:hover code[data-lang]::before {
    display: block
}

.listingblock.terminal pre .command::before {
    content: attr(data-prompt);
    padding-right: .5em;
    color: inherit;
    opacity: .5
}

.listingblock.terminal pre .command:not([data-prompt])::before {
    content: "$"
}

.listingblock pre.highlightjs {
    padding: 0
}

.listingblock pre.highlightjs > code {
    padding: 1em;
    -webkit-border-radius: 4px;
    border-radius: 4px
}

.listingblock pre.prettyprint {
    border-width: 0
}

.prettyprint {
    background: #f7f7f8
}

pre.prettyprint .linenums {
    line-height: 1.45;
    margin-left: 2em
}

pre.prettyprint li {
    background: none;
    list-style-type: inherit;
    padding-left: 0
}

pre.prettyprint li code[data-lang]::before {
    opacity: 1
}

pre.prettyprint li:not(:first-child) code[data-lang]::before {
    display: none
}

table.linenotable {
    border-collapse: separate;
    border: 0;
    margin-bottom: 0;
    background: none
}

table.linenotable td[class] {
    color: inherit;
    vertical-align: top;
    padding: 0;
    line-height: inherit;
    white-space: normal
}

table.linenotable td.code {
    padding-left: .75em
}

table.linenotable td.linenos {
    border-right: 1px solid currentColor;
    opacity: .35;
    padding-right: .5em
}

pre.pygments .lineno {
    border-right: 1px solid currentColor;
    opacity: .35;
    display: inline-block;
    margin-right: .75em
}

pre.pygments .lineno::before {
    content: "";
    margin-right: -.125em
}

.quoteblock {
    margin: 0 1em 1.25em 1.5em;
    display: table
}

.quoteblock:not(.excerpt) > .title {
    margin-left: -1.5em;
    margin-bottom: .75em
}

.quoteblock blockquote, .quoteblock p {
    color: rgba(0, 0, 0, .85);
    font-size: 1.15rem;
    line-height: 1.75;
    word-spacing: .1em;
    letter-spacing: 0;
    font-style: italic;
    text-align: justify
}

.quoteblock blockquote {
    margin: 0;
    padding: 0;
    border: 0
}

.quoteblock blockquote::before {
    content: "\201c";
    float: left;
    font-size: 2.75em;
    font-weight: bold;
    line-height: .6em;
    margin-left: -.6em;
    color: #7a2518;
    text-shadow: 0 1px 2px rgba(0, 0, 0, .1)
}

.quoteblock blockquote > .paragraph:last-child p {
    margin-bottom: 0
}

.quoteblock .attribution {
    margin-top: .75em;
    margin-right: .5ex;
    text-align: right
}

.verseblock {
    margin: 0 1em 1.25em
}

.verseblock pre {
    font-family: "Open Sans", "DejaVu Sans", sans;
    font-size: 1.15rem;
    color: rgba(0, 0, 0, .85);
    font-weight: 300;
    text-rendering: optimizeLegibility
}

.verseblock pre strong {
    font-weight: 400
}

.verseblock .attribution {
    margin-top: 1.25rem;
    margin-left: .5ex
}

.quoteblock .attribution, .verseblock .attribution {
    font-size: .9375em;
    line-height: 1.45;
    font-style: italic
}

.quoteblock .attribution br, .verseblock .attribution br {
    display: none
}

.quoteblock .attribution cite, .verseblock .attribution cite {
    display: block;
    letter-spacing: -.025em;
    color: rgba(0, 0, 0, .6)
}

.quoteblock.abstract blockquote::before, .quoteblock.excerpt blockquote::before, .quoteblock .quoteblock blockquote::before {
    display: none
}

.quoteblock.abstract blockquote, .quoteblock.abstract p, .quoteblock.excerpt blockquote, .quoteblock.excerpt p, .quoteblock .quoteblock blockquote, .quoteblock .quoteblock p {
    line-height: 1.6;
    word-spacing: 0
}

.quoteblock.abstract {
    margin: 0 1em 1.25em;
    display: block
}

.quoteblock.abstract > .title {
    margin: 0 0 .375em;
    font-size: 1.15em;
    text-align: center
}

.quoteblock.excerpt > blockquote, .quoteblock .quoteblock {
    padding: 0 0 .25em 1em;
    border-left: .25em solid #dddddf
}

.quoteblock.excerpt, .quoteblock .quoteblock {
    margin-left: 0
}

.quoteblock.excerpt blockquote, .quoteblock.excerpt p, .quoteblock .quoteblock blockquote, .quoteblock .quoteblock p {
    color: inherit;
    font-size: 1.0625rem
}

.quoteblock.excerpt .attribution, .quoteblock .quoteblock .attribution {
    color: inherit;
    font-size: .85rem;
    text-align: left;
    margin-right: 0
}

p.tableblock:last-child {
    margin-bottom: 0
}

td.tableblock > .content {
    margin-bottom: 1.25em;
    word-wrap: anywhere
}

td.tableblock > .content > :last-child {
    margin-bottom: -1.25em
}

table.tableblock, th.tableblock, td.tableblock {
    border: 0 solid #dedede
}

table.grid-all > * > tr > * {
    border-width: 1px
}

table.grid-cols > * > tr > * {
    border-width: 0 1px
}

table.grid-rows > * > tr > * {
    border-width: 1px 0
}

table.frame-all {
    border-width: 1px
}

table.frame-ends {
    border-width: 1px 0
}

table.frame-sides {
    border-width: 0 1px
}

table.frame-none > colgroup + * > :first-child > *, table.frame-sides > colgroup + * > :first-child > * {
    border-top-width: 0
}

table.frame-none > :last-child > :last-child > *, table.frame-sides > :last-child > :last-child > * {
    border-bottom-width: 0
}

table.frame-none > * > tr > :first-child, table.frame-ends > * > tr > :first-child {
    border-left-width: 0
}

table.frame-none > * > tr > :last-child, table.frame-ends > * > tr > :last-child {
    border-right-width: 0
}

table.stripes-all tr, table.stripes-odd tr:nth-of-type(odd), table.stripes-even tr:nth-of-type(even), table.stripes-hover tr:hover {
    background: #f8f8f7
}

th.halign-left, td.halign-left {
    text-align: left
}

th.halign-right, td.halign-right {
    text-align: right
}

th.halign-center, td.halign-center {
    text-align: center
}

th.valign-top, td.valign-top {
    vertical-align: top
}

th.valign-bottom, td.valign-bottom {
    vertical-align: bottom
}

th.valign-middle, td.valign-middle {
    vertical-align: middle
}

table thead th, table tfoot th {
    font-weight: bold
}

tbody tr th {
    background: #f7f8f7
}

tbody tr th, tbody tr th p, tfoot tr th, tfoot tr th p {
    color: rgba(0, 0, 0, .8);
    font-weight: bold
}

p.tableblock > code:only-child {
    background: none;
    padding: 0
}

p.tableblock {
    font-size: 1em
}

ol {
    margin-left: 1.75em
}

ul li ol {
    margin-left: 1.5em
}

dl dd {
    margin-left: 1.125em
}

dl dd:last-child, dl dd:last-child > :last-child {
    margin-bottom: 0
}

ol > li p, ul > li p, ul dd, ol dd, .olist .olist, .ulist .ulist, .ulist .olist, .olist .ulist {
    margin-bottom: .625em
}

ul.checklist, ul.none, ol.none, ul.no-bullet, ol.no-bullet, ol.unnumbered, ul.unstyled, ol.unstyled {
    list-style-type: none
}

ul.no-bullet, ol.no-bullet, ol.unnumbered {
    margin-left: .625em
}

ul.unstyled, ol.unstyled {
    margin-left: 0
}

ul.checklist {
    margin-left: .625em
}

ul.checklist li > p:first-child > .fa-square-o:first-child, ul.checklist li > p:first-child > .fa-check-square-o:first-child {
    width: 1.25em;
    font-size: .8em;
    position: relative;
    bottom: .125em
}

ul.checklist li > p:first-child > input[type="checkbox"]:first-child {
    margin-right: .25em
}

ul.inline {
    display: -ms-flexbox;
    display: -webkit-box;
    display: flex;
    -ms-flex-flow: row wrap;
    -webkit-flex-flow: row wrap;
    flex-flow: row wrap;
    list-style: none;
    margin: 0 0 .625em -1.25em
}

ul.inline > li {
    margin-left: 1.25em
}

.unstyled dl dt {
    font-weight: 400;
    font-style: normal
}

ol.arabic {
    list-style-type: decimal
}

ol.decimal {
    list-style-type: decimal-leading-zero
}

ol.loweralpha {
    list-style-type: lower-alpha
}

ol.upperalpha {
    list-style-type: upper-alpha
}

ol.lowerroman {
    list-style-type: lower-roman
}

ol.upperroman {
    list-style-type: upper-roman
}

ol.lowergreek {
    list-style-type: lower-greek
}

.hdlist > table, .colist > table {
    border: 0;
    background: none
}

.hdlist > table > tbody > tr, .colist > table > tbody > tr {
    background: none
}

td.hdlist1, td.hdlist2 {
    vertical-align: top;
    padding: 0 .625em
}

td.hdlist1 {
    font-weight: bold;
    padding-bottom: 1.25em
}

td.hdlist2 {
    word-wrap: anywhere
}

.literalblock + .colist, .listingblock + .colist {
    margin-top: -.5em
}

.colist td:not([class]):first-child {
    padding: .4em .75em 0;
    line-height: 1;
    vertical-align: top
}

.colist td:not([class]):first-child img {
    max-width: none
}

.colist td:not([class]):last-child {
    padding: .25em 0
}

.thumb, .th {
    line-height: 0;
    display: inline-block;
    border: solid 4px #fff;
    -webkit-box-shadow: 0 0 0 1px #ddd;
    box-shadow: 0 0 0 1px #ddd
}

.imageblock.left {
    margin: .25em .625em 1.25em 0
}

.imageblock.right {
    margin: .25em 0 1.25em .625em
}

.imageblock > .title {
    margin-bottom: 0
}

.imageblock.thumb, .imageblock.th {
    border-width: 6px
}

.imageblock.thumb > .title, .imageblock.th > .title {
    padding: 0 .125em
}

.image.left, .image.right {
    margin-top: .25em;
    margin-bottom: .25em;
    display: inline-block;
    line-height: 0
}

.image.left {
    margin-right: .625em
}

.image.right {
    margin-left: .625em
}

a.image {
    text-decoration: none;
    display: inline-block
}

a.image object {
    pointer-events: none
}

sup.footnote, sup.footnoteref {
    font-size: .875em;
    position: static;
    vertical-align: super
}

sup.footnote a, sup.footnoteref a {
    text-decoration: none
}

sup.footnote a:active, sup.footnoteref a:active {
    text-decoration: underline
}

#footnotes {
    padding-top: .75em;
    padding-bottom: .75em;
    margin-bottom: .625em
}

#footnotes hr {
    width: 20%;
    min-width: 6.25em;
    margin: -.25em 0 .75em;
    border-width: 1px 0 0
}

#footnotes .footnote {
    padding: 0 .375em 0 .225em;
    line-height: 1.3334;
    font-size: .875em;
    margin-left: 1.2em;
    margin-bottom: .2em
}

#footnotes .footnote a:first-of-type {
    font-weight: bold;
    text-decoration: none;
    margin-left: -1.05em
}

#footnotes .footnote:last-of-type {
    margin-bottom: 0
}

#content #footnotes {
    margin-top: -.625em;
    margin-bottom: 0;
    padding: .75em 0
}

.gist .file-data > table {
    border: 0;
    background: #fff;
    width: 100%;
    margin-bottom: 0
}

.gist .file-data > table td.line-data {
    width: 99%
}

div.unbreakable {
    page-break-inside: avoid
}

.big {
    font-size: larger
}

.small {
    font-size: smaller
}

.underline {
    text-decoration: underline
}

.overline {
    text-decoration: overline
}

.line-through {
    text-decoration: line-through
}

.aqua {
    color: #00bfbf
}

.aqua-background {
    background: #00fafa
}

.black {
    color: #000
}

.black-background {
    background: #000
}

.blue {
    color: #0000bf
}

.blue-background {
    background: #0000fa
}

.fuchsia {
    color: #bf00bf
}

.fuchsia-background {
    background: #fa00fa
}

.gray {
    color: #606060
}

.gray-background {
    background: #7d7d7d
}

.green {
    color: #006000
}

.green-background {
    background: #007d00
}

.lime {
    color: #00bf00
}

.lime-background {
    background: #00fa00
}

.maroon {
    color: #600000
}

.maroon-background {
    background: #7d0000
}

.navy {
    color: #000060
}

.navy-background {
    background: #00007d
}

.olive {
    color: #606000
}

.olive-background {
    background: #7d7d00
}

.purple {
    color: #600060
}

.purple-background {
    background: #7d007d
}

.red {
    color: #bf0000
}

.red-background {
    background: #fa0000
}

.silver {
    color: #909090
}

.silver-background {
    background: #bcbcbc
}

.teal {
    color: #006060
}

.teal-background {
    background: #007d7d
}

.white {
    color: #bfbfbf
}

.white-background {
    background: #fafafa
}

.yellow {
    color: #bfbf00
}

.yellow-background {
    background: #fafa00
}

span.icon > .fa {
    cursor: default
}

a span.icon > .fa {
    cursor: inherit
}

.admonitionblock td.icon [class^="fa icon-"] {
    font-size: 2.5em;
    text-shadow: 1px 1px 2px rgba(0, 0, 0, .5);
    cursor: default
}

.admonitionblock td.icon .icon-note::before {
    content: "\f05a";
    color: #19407c
}

.admonitionblock td.icon .icon-tip::before {
    content: "\f0eb";
    text-shadow: 1px 1px 2px rgba(155, 155, 0, .8);
    color: #111
}

.admonitionblock td.icon .icon-warning::before {
    content: "\f071";
    color: #bf6900
}

.admonitionblock td.icon .icon-caution::before {
    content: "\f06d";
    color: #bf3400
}

.admonitionblock td.icon .icon-important::before {
    content: "\f06a";
    color: #bf0000
}

.conum[data-value] {
    display: inline-block;
    color: #fff !important;
    background: rgba(0, 0, 0, .8);
    -webkit-border-radius: 50%;
    border-radius: 50%;
    text-align: center;
    font-size: .75em;
    width: 1.67em;
    height: 1.67em;
    line-height: 1.67em;
    font-family: "Open Sans", "DejaVu Sans", sans-serif;
    font-style: normal;
    font-weight: bold
}

.conum[data-value] * {
    color: #fff !important
}

.conum[data-value] + b {
    display: none
}

.conum[data-value]::after {
    content: attr(data-value)
}

pre .conum[data-value] {
    position: relative;
    top: -.125em
}

b.conum * {
    color: inherit !important
}

.conum:not([data-value]):empty {
    display: none
}

dt, th.tableblock, td.content, div.footnote {
    text-rendering: optimizeLegibility
}

h1, h2, p, td.content, span.alt {
    letter-spacing: -.01em
}

p strong, td.content strong, div.footnote strong {
    letter-spacing: -.005em
}

p, blockquote, dt, td.content, span.alt {
    font-size: 1.0625rem
}

p {
    margin-bottom: 1.25rem
}

.sidebarblock p, .sidebarblock dt, .sidebarblock td.content, p.tableblock {
    font-size: 1em
}

.exampleblock > .content {
    background: #fffef7;
    border-color: #e0e0dc;
    -webkit-box-shadow: 0 1px 4px #e0e0dc;
    box-shadow: 0 1px 4px #e0e0dc
}

.print-only {
    display: none !important
}

@page {
    margin: 1.25cm .75cm
}

@media print {
    * {
        -webkit-box-shadow: none !important;
        box-shadow: none !important;
        text-shadow: none !important
    }

    html {
        font-size: 80%
    }

    a {
        color: inherit !important;
        text-decoration: underline !important
    }

    a.bare, a[href^="#"], a[href^="mailto:"] {
        text-decoration: none !important
    }

    a[href^="http:"]:not(.bare)::after, a[href^="https:"]:not(.bare)::after {
        content: "(" attr(href) ")";
        display: inline-block;
        font-size: .875em;
        padding-left: .25em
    }

    abbr[title]::after {
        content: " (" attr(title) ")"
    }

    pre, blockquote, tr, img, object, svg {
        page-break-inside: avoid
    }

    thead {
        display: table-header-group
    }

    svg {
        max-width: 100%
    }

    p, blockquote, dt, td.content {
        font-size: 1em;
        orphans: 3;
        widows: 3
    }

    h2, h3, #toctitle, .sidebarblock > .content > .title {
        page-break-after: avoid
    }

    #header, #content, #footnotes, #footer {
        max-width: none
    }

    #toc, .sidebarblock, .exampleblock > .content {
        background: none !important
    }

    #toc {
        border-bottom: 1px solid #dddddf !important;
        padding-bottom: 0 !important
    }

    body.book #header {
        text-align: center
    }

    body.book #header > h1:first-child {
        border: 0 !important;
        margin: 2.5em 0 1em
    }

    body.book #header .details {
        border: 0 !important;
        display: block;
        padding: 0 !important
    }

    body.book #header .details span:first-child {
        margin-left: 0 !important
    }

    body.book #header .details br {
        display: block
    }

    body.book #header .details br + span::before {
        content: none !important
    }

    body.book #toc {
        border: 0 !important;
        text-align: left !important;
        padding: 0 !important;
        margin: 0 !important
    }

    body.book #toc, body.book #preamble, body.book h1.sect0, body.book .sect1 > h2 {
        page-break-before: always
    }

    .listingblock code[data-lang]::before {
        display: block
    }

    #footer {
        padding: 0 .9375em
    }

    .hide-on-print {
        display: none !important
    }

    .print-only {
        display: block !important
    }

    .hide-for-print {
        display: none !important
    }

    .show-for-print {
        display: inherit !important
    }
}

@media print, amzn-kf8 {
    #header > h1:first-child {
        margin-top: 1.25rem
    }

    .sect1 {
        padding: 0 !important
    }

    .sect1 + .sect1 {
        border: 0
    }

    #footer {
        background: none
    }

    #footer-text {
        color: rgba(0, 0, 0, .6);
        font-size: .9em
    }
}

@media amzn-kf8 {
    #header, #content, #footnotes, #footer {
        padding: 0
    }
}
</style>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.18.3/styles/github.min.css">
<script src="tocbot.min.js"></script>
<link rel="stylesheet" href="tocbot.css">
</head>
<body class="book toc2 toc-left">
<div id="header">
<h1>Sqlg Documentation</h1>
<div class="details">
<span id="author" class="author">Pieter Martin</span><br>
<span id="revnumber">version 3.1.2,</span>
<span id="revdate">June 2024</span>
<br><span id="revremark"></span>
</div>
<div id="toc" class="toc2">
<div id="toctitle">Table of Contents</div>
<ul class="sectlevel1">
<li><a href="#_introduction">1. Introduction</a></li>
<li><a href="#_license">2. License</a></li>
<li><a href="#_tinkerpop_supported_features">3. TinkerPop supported features</a></li>
<li><a href="#_limitations">4. Limitations</a></li>
<li><a href="#_getting_started">5. Getting Started</a>
<ul class="sectlevel2">
<li><a href="#_maven_coordinates">5.1. Maven coordinates</a></li>
<li><a href="#_start">5.2. Start</a></li>
</ul>
</li>
<li><a href="#_data_types">6. Data types</a></li>
<li><a href="#_architecture">7. Architecture</a>
<ul class="sectlevel2">
<li><a href="#_vertex_tables">7.1. Vertex tables</a></li>
<li><a href="#_edge_tables">7.2. Edge tables</a></li>
<li><a href="#_tinkerpop_modern">7.3. TinkerPop-modern</a></li>
<li><a href="#_namespacing_and_schemas">7.4. Namespacing and Schemas</a>
<ul class="sectlevel3">
<li><a href="#_edge_label">7.4.1. Edge label</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#_indexes">8. Indexes</a>
<ul class="sectlevel2">
<li><a href="#_basic_indexing">8.1. Basic indexing</a>
<ul class="sectlevel3">
<li><a href="#_composite_indexes">8.1.1. Composite indexes</a></li>
</ul>
</li>
<li><a href="#anchor-full-text-indexing">8.2. Full-text indexing</a></li>
</ul>
</li>
<li><a href="#_multiple_jvms">9. Multiple JVMs</a></li>
<li><a href="#_gremlin">10. Gremlin</a>
<ul class="sectlevel2">
<li><a href="#_optimization_strategy_1">10.1. Optimization (strategy 1)</a>
<ul class="sectlevel3">
<li><a href="#_graph_step">10.1.1. Graph Step</a></li>
<li><a href="#_vertex_step">10.1.2. Vertex Step</a></li>
<li><a href="#_has_step">10.1.3. Has Step</a></li>
<li><a href="#_or_step">10.1.4. Or Step</a></li>
<li><a href="#_and_step">10.1.5. And Step</a></li>
<li><a href="#_not_step">10.1.6. Not Step</a></li>
<li><a href="#_repeat_step">10.1.7. Repeat Step</a>
<ul class="sectlevel4">
<li><a href="#_repeat_step_with_timesx">Repeat Step with <code>times(x)</code></a></li>
<li><a href="#_recursive_repeat_step">Recursive Repeat Step</a></li>
</ul>
</li>
<li><a href="#_optional_step">10.1.8. Optional Step</a></li>
<li><a href="#_choose_step">10.1.9. Choose Step</a></li>
<li><a href="#_order_step">10.1.10. Order Step</a></li>
<li><a href="#_range_step">10.1.11. Range Step</a></li>
<li><a href="#_limit_step">10.1.12. Limit Step</a></li>
<li><a href="#_drop_step">10.1.13. Drop Step</a></li>
<li><a href="#_reducing_steps">10.1.14. Reducing Steps</a>
<ul class="sectlevel4">
<li><a href="#_min_step">Min Step</a></li>
<li><a href="#_max_step">Max Step</a></li>
<li><a href="#_sum_step">Sum Step</a></li>
<li><a href="#_mean_step">Mean Step</a></li>
<li><a href="#_count_step">Count Step</a></li>
<li><a href="#_group_by">Group By</a></li>
<li><a href="#_group_by_and_min_step">Group By and Min Step</a></li>
<li><a href="#_group_by_and_max_step">Group By and Max Step</a></li>
<li><a href="#_group_by_and_sum_step">Group By and Sum Step</a></li>
<li><a href="#_group_by_and_mean_step">Group By and Mean Step</a></li>
<li><a href="#_group_by_and_count_step">Group By and Count Step</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#_optimization_strategy_2">10.2. Optimization (strategy 2)</a>
<ul class="sectlevel3">
<li><a href="#_vertex_step_2">10.2.1. Vertex Step</a></li>
<li><a href="#_repeat_step_2">10.2.2. Repeat Step</a></li>
<li><a href="#_optional_step_2">10.2.3. Optional Step</a></li>
<li><a href="#_choose_step_2">10.2.4. Choose Step</a></li>
<li><a href="#_local_step">10.2.5. Local Step</a></li>
<li><a href="#_and_step_2">10.2.6. And Step</a></li>
<li><a href="#_or_step_2">10.2.7. Or Step</a></li>
<li><a href="#_not_step_2">10.2.8. Not Step</a></li>
<li><a href="#_where_step">10.2.9. Where Step</a></li>
</ul>
</li>
<li><a href="#_predicates">10.3. Predicates</a>
<ul class="sectlevel3">
<li><a href="#_compare_predicate">10.3.1. Compare predicate</a></li>
<li><a href="#_contains_predicate">10.3.2. Contains predicate</a></li>
<li><a href="#_text_predicate">10.3.3. Text predicate</a></li>
<li><a href="#_full_text_search">10.3.4. Full text search</a></li>
<li><a href="#_datetime_queries">10.3.5. DateTime queries</a></li>
<li><a href="#_ltree_queries">10.3.6. Ltree queries</a></li>
<li><a href="#_lquery_predicate">10.3.7. Lquery predicate</a></li>
<li><a href="#_lqueryarray_predicate">10.3.8. LqueryArray predicate</a></li>
</ul>
</li>
<li><a href="#_custom_functions">10.4. Custom functions</a></li>
</ul>
</li>
<li><a href="#_batch_mode">11. Batch Mode</a>
<ul class="sectlevel2">
<li><a href="#_normal_batch_mode">11.1. Normal batch mode</a></li>
<li><a href="#_streaming_batch_mode">11.2. Streaming batch mode</a></li>
<li><a href="#_bulk_edge_creation">11.3. Bulk edge creation</a></li>
<li><a href="#_streaming_with_lock_batch_mode">11.4. Streaming with lock batch mode</a></li>
</ul>
</li>
<li><a href="#anchor-topology">12. Topology</a>
<ul class="sectlevel2">
<li><a href="#_topology_eager_creation">12.1. Topology eager creation</a></li>
<li><a href="#_propertydefinition">12.2. PropertyDefinition</a>
<ul class="sectlevel3">
<li><a href="#_propertytype">12.2.1. PropertyType</a></li>
<li><a href="#_multiplicity">12.2.2. Multiplicity</a></li>
<li><a href="#_default_values">12.2.3. Default values</a></li>
<li><a href="#_check_constraints">12.2.4. Check constraints</a></li>
<li><a href="#_update_propertydefinition">12.2.5. Update PropertyDefinition</a></li>
</ul>
</li>
<li><a href="#_edgedefinition">12.3. EdgeDefinition</a>
<ul class="sectlevel3">
<li><a href="#_one_to_one">12.3.1. One-to-one</a></li>
<li><a href="#_one_to_many">12.3.2. One-to-many</a></li>
<li><a href="#_many_to_many_unique">12.3.3. Many-to-many (unique)</a></li>
<li><a href="#_one_to_many_many_to_many_multiplicity">12.3.4. one-to-many, many-to-many, multiplicity</a>
<ul class="sectlevel4">
<li><a href="#_1_checkmultiplicity_per_vertex">1 checkMultiplicity (per vertex)</a></li>
<li><a href="#_2_checkmultiplicity_per_vertexlabel">2 checkMultiplicity (per VertexLabel)</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#_query_the_topology">12.4. Query the topology</a></li>
<li><a href="#anchor-user-supplied-identifiers">12.5. User supplied identifiers</a></li>
<li><a href="#_lock_the_topology">12.6. Lock the topology</a></li>
</ul>
</li>
<li><a href="#_postgresql_partitioning">13. Postgresql Partitioning</a>
<ul class="sectlevel2">
<li><a href="#_range_partitioning">13.1. Range partitioning</a></li>
<li><a href="#_list_partitioning">13.2. List partitioning</a></li>
<li><a href="#_hash_partitioning">13.3. Hash partitioning</a></li>
<li><a href="#_sub_partitioning">13.4. Sub partitioning</a></li>
</ul>
</li>
<li><a href="#_postgresql_foreign_data_wrappers">14. Postgresql Foreign Data Wrappers</a>
<ul class="sectlevel2">
<li><a href="#_how_it_works">14.1. How it works</a></li>
<li><a href="#_prepare">14.2. Prepare</a></li>
<li><a href="#_import_a_foreign_schema">14.3. Import a foreign schema</a></li>
</ul>
</li>
<li><a href="#_postgresql_pgrouting">15. Postgresql pgRouting</a>
<ul class="sectlevel2">
<li><a href="#_dijkstra">15.1. Dijkstra</a></li>
</ul>
</li>
<li><a href="#_postgresql_pgvector">16. Postgresql PGVector</a>
<ul class="sectlevel2">
<li><a href="#_data_types_2">16.1. Data types</a>
<ul class="sectlevel3">
<li><a href="#pgvector">16.1.1. vector</a></li>
<li><a href="#pgbit">16.1.2. bit</a></li>
<li><a href="#pghalfvec">16.1.3. halfvec</a></li>
<li><a href="#pgsparcvec">16.1.4. sparcvec</a></li>
</ul>
</li>
<li><a href="#_query">16.2. Query</a>
<ul class="sectlevel3">
<li><a href="#OrderBy">16.2.1. Queries using order by</a></li>
<li><a href="#Predicate">16.2.2. Queries using filter predicates</a></li>
<li><a href="#Distance">16.2.3. Queries using custom <code>distance</code> step</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#_gremlin_server">17. Gremlin server</a>
<ul class="sectlevel2">
<li><a href="#_minimal_config">17.1. Minimal config</a></li>
</ul>
</li>
<li><a href="#_test_suite">18. Test Suite</a>
<ul class="sectlevel2">
<li><a href="#_postgresql">18.1. Postgresql</a></li>
<li><a href="#_hsqldb">18.2. Hsqldb</a></li>
<li><a href="#_h2">18.3. H2</a></li>
</ul>
</li>
</ul>
</div>
</div>
<div id="content">
<div id="preamble">
<div class="sectionbody">
<div class="paragraph">
<p><a href="https://github.com/pietermartin/sqlg"><strong>Sqlg</strong></a> <span class="image"><img src="./img/github/SVG/mark-github.svg" alt="mark github"></span> is a implementation of <a href="http://tinkerpop.apache.org/">Apache TinkerPop</a> on a
<a href="http://en.wikipedia.org/wiki/Relational_database_management_system">RDBMS</a>.
Currently <a href="http://www.postgresql.org/">Postgresql</a>, <a href="http://hsqldb.org/">HSQLDB</a>, <a href="http://h2database.com">H2</a>, <a href="https://mariadb.org">MariaDB</a>, <a href="https://www.mysql.com">MySQL</a> are supported.</p>
</div>
<div class="paragraph">
<p>Sqlg has a github <a href="https://github.com/pietermartin/sqlg/discussions">discussions</a> page.</p>
</div>
<div class="paragraph">
<p>Javadoc <a href="sqlg-core/apidocs/index.html" target="\"_blank\"">sqlg-core</a>,
<a href="postgresql/apidocs/index.html" target="\"_blank\"">postgres-dialect</a>,
<a href="hsqldb/apidocs/index.html" target="\"_blank\"">hsqldb-dialect</a>,
<a href="h2/apidocs/index.html" target="\"_blank\"">h2-dialect</a></p>
</div>
<div class="paragraph">
<p>Sqlg has an extensive <a href="#_test_suite">test suite</a></p>
</div>
<div class="paragraph">
<p>Code coverage <a href="postgresql/codeCoverage/index.html" target="\"_blank\"">code coverage</a>,</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_introduction">1. Introduction</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Sqlg primary challenge is to reduce latency by combining TinkerPop
<a href="http://tinkerpop.apache.org/docs/current/reference/#graph-traversal-steps">steps</a> into as few database calls as possible.
Without a significant reduction in latency the fine-grained nature of graph traversals has a prohibitively high performance impact.</p>
</div>
<div class="paragraph">
<p>Sqlg supports various bulk modes to reduce latency when modifying the graph.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
Hsqldb and H2 do not suffer the same latency as Postgresql and MariaDB as it runs embedded in the jvm.
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_license">2. License</h2>
<div class="sectionbody">
<div class="paragraph">
<p><span class="image"><img src="./img/github/SVG/law.svg" alt="MIT"></span> <a href="https://github.com/pietermartin/sqlg/blob/master/LICENSE">MIT</a></p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_tinkerpop_supported_features">3. TinkerPop supported features</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Sqlg version 3.1.2 runs on <a href="https://tinkerpop.apache.org">TinkerPop 3.7.3</a>.</p>
</div>
<div class="paragraph">
<p>Sqlg passes TinkerPop&#8217;s <code>StructureStandardSuite</code>, <code>ProcessStandardSuite</code> test suites then and <code>Gherkin feature</code> tests.</p>
</div>
<div class="ulist">
<div class="title">Graph Features <strong>not</strong> implemented.</div>
<ul>
<li>
<p>Computer</p>
</li>
<li>
<p>ThreadedTransactions</p>
</li>
<li>
<p>Variables</p>
</li>
</ul>
</div>
<div class="ulist">
<div class="title">Vertex Features <strong>not</strong> implemented.</div>
<ul>
<li>
<p>MultiProperties</p>
</li>
<li>
<p>MetaProperties</p>
</li>
<li>
<p>UserSuppliedIds</p>
</li>
<li>
<p>NumericIds</p>
</li>
<li>
<p>StringIds</p>
</li>
<li>
<p>UuidIds</p>
</li>
<li>
<p>CustomIds</p>
</li>
<li>
<p>AnyIds</p>
</li>
</ul>
</div>
<div class="ulist">
<div class="title">Edge Features <strong>not</strong> implemented.</div>
<ul>
<li>
<p>UserSuppliedIds</p>
</li>
<li>
<p>NumericIds</p>
</li>
<li>
<p>StringIds</p>
</li>
<li>
<p>UuidIds</p>
</li>
<li>
<p>CustomIds</p>
</li>
<li>
<p>AnyIds</p>
</li>
</ul>
</div>
<div class="ulist">
<div class="title">Vertex property features <strong>not</strong> implemented.</div>
<ul>
<li>
<p>AddProperty</p>
</li>
<li>
<p>RemoveProperty</p>
</li>
<li>
<p>UserSuppliedIds</p>
</li>
<li>
<p>NumericIds</p>
</li>
<li>
<p>StringIds</p>
</li>
<li>
<p>UuidIds</p>
</li>
<li>
<p>CustomIds</p>
</li>
<li>
<p>AnyIds</p>
</li>
<li>
<p>MapValues</p>
</li>
<li>
<p>MixedListValues</p>
</li>
<li>
<p>SerializableValues</p>
</li>
<li>
<p>UniformListValues</p>
</li>
</ul>
</div>
<div class="ulist">
<div class="title">Edge property feature <strong>not</strong> implemented.</div>
<ul>
<li>
<p>MapValues</p>
</li>
<li>
<p>MixedListValues</p>
</li>
<li>
<p>SerializableValues</p>
</li>
<li>
<p>UniformListValues</p>
</li>
</ul>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
Sqlg supports <code>NullPropertyValues</code>
</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
Sqlg supports user supplied ids but not quite as defined by TinkerPop. This is explained <a href="#anchor-user-supplied-identifiers">below</a>.
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_limitations">4. Limitations</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Postgresql schema, table and column names can not be more than 63 characters long.</p>
</div>
<div class="paragraph">
<p>Sqlg does not allow referencing non-existing properties in <code>`order().by('nonExisting')</code>. Unlike <code>TinkerGraph</code> <code>Sqlg</code> will throw an exception.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_getting_started">5. Getting Started</h2>
<div class="sectionbody">
<div class="paragraph">
<p>There are a few ways to initialize Sqlg. The easiest is to include one of the provided connection pools and choose a supported database.</p>
</div>
<div class="paragraph">
<p>e.g.</p>
</div>
<div class="literalblock">
<div class="title">C3P0</div>
<div class="content">
<pre>&lt;dependency&gt;
    &lt;groupId&gt;org.umlg&lt;/groupId&gt;
    &lt;artifactId&gt;sqlg-c3p0&lt;/artifactId&gt;
    &lt;version&gt;3.1.2&lt;/version&gt;
&lt;/dependency&gt;</pre>
</div>
</div>
<div class="literalblock">
<div class="title">Postgresql</div>
<div class="content">
<pre>&lt;dependency&gt;
    &lt;groupId&gt;org.umlg&lt;/groupId&gt;
    &lt;artifactId&gt;sqlg-postgres&lt;/artifactId&gt;
    &lt;version&gt;3.1.2&lt;/version&gt;
&lt;/dependency&gt;</pre>
</div>
</div>
<div class="paragraph">
<p>You can also provide your own custom datasource by implementing <code>org.umlg.sqlg.structure.SqlgDataSource</code>. To let <code>Sqlg</code> know about your custom datasource you need to specify the fully qualified class name in <code>sqlg.properties</code></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-none hljs">sqlg.dataSource=your.custom.SqlgDataSource</code></pre>
</div>
</div>
<div class="paragraph">
<p>Sqlg can also do a <code>JNDI</code> lookup to find the datasource. For this to work the <code>jdbc.url</code> property must begin with <code>jndi:</code></p>
</div>
<div class="sect2">
<h3 id="_maven_coordinates">5.1. Maven coordinates</h3>
<div class="paragraph">
<p>Sqlg has support for <a href="https://www.mchange.com/projects/c3p0/">c3p0</a> and <a href="https://github.com/brettwooldridge/HikariCP">hikari</a> connection pools.</p>
</div>
<div class="literalblock">
<div class="title">C3P0</div>
<div class="content">
<pre>&lt;dependency&gt;
    &lt;groupId&gt;org.umlg&lt;/groupId&gt;
    &lt;artifactId&gt;sqlg-c3p0&lt;/artifactId&gt;
    &lt;version&gt;3.1.2&lt;/version&gt;
&lt;/dependency&gt;</pre>
</div>
</div>
<div class="literalblock">
<div class="title">Hikari</div>
<div class="content">
<pre>&lt;dependency&gt;
    &lt;groupId&gt;org.umlg&lt;/groupId&gt;
    &lt;artifactId&gt;sqlg-hikari&lt;/artifactId&gt;
    &lt;version&gt;{version}&lt;/version&gt;
&lt;/dependency&gt;</pre>
</div>
</div>
<div class="paragraph">
<p>The various <code>Sqlg</code> supported databases.</p>
</div>
<div class="literalblock">
<div class="title">Postgresql</div>
<div class="content">
<pre>&lt;dependency&gt;
    &lt;groupId&gt;org.umlg&lt;/groupId&gt;
    &lt;artifactId&gt;sqlg-postgres&lt;/artifactId&gt;
    &lt;version&gt;3.1.2&lt;/version&gt;
&lt;/dependency&gt;</pre>
</div>
</div>
<div class="literalblock">
<div class="title">HSQLDB</div>
<div class="content">
<pre>&lt;dependency&gt;
    &lt;groupId&gt;org.umlg&lt;/groupId&gt;
    &lt;artifactId&gt;sqlg-hsqldb&lt;/artifactId&gt;
    &lt;version&gt;3.1.2&lt;/version&gt;
&lt;/dependency&gt;</pre>
</div>
</div>
<div class="literalblock">
<div class="title">H2</div>
<div class="content">
<pre>&lt;dependency&gt;
    &lt;groupId&gt;org.umlg&lt;/groupId&gt;
    &lt;artifactId&gt;sqlg-h2&lt;/artifactId&gt;
    &lt;version&gt;3.1.2&lt;/version&gt;
&lt;/dependency&gt;</pre>
</div>
</div>
<div class="literalblock">
<div class="title">MariaDB</div>
<div class="content">
<pre>&lt;dependency&gt;
    &lt;groupId&gt;org.umlg&lt;/groupId&gt;
    &lt;artifactId&gt;sqlg-mariadb&lt;/artifactId&gt;
    &lt;version&gt;3.1.2&lt;/version&gt;
&lt;/dependency&gt;</pre>
</div>
</div>
<div class="literalblock">
<div class="title">MySQL</div>
<div class="content">
<pre>&lt;dependency&gt;
    &lt;groupId&gt;org.umlg&lt;/groupId&gt;
    &lt;artifactId&gt;sqlg-mysql&lt;/artifactId&gt;
    &lt;version&gt;3.1.2&lt;/version&gt;
&lt;/dependency&gt;</pre>
</div>
</div>
<div class="paragraph">
<p>The above mentioned maven coordinates will include <code>gremlin-groovy</code>. To exclude <code>gremlin-groovy</code> only include the dialect.</p>
</div>
<div class="literalblock">
<div class="title">Postgresql</div>
<div class="content">
<pre>&lt;dependency&gt;
    &lt;groupId&gt;org.umlg&lt;/groupId&gt;
    &lt;artifactId&gt;sqlg-postgres-dialect&lt;/artifactId&gt;
    &lt;version&gt;3.1.2&lt;/version&gt;
&lt;/dependency&gt;</pre>
</div>
</div>
<div class="literalblock">
<div class="title">HSQLDB</div>
<div class="content">
<pre>&lt;dependency&gt;
    &lt;groupId&gt;org.umlg&lt;/groupId&gt;
    &lt;artifactId&gt;sqlg-hsqldb-dialect&lt;/artifactId&gt;
    &lt;version&gt;3.1.2&lt;/version&gt;
&lt;/dependency&gt;</pre>
</div>
</div>
<div class="literalblock">
<div class="title">H2</div>
<div class="content">
<pre>&lt;dependency&gt;
    &lt;groupId&gt;org.umlg&lt;/groupId&gt;
    &lt;artifactId&gt;sqlg-h2-dialect&lt;/artifactId&gt;
    &lt;version&gt;3.1.2&lt;/version&gt;
&lt;/dependency&gt;</pre>
</div>
</div>
<div class="literalblock">
<div class="title">MariaDB</div>
<div class="content">
<pre>&lt;dependency&gt;
    &lt;groupId&gt;org.umlg&lt;/groupId&gt;
    &lt;artifactId&gt;sqlg-mariadb-dialect&lt;/artifactId&gt;
    &lt;version&gt;3.1.2&lt;/version&gt;
&lt;/dependency&gt;</pre>
</div>
</div>
<div class="literalblock">
<div class="title">MySQL</div>
<div class="content">
<pre>&lt;dependency&gt;
    &lt;groupId&gt;org.umlg&lt;/groupId&gt;
    &lt;artifactId&gt;sqlg-mysql-dialect&lt;/artifactId&gt;
    &lt;version&gt;3.1.2&lt;/version&gt;
&lt;/dependency&gt;</pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_start">5.2. Start</h3>
<div class="paragraph">
<p><code>SqlgGraph</code> is a singleton that can be shared among multiple threads. You instantiate <code>SqlgGraph</code> using the standard
TinkerPop static constructors.</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>Graph g = SqlgGraph.open(final Configuration configuration)</code></p>
</li>
<li>
<p><code>Graph g = SqlgGraph.open(final String pathToSqlgProperties)</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The configuration object requires the following properties.</p>
</div>
<div class="literalblock">
<div class="title">Postgresql</div>
<div class="content">
<pre>jdbc.url=jdbc:postgresql://localhost:5432/yourdb
jdbc.username=postgres
jdbc.password=******</pre>
</div>
</div>
<div class="literalblock">
<div class="title">HSQLDB</div>
<div class="content">
<pre>jdbc.url=jdbc:hsqldb:file:/tmp/yourdb
jdbc.username=SA
jdbc.password=</pre>
</div>
</div>
<div class="literalblock">
<div class="title">H2</div>
<div class="content">
<pre>jdbc.url=jdbc:h2:file:target/tmp/yourdb
jdbc.username=SA
jdbc.password=</pre>
</div>
</div>
<div class="literalblock">
<div class="title">MariaDB</div>
<div class="content">
<pre>jdbc.url=jdbc:mariadb://localhost:3306/?useSSL=false
jdbc.username=mariadb
jdbc.password=</pre>
</div>
</div>
<div class="literalblock">
<div class="title">MySQL</div>
<div class="content">
<pre>jdbc.url=jdbc:mysql://localhost:3306/?allowPublicKeyRetrieval=true&amp;useSSL=false
jdbc.username=mysql
jdbc.password=</pre>
</div>
</div>
<div class="paragraph">
<p>In the case of <code>Postgresql</code> the database must already exist.</p>
</div>
<div class="paragraph">
<p>Once you have access to the graph you can use it as per normal.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-java hljs" data-lang="java">@Test
public void useAsPerNormal() {
    Vertex person = this.sqlgGraph.addVertex(T.label, "Person", "name", "John");
    Vertex address = this.sqlgGraph.addVertex(T.label, "Address", "street", "13th");
    person.addEdge("livesAt", address, "since", LocalDate.of(2010, 1, 21));
    this.sqlgGraph.tx().commit(); # <b class="conum">(1)</b>
    List&lt;Vertex&gt; addresses = this.sqlgGraph.traversal().V().hasLabel("Person").out("livesAt").toList();
    assertEquals(1, addresses.size());
}</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>It is very important to always commit or rollback the transaction.
If you do not, connections to the database will remain open and eventually
the connection pool will run out of connections.</p>
</li>
</ol>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_data_types">6. Data types</h2>
<div class="sectionbody">
<table class="tableblock frame-all grid-all stretch">
<caption class="title">Table 1. Table Data types</caption>
<colgroup>
<col style="width: 20%;">
<col style="width: 20%;">
<col style="width: 20%;">
<col style="width: 20%;">
<col style="width: 20%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Java</th>
<th class="tableblock halign-left valign-top">Postgresql</th>
<th class="tableblock halign-left valign-top">HSQLDB</th>
<th class="tableblock halign-left valign-top">H2</th>
<th class="tableblock halign-left valign-top">MariaDB</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Boolean</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">BOOLEAN</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">BOOLEAN</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">BOOLEAN</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">BOOLEAN</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Byte</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>Not supported</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">TINYINT</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">TINYINT</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">TINYINT</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Short</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">SMALLINT</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">SMALLINT</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">SMALLINT</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">SMALLINT</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Integer</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">INTEGER</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">INTEGER</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">INT</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">INTEGER</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Long</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">BIGINT</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">BIGINT</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">BIGINT</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">BIGINT</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Float</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">REAL</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>Not supported</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">REAL</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>Not supported</strong></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Double</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">DOUBLE PRECISION</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">DOUBLE</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">DOUBLE</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">DOUBLE</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">BigDecimal</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">DOUBLE PRECISION</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">DOUBLE</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">DOUBLE</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">DOUBLE</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">String</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">TEXT</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">LONGVARCHAR</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">VARCHAR</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">LONGTEXT</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">String (fixed length)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">VARCHAR(x)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">VARCHAR(x)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">VARCHAR(x)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">VARCHAR(x)</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">UUID</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">UUID</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">UUID</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">UUID</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>Not supported</strong></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Boolean[]</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">BOOLEAN[]</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">BOOLEAN ARRAY DEFAULT ARRAY[]</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">ARRAY</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">BOOLEAN ARRAY DEFAULT ARRAY[]</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Byte[]</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">BYTEA</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">LONGVARBINARY</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">BINARY</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">BLOB</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Short[]</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">SMALLINT[]</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">SMALLINT ARRAY DEFAULT ARRAY[]</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">ARRAY</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>Not supported</strong></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Integer[]</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">INTEGER[]</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">INTEGER ARRAY DEFAULT ARRAY[]</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">ARRAY</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>Not supported</strong></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Long[]</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">BIGINT[]</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">BIGINT ARRAY DEFAULT ARRAY[]</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">ARRAY</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>Not supported</strong></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Float[]</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">REAL[]</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>Not supported</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">ARRAY</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>Not supported</strong></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Double[]</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">DOUBLE PRECISION[]</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">DOUBLE ARRAY DEFAULT ARRAY[]</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">ARRAY</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>Not supported</strong></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">String[]</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">TEXT[]</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">LONGVARCHAR ARRAY DEFAULT ARRAY[]</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">ARRAY</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>Not supported</strong></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">java.time.LocalDateTime</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">TIMESTAMP</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">TIMESTAMP</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">TIMESTAMP</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">DATETIME(3)</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">java.time.LocalDate</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">DATE</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">DATE</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">DATE</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">DATE</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">java.time.LocalTime</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">TIME</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">TIME</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">TIME</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">TIME</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">java.time.ZonedDateTime</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">TIMESTAMP, TEXT</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">TIMESTAMP, LONGVARCHAR</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">TIMESTAMP, VARCHAR</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">DATETIME(3), TINYTEXT</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">java.time.Period</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">INTEGER, INTEGER, INTEGER</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">INTEGER, INTEGER, INTEGER</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">INT, INT, INT</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">INTEGER, INTEGER, INTEGER</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">java.time.Duration</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">BIGINT, INTEGER</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">BIGINT, INTEGER</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">BIGINT, INT</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">BIGINT, INTEGER</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">java.time.LocalDateTime[]</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">TIMESTAMP[]</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">TIMESTAMP ARRAY DEFAULT ARRAY[]</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">ARRAY</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>Not supported</strong></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">java.time.LocalDate[]</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">DATE[]</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">DATE ARRAY DEFAULT ARRAY[]</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">ARRAY</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>Not supported</strong></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">java.time.LocalTime[]</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">TIME[]</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">TIME ARRAY DEFAULT ARRAY[]</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">ARRAY</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>Not supported</strong></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">java.time.ZonedDateTime[]</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">TIMESTAMP[], TEXT[]</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">TIMESTAMP ARRAY DEFAULT ARRAY[], LONGVARCHAR ARRAY DEFAULT ARRAY[]</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">ARRAY</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>Not supported</strong></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">java.time.Period[]</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">INTEGER[], INTEGER[], INTEGER[]</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">INTEGER ARRAY DEFAULT ARRAY[], INTEGER ARRAY DEFAULT ARRAY[], INTEGER ARRAY DEFAULT ARRAY[]</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">ARRAY</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>Not supported</strong></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">java.time.Duration[]</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">BIGINT[], INTEGER[]</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">BIGINT ARRAY DEFAULT ARRAY[], INTEGER ARRAY DEFAULT ARRAY[]</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">ARRAY</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>Not supported</strong></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">com.fasterxml.jackson.databind.JsonNode</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">JSONB</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">LONGVARCHAR</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">VARCHAR</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">LONGTEXT</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">com.fasterxml.jackson.databind.JsonNode[]</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">JSONB[]</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">ARRAY</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">ARRAY</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>Not supported</strong></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">org.postgis.Point</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">geometry(POINT)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>Not supported</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>Not supported</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>Not supported</strong></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">org.umlg.sqlg.gis.GeographyPoint</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">geography(POINT, 4326)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>Not supported</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>Not supported</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>Not supported</strong></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">org.postgis.LineString</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">geometry(LINESTRING)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>Not supported</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>Not supported</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>Not supported</strong></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">org.postgis.Polygon</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">geometry(POLYGON)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>Not supported</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>Not supported</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>Not supported</strong></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">org.umlg.sqlg.gis.GeographyPolygon</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">geography(POLYGON, 4326)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>Not supported</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>Not supported</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>Not supported</strong></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">String</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Ltree</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>Not supported</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>Not supported</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>Not supported</strong></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">pgvector</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">vector</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>Not supported</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>Not supported</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>Not supported</strong></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">pgbit</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">bit</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>Not supported</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>Not supported</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>Not supported</strong></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">pghalfvec</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">halfvec</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>Not supported</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>Not supported</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>Not supported</strong></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">pgsparcvec</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">sparcvec</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>Not supported</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>Not supported</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>Not supported</strong></p></td>
</tr>
</tbody>
</table>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
<code>java.time.LocalTime</code> drops the nanosecond precision.
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_architecture">7. Architecture</h2>
<div class="sectionbody">
<div class="paragraph">
<p>TinkerPop&#8217;s property graph semantics specifies that every vertex and edge has a single label. Modelling this in a RDBMS
is trivial. TinkerPop edges has no notion of cardinality nor of order. Every relationship between vertex labels is modelled as
<code>many to many</code> relationship with no specified order.</p>
</div>
<div class="paragraph">
<p>This realizes itself as a classic <code>many to many</code> relationship in a RDBMS database.</p>
</div>
<div class="listingblock">
<div class="content">
<pre>VertexLabel &lt;---- EdgeLabel ----&gt; VertexLabel</pre>
</div>
</div>
<div class="sect2">
<h3 id="_vertex_tables">7.1. Vertex tables</h3>
<div class="paragraph">
<p>Every unique vertex label maps to a table. Vertex tables are prefixed with a <code>V_</code>. i.e. <code>V_Person</code>. The vertex table
stores the vertex&#8217;s properties.</p>
</div>
</div>
<div class="sect2">
<h3 id="_edge_tables">7.2. Edge tables</h3>
<div class="paragraph">
<p>Every unique edge label maps to a table. Edge tables are prefixed with a <code>E_</code>. i.e. <code>E_friend</code>. The edge table stores
each edge&#8217;s adjacent vertex ids and the edge&#8217;s properties. The column corresponding to each adjacent vertex id (<code>IN</code> and <code>OUT</code>)
has a foreign key to the adjacent vertex&#8217;s table. The foreign key is optional, instead just an index on the adjacent vertex id
can be used.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
By default, Sqlg will use an auto increment <code>ID</code> <code>bigint</code> for the primary key. You can however use the <a href="#anchor-topology">topology</a> interface to define which properties to use as the primary key.
</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
<code>sqlg.properties</code> <code>implement.foreign.keys = false</code><br>
Edge foreign keys have a significant impact on performance.<br>
Edge foreign keys are enabled by default.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>From a rdbms' perspective each edge table is the classic <code>many to many</code> join table between vertices.</p>
</div>
</div>
<div class="sect2">
<h3 id="_tinkerpop_modern">7.3. TinkerPop-modern</h3>
<div class="paragraph">
<p>Taken from <a href="http://tinkerpop.apache.org/docs/current/reference/#intro">TinkerPop</a></p>
</div>
<div class="paragraph">
<p><span class="image"><img src="./img/sqlg/tinkerpop-modern-graph.png" alt="image of tinkerpop-classic"></span></p>
</div>
<div class="paragraph">
<div class="title">ER Diagram</div>
<p><span class="image"><img src="./img/sqlg/tinkerpop-modern-er.png" alt="image of tinkerpop-classic"></span></p>
</div>
<div class="paragraph">
<div class="title">V_person</div>
<p><span class="image"><img src="./img/sqlg/V_person.png" alt="image of tinkerpop-classic"></span></p>
</div>
<div class="paragraph">
<div class="title">V_software</div>
<p><span class="image"><img src="./img/sqlg/V_software.png" alt="image of tinkerpop-classic"></span></p>
</div>
<div class="paragraph">
<div class="title">E_knows</div>
<p><span class="image"><img src="./img/sqlg/E_knows.png" alt="image of tinkerpop-classic"></span></p>
</div>
<div class="paragraph">
<div class="title">E_created</div>
<p><span class="image"><img src="./img/sqlg/E_created.png" alt="image of tinkerpop-classic"></span></p>
</div>
</div>
<div class="sect2">
<h3 id="_namespacing_and_schemas">7.4. Namespacing and Schemas</h3>
<div class="paragraph">
<p>Many RDBMS databases have the notion of a <code>schema</code> as a namespace for tables. Sqlg supports schemas
for vertex labels. Distinct schemas for edge tables are unnecessary as edge tables are created in the schema of the adjacent <code>out</code> vertex.
By default, schemas for vertex tables go into the underlying databases' default schema. For Postgresql, hsqldb and H2 this
is the <code>public</code> schema.</p>
</div>
<div class="paragraph">
<p>To specify the schema for a label Sqlg uses the dot <code>.</code> notation.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-java hljs" data-lang="java">@Test
public void testElementsInSchema() {
    Vertex john = this.sqlgGraph.addVertex(T.label, "Manager", "name", "john"); # <b class="conum">(1)</b>
    Vertex palace1 = this.sqlgGraph.addVertex(T.label, "continent.House", "name", "palace1"); # <b class="conum">(2)</b>
    Vertex corrola = this.sqlgGraph.addVertex(T.label, "fleet.Car", "model", "corrola"); # <b class="conum">(3)</b>
    palace1.addEdge("managedBy", john);
    corrola.addEdge("owner", john);
    this.sqlgGraph.tx().commit();
    assertEquals(1, this.sqlgGraph.traversal().V().hasLabel("Manager").count().next().intValue()); # <b class="conum">(4)</b>
    assertEquals(0, this.sqlgGraph.traversal().V().hasLabel("House").count().next().intValue()); # <b class="conum">(5)</b>
    assertEquals(1, this.sqlgGraph.traversal().V().hasLabel("continent.House").count().next().intValue()); <b class="conum">(6)</b>
    assertEquals(0, this.sqlgGraph.traversal().V().hasLabel("Car").count().next().intValue());
    assertEquals(1, this.sqlgGraph.traversal().V().hasLabel("fleet.Car").count().next().intValue());
    assertEquals(1, this.sqlgGraph.traversal().E().hasLabel("managedBy").count().next().intValue());
    assertEquals(1, this.sqlgGraph.traversal().E().hasLabel("owner").count().next().intValue());
}</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>'Manager' will be in the default 'public' schema.</p>
</li>
<li>
<p>'House' will be in the 'continent' schema.</p>
</li>
<li>
<p>'Car' will be in the 'fleet' schema.</p>
</li>
<li>
<p>Vertices in the public schema do not need to be qualified with the schema.</p>
</li>
<li>
<p>Vertices not in the public schema must be qualified with its schema. In this case 'House' will not be found.</p>
</li>
<li>
<p>As 'House' is qualified with the 'continent' schema it will be found.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Table <code>V_manager</code> is in the <code>public</code> (default) schema.<br>
Table <code>V_house</code> is in the <code>continent</code> schema.<br>
Table <code>V_car</code> is in the <code>fleet</code> schema.<br>
Table <code>E_managedBy</code> is in the <code>continent</code> schema as its <code>out</code> vertex <code>palace1</code> is in the <code>continent</code> schema.<br>
Table <code>E_owner</code> is in the <code>fleet</code> schema as its <code>out</code> vertex is in the `fleet`schema.</p>
</div>
<div class="paragraph">
<div class="title">postgresql schemas</div>
<p><span class="image"><img src="./img/sqlg/schemas.png" alt="image of tinkerpop-classic"></span>
<span class="image"><img src="./img/sqlg/continent.png" alt="image of tinkerpop-classic"></span>
<span class="image"><img src="./img/sqlg/fleet.png" alt="image of tinkerpop-classic"></span>
<span class="image"><img src="./img/sqlg/public.png" alt="image of tinkerpop-classic"></span></p>
</div>
<div class="sect3">
<h4 id="_edge_label">7.4.1. Edge label</h4>
<div class="paragraph">
<p>An edge label can have many different out vertex labels.
This means that its possible for a single edge label to be stored in multiple schemas and tables.
One for each distinct out vertex label. Gremlin queries will work as per normal.
However, it is possible to target the edges per out vertex schema directly.</p>
</div>
<div class="listingblock">
<div class="title">eg.</div>
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-java hljs" data-lang="java">@Test
public void testEdgeAcrossSchema() {
    Vertex a = this.sqlgGraph.addVertex(T.label, "A.A");
    Vertex b = this.sqlgGraph.addVertex(T.label, "B.B");
    Vertex c = this.sqlgGraph.addVertex(T.label, "C.C");
    a.addEdge("specialEdge", b);
    b.addEdge("specialEdge", c);
    this.sqlgGraph.tx().commit();
    assertEquals(2, this.sqlgGraph.traversal().E().hasLabel("specialEdge").count().next().intValue()); # <b class="conum">(1)</b>
    assertEquals(1, this.sqlgGraph.traversal().E().hasLabel("A.specialEdge").count().next().intValue()); # <b class="conum">(2)</b>
    assertEquals(1, this.sqlgGraph.traversal().E().hasLabel("B.specialEdge").count().next().intValue()); # <b class="conum">(3)</b>
}</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Query 'specialEdge'</p>
</li>
<li>
<p>Query 'specialEdge' with, out vertex labels in the 'A' schema.</p>
</li>
<li>
<p>Query 'specialEdge' with, out vertex labels in the 'B' schema.</p>
</li>
</ol>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_indexes">8. Indexes</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_basic_indexing">8.1. Basic indexing</h3>
<div class="paragraph">
<p>Sqlg supports adding a unique or non-unique index to any property or properties.</p>
</div>
<div class="paragraph">
<div class="title">UML diagram of Sqlg&#8217;s topology.</div>
<p><span class="image"><img src="./img/uml/Package_topology_indexClassDiagram.PNG" alt="image of Sqlg&#8217;s topology"></span></p>
</div>
<div class="paragraph">
<p>To add an index one has to use Sqlg&#8217;s topology interface.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-java hljs" data-lang="java">@Test
public void testIndex() {
    VertexLabel personVertexLabel = this.sqlgGraph.getTopology().getPublicSchema().ensureVertexLabelExist("Person",
        new HashMap&lt;&gt;() {{
            put("name", PropertyDefinition.of(PropertyType.STRING));
        }}
    ); # <b class="conum">(1)</b>
    Optional&lt;PropertyColumn&gt; namePropertyOptional = personVertexLabel.getProperty("name");
    assertTrue(namePropertyOptional.isPresent());
    Index index = personVertexLabel.ensureIndexExists(IndexType.NON_UNIQUE, Collections.singletonList(namePropertyOptional.get())); $ <b class="conum">(2)</b>
    this.sqlgGraph.tx().commit(); # <b class="conum">(3)</b>

    this.sqlgGraph.addVertex(T.label, "Person", "name", "John");
    List&lt;Vertex&gt; johns = this.sqlgGraph.traversal().V()
            .hasLabel("Person")
            .has("name", "John")
            .toList(); # <b class="conum">(4)</b>

    /* This will execute the following sql.
    SELECT
        "public"."V_Person"."ID" AS "alias1",
        "public"."V_Person"."name" AS "alias2"
    FROM
        "public"."V_Person"
    WHERE
        ( "public"."V_Person"."name" = ?)
    */ # <b class="conum">(5)</b>

    assertEquals(1, johns.size());
}</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Create the 'Person' VertexLabel.</p>
</li>
<li>
<p>On the 'Person' VertexLabel create a non unique index on the 'name' property.</p>
</li>
<li>
<p>Index creation is transactional on Postgresql.</p>
</li>
<li>
<p>The given gremlin query will use the index.</p>
</li>
<li>
<p>The underlying RDBMS will use the index for the executed sql.</p>
</li>
</ol>
</div>
<div class="paragraph">
<div class="title">postgresql V_Person sql definition</div>
<p><span class="image"><img src="./img/sqlg/V_Person_name_index.png" alt="image of tinkerpop-classic"></span></p>
</div>
<div class="sect3">
<h4 id="_composite_indexes">8.1.1. Composite indexes</h4>
<div class="paragraph">
<p>It is possible to create composite indexes.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-java hljs" data-lang="java">@Test
public void testCompositeIndex() {
    VertexLabel personVertexLabel = this.sqlgGraph.getTopology().getPublicSchema().ensureVertexLabelExist("Person", new HashMap&lt;&gt;() {{
        put("firstName", PropertyDefinition.of(PropertyType.STRING));
        put("lastName", PropertyDefinition.of(PropertyType.STRING));
    }}); # <b class="conum">(1)</b>
    personVertexLabel.ensureIndexExists(IndexType.NON_UNIQUE, new ArrayList&lt;&gt;(personVertexLabel.getProperties().values())); # <b class="conum">(2)</b>
    this.sqlgGraph.tx().commit();
    this.sqlgGraph.addVertex(T.label, "Person", "firstName", "John", "lastName", "Smith");
    List&lt;Vertex&gt; johnSmiths = this.sqlgGraph.traversal().V()
            .hasLabel("Person")
            .has("firstName", "John")
            .has("lastName", "Smith")
            .toList();
    assertEquals(1, johnSmiths.size());
}</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Create the 'Person' VertexLabel with 2 properties, 'firstName' and 'lastName'.</p>
</li>
<li>
<p>Create a composite index on 'firstName' and 'lastName'</p>
</li>
</ol>
</div>
<div class="paragraph">
<div class="title">postgresql V_Person composite index sql definition</div>
<p><span class="image"><img src="./sqlg/postgresql_composite_index.png" alt="image of tinkerpop-classic"></span></p>
</div>
<div class="paragraph">
<p>Outside of creating the index Sqlg has no further direct interaction with the index. However gremlin queries with a
<code>HasStep</code> targeting a property with an index on it will translate to a sql <code>where</code> clause on that property and
the underlying RDBMS will utilize the index.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
The index does not need to be created upfront. It can be added any time.
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect2">
<h3 id="anchor-full-text-indexing">8.2. Full-text indexing</h3>
<div class="paragraph">
<p>On postgresql full text indexing is supported.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-java hljs" data-lang="java">@Test
public void testFullTextIndex() {
    Vertex v0 = this.sqlgGraph.addVertex(T.label, "Sentence", "name", "a fat cat sat on a mat and ate a fat rat");
    Vertex v1 = this.sqlgGraph.addVertex(T.label, "Sentence", "name", "fatal error");
    Vertex v2 = this.sqlgGraph.addVertex(T.label, "Sentence", "name", "error is not fatal");

    VertexLabel vl = this.sqlgGraph.getTopology().getVertexLabel("public", "Sentence").get();
    vl.ensureIndexExists(IndexType.getFullTextGIN("english"), Collections.singletonList(vl.getProperty("name").get())); <b class="conum">(1)</b>
    this.sqlgGraph.tx().commit();

    List&lt;Vertex&gt; vts = this.sqlgGraph.traversal()
            .V().hasLabel("Sentence")
            .has("name", FullText.fullTextMatch("english", "fat &amp; rat")) <b class="conum">(2)</b>
            .toList();
    Assert.assertEquals(1, vts.size());
    Assert.assertTrue(vts.contains(v0));
}</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Create a full-text gin index.</p>
</li>
<li>
<p>Query the full-text index using Sqlg&#8217;s custom FullText predicate.</p>
</li>
</ol>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_multiple_jvms">9. Multiple JVMs</h2>
<div class="sectionbody">
<div class="paragraph">
<p>It is possible to run many Sqlg instances pointing to the same underlying database. These instances can be in the same jvm
but is primarily intended for separate jvm(s) pointing to the same underlying database.</p>
</div>
<div class="paragraph">
<p>To make multiple graphs point to the same underlying database it is important to add in the <code>distributed</code> property to <code>sqlg.properties</code>.</p>
</div>
<div class="listingblock">
<div class="title">sqlg.properties</div>
<div class="content">
<pre>distributed = true</pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
Multiple JVMs is only supported for Postgresql.
Hsqldb and H2 are primarily intended to run embedded so multiple JVMs do not make sense for them.
Multiple JVM support has not been implemented for MariaDB and MSSqlServer.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Postgresql&#8217;s <a href="https://www.postgresql.org/docs/current/static/sql-notify.html"><strong>notify</strong></a> mechanism is used to distribute the cached schema
across multiple JVMs.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_gremlin">10. Gremlin</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Sqlg optimizes a gremlin <a href="http://tinkerpop.apache.org/docs/current/reference/#traversal"><code>traversal</code></a>  by analyzing the
<a href="http://tinkerpop.apache.org/docs/current/reference/#graph-traversal-steps"><code>steps</code></a> and where possible combining them into custom Sqlg steps. This can
significantly reduce the number of database calls.</p>
</div>
<div class="paragraph">
<p>Sqlg has two strategies for optimizing TinkerPop steps.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Starting with the <a href="http://tinkerpop.apache.org/docs/current/reference/#graph-step"><code>GraphStep</code></a>,
consecutive optimizable steps are folded into <a href="apidocs/org/umlg/sqlg/step/SqlgGraphStep.html"><code>SqlgGraphStep</code></a>. This
stops at the first unoptimizable step after which the second strategy is used.</p>
</li>
<li>
<p>The second strategy is to <code>barrier</code> the incoming elements to the unoptimizable step. This means to exhaust the traversal/iterator
up to the step and cache all the incoming elements for this step. From here the step is executed for all the incoming
elements at once. This strategy effectively changes the semantics to a breath first retrieval.</p>
</li>
</ul>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
Turn sql logging on by setting <code>log4j.logger.org.umlg.sqlg=debug</code>
</td>
</tr>
</table>
</div>
<div class="sect2">
<h3 id="_optimization_strategy_1">10.1. Optimization (strategy 1)</h3>
<div class="paragraph">
<p>The following steps are optimized.</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#_graph_step">Graph Step</a></p>
</li>
<li>
<p><a href="#_vertex_step">Vertex Step</a></p>
</li>
<li>
<p><a href="#_has_step">Has Step</a></p>
</li>
<li>
<p><a href="#_or_step">Or Step</a></p>
</li>
<li>
<p><a href="#_and_step">And Step</a></p>
</li>
<li>
<p><a href="#_not_step">Not Step</a></p>
</li>
<li>
<p><a href="#_repeat_step">Repeat Step</a></p>
</li>
<li>
<p><a href="#_optional_step">Optional Step</a></p>
</li>
<li>
<p><a href="#_choose_step">Choose Step</a></p>
</li>
<li>
<p><a href="#_order_step">Order Step</a></p>
</li>
<li>
<p><a href="#_range_step">Range Step</a></p>
</li>
<li>
<p><a href="#_limit_step">Limit Step</a></p>
</li>
<li>
<p><a href="#_drop_step">Drop Step</a></p>
</li>
<li>
<p><a href="#_reducing_steps">Reducing Steps</a></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The combined step will then in turn generate the sql statements to retrieve the data.
It attempts to retrieve the data in as few distinct sql statements as possible.</p>
</div>
<div class="sect3">
<h4 id="_graph_step">10.1.1. Graph Step</h4>
<div class="paragraph">
<p>The <a href="http://tinkerpop.apache.org/docs/current/reference/#graph-step">Graph Step</a> is the start of any traversal.
Sqlg optimizes the graph step by analysing subsequent steps and if possible folding them into a few steps as possible.
Often into only one step, <code>SqlgGraphStepCompiled</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-java hljs" data-lang="java">@Test
public void showGraphStep() {
    Vertex a1 = this.sqlgGraph.addVertex(T.label, "A", "name", "a1");
    Vertex b1 = this.sqlgGraph.addVertex(T.label, "B", "name", "b1");
    Vertex b2 = this.sqlgGraph.addVertex(T.label, "B", "name", "b2");
    Vertex c1 = this.sqlgGraph.addVertex(T.label, "C", "name", "c1");
    Vertex c2 = this.sqlgGraph.addVertex(T.label, "C", "name", "c2");
    a1.addEdge("ab", b1);
    a1.addEdge("ab", b2);
    b1.addEdge("bc", c1);
    b2.addEdge("bc", c2);
    this.sqlgGraph.tx().commit();

    GraphTraversal&lt;Vertex, Vertex&gt; traversal = this.sqlgGraph.traversal().V()
            .hasLabel("A")
            .out()
            .out();
    System.out.println(traversal);
    traversal.hasNext();
    System.out.println(traversal);
    List&lt;Vertex&gt; c = traversal.toList();
    assertEquals(2, c.size());
}</code></pre>
</div>
</div>
<div id="anchor-before-optimization" class="listingblock">
<div class="title">Before optimization</div>
<div class="content">
<pre class="nowrap">[GraphStep(vertex,[]), HasStep([~label.eq(A)]), VertexStep(OUT,vertex), VertexStep(OUT,vertex)]</pre>
</div>
</div>
<div id="anchor-after-optimization" class="listingblock">
<div class="title">After optimization</div>
<div class="content">
<pre>[SqlgGraphStep(vertex,[])@[sqlgPathFakeLabel]]</pre>
</div>
</div>
<div class="paragraph">
<p>The <a href="#anchor-before-optimization">Before optimization</a> output shows the steps that will execute if no optimization is performed.
Without optimization the query <code>this.sqlgGraph.traversal().V().hasLabel("A").out().out()</code> will
first get the <code>A</code> s, then for each <code>A</code> the <code>B</code> s and then for each <code>B</code> the <code>C</code> s. In the above example unoptimized it
would be at least five round trips to the db. Optimized it is only one trip to the db.</p>
</div>
<div class="paragraph">
<p>For an embedded db like HSQLDB this is still ok but for a database server like postgresql the performance impact is
significant.</p>
</div>
<div class="paragraph">
<p><a href="#anchor-after-optimization">After optimization</a> there is only one <a href="apidocs//org/umlg/sqlg/step/SqlgGraphStep.html"><code>SqlgGraphStep</code></a> step.
All the steps have been folded into one step.</p>
</div>
<div class="paragraph">
<p>The <a href="apidocs//org/umlg/sqlg/step/SqlgGraphStep.html"><code>SqlgGraphStep</code></a> will generate the following <code>sql</code> to retrieve the data.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-sql hljs" data-lang="sql">SELECT
	"public"."V_C"."ID" AS "alias1",
	"public"."V_C"."name" AS "alias2"
FROM
	"public"."V_A" INNER JOIN
	"public"."E_ab" ON "public"."V_A"."ID" = "public"."E_ab"."public.A__O" INNER JOIN
	"public"."V_B" ON "public"."E_ab"."public.B__I" = "public"."V_B"."ID" INNER JOIN
	"public"."E_bc" ON "public"."V_B"."ID" = "public"."E_bc"."public.B__O" INNER JOIN
	"public"."V_C" ON "public"."E_bc"."public.C__I" = "public"."V_C"."ID"</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_vertex_step">10.1.2. Vertex Step</h4>
<div class="paragraph">
<p>Consecutive <a href="http://tinkerpop.apache.org/docs/current/reference/#vertex-steps"><code>Vertex Step</code></a> are folded into the <a href="#_graph_step">Graph Step</a>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-java hljs" data-lang="java">@Test
public void showVertexStep() {
    Vertex a1 = this.sqlgGraph.addVertex(T.label, "A", "name", "a1");
    Vertex b1 = this.sqlgGraph.addVertex(T.label, "B", "name", "b1");
    Vertex b2 = this.sqlgGraph.addVertex(T.label, "B", "name", "b2");
    Vertex c1 = this.sqlgGraph.addVertex(T.label, "C", "name", "c1");
    Vertex c2 = this.sqlgGraph.addVertex(T.label, "C", "name", "c2");
    a1.addEdge("ab", b1);
    a1.addEdge("ab", b2);
    b1.addEdge("bc", c1);
    b2.addEdge("bc", c2);
    this.sqlgGraph.tx().commit();

    GraphTraversal&lt;Vertex, Vertex&gt; traversal = this.sqlgGraph.traversal().V()
            .hasLabel("A")
            .out()
            .out();
    System.out.println(traversal);
    traversal.hasNext();
    System.out.println(traversal);
    List&lt;Vertex&gt; c = traversal.toList();
    assertEquals(2, c.size());
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Before optimization</div>
<div class="content">
<pre class="nowrap">[GraphStep(vertex,[]), HasStep([~label.eq(A)]), VertexStep(OUT,vertex), VertexStep(OUT,vertex)]</pre>
</div>
</div>
<div class="listingblock">
<div class="title">After optimization</div>
<div class="content">
<pre>[SqlgGraphStep(vertex,[])@[sqlgPathFakeLabel]]</pre>
</div>
</div>
<div class="paragraph">
<p>This example is the same as the <a href="#_graph_step">Graph Step</a>. It shows the two <code>Vertex Steps</code> being folded into the <code>SqlgGraphStep</code>.</p>
</div>
<div class="paragraph">
<p>The <a href="apidocs//org/umlg/sqlg/step/SqlgGraphStep.html"><code>SqlgGraphStep</code></a> will generate the following <code>sql</code> to retrieve the data.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-sql hljs" data-lang="sql">SELECT
	"public"."V_C"."ID" AS "alias1",
	"public"."V_C"."name" AS "alias2"
FROM
	"public"."V_A" INNER JOIN
	"public"."E_ab" ON "public"."V_A"."ID" = "public"."E_ab"."public.A__O" INNER JOIN
	"public"."V_B" ON "public"."E_ab"."public.B__I" = "public"."V_B"."ID" INNER JOIN
	"public"."E_bc" ON "public"."V_B"."ID" = "public"."E_bc"."public.B__O" INNER JOIN
	"public"."V_C" ON "public"."E_bc"."public.C__I" = "public"."V_C"."ID"</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_has_step">10.1.3. Has Step</h4>
<div class="paragraph">
<p><a href="http://tinkerpop.apache.org/docs/current/reference/#has-step"><code>Has Step</code></a>s are folded into the <a href="#_graph_step">Graph Step</a> or <a href="#_vertex_step">Vertex Step</a>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-java hljs" data-lang="java">@Test
public void showHasStep() {
    Vertex a1 = this.sqlgGraph.addVertex(T.label, "A", "name", "a1");
    Vertex b1 = this.sqlgGraph.addVertex(T.label, "B", "name", "b1");
    Vertex b2 = this.sqlgGraph.addVertex(T.label, "B", "name", "b2");
    Vertex c1 = this.sqlgGraph.addVertex(T.label, "C", "name", "c1");
    Vertex c2 = this.sqlgGraph.addVertex(T.label, "C", "name", "c2");
    a1.addEdge("ab", b1);
    a1.addEdge("ab", b2);
    b1.addEdge("bc", c1);
    b2.addEdge("bc", c2);
    this.sqlgGraph.tx().commit();

    GraphTraversal&lt;Vertex, Vertex&gt; traversal = this.sqlgGraph.traversal().V()
            .hasLabel("A")
            .out().has("name", "b1")
            .out();
    System.out.println(traversal);
    traversal.hasNext();
    System.out.println(traversal);
    List&lt;Vertex&gt; c = traversal.toList();
    assertEquals(1, c.size());
}</code></pre>
</div>
</div>
<div id="anchor-before-optimization-has-step" class="listingblock">
<div class="title">Before optimization</div>
<div class="content">
<pre class="nowrap">[GraphStep(vertex,[]), HasStep([~label.eq(A)]), VertexStep(OUT,vertex), HasStep([name.eq(b1)]), VertexStep(OUT,vertex)]</pre>
</div>
</div>
<div id="anchor-after-optimization-has-step" class="listingblock">
<div class="title">After optimization</div>
<div class="content">
<pre>[SqlgGraphStep(vertex,[])@[sqlgPathFakeLabel]]</pre>
</div>
</div>
<div class="paragraph">
<p>This example is similar to the <a href="#_graph_step">Graph Step</a> example except for an additional <code>HasStep</code>.
It shows the two <code>Vertex Step</code> s and the <code>Has Step</code> being folded into the <code>SqlgGraphStep</code>.</p>
</div>
<div class="paragraph">
<p>The <a href="apidocs//org/umlg/sqlg/step/SqlgGraphStep.html"><code>SqlgGraphStep</code></a> will generate the following <code>sql</code> to retrieve the data.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-sql hljs" data-lang="sql">SELECT
	"public"."V_C"."ID" AS "alias1",
	"public"."V_C"."name" AS "alias2"
FROM
	"public"."V_A" INNER JOIN
	"public"."E_ab" ON "public"."V_A"."ID" = "public"."E_ab"."public.A__O" INNER JOIN
	"public"."V_B" ON "public"."E_ab"."public.B__I" = "public"."V_B"."ID" INNER JOIN
	"public"."E_bc" ON "public"."V_B"."ID" = "public"."E_bc"."public.B__O" INNER JOIN
	"public"."V_C" ON "public"."E_bc"."public.C__I" = "public"."V_C"."ID"
WHERE
	( "public"."V_B"."name" = ?) <b class="conum">(1)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>The <code>Has Step</code> realizes itself as a sql <code>where</code> clause.</p>
</li>
</ol>
</div>
</div>
<div class="sect3">
<h4 id="_or_step">10.1.4. Or Step</h4>
<div class="paragraph">
<p><a href="http://tinkerpop.apache.org/docs/current/reference/#or-step"><code>Or Step</code></a>s are folded into the <a href="#_graph_step">Graph Step</a> or <a href="#_vertex_step">Vertex Step</a>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-java hljs" data-lang="java">@Test
public void showOrStep() {
    Vertex a1 = this.sqlgGraph.addVertex(T.label, "A", "name", "a1");
    Vertex b1 = this.sqlgGraph.addVertex(T.label, "B", "name", "b1");
    Vertex b2 = this.sqlgGraph.addVertex(T.label, "B", "name", "b2");
    Vertex c1 = this.sqlgGraph.addVertex(T.label, "C", "name", "c1");
    Vertex c2 = this.sqlgGraph.addVertex(T.label, "C", "name", "c2");
    Vertex c3 = this.sqlgGraph.addVertex(T.label, "C", "name", "c3");
    Vertex c4 = this.sqlgGraph.addVertex(T.label, "C", "name", "c4");
    Vertex c5 = this.sqlgGraph.addVertex(T.label, "C", "name", "c5");
    Vertex c6 = this.sqlgGraph.addVertex(T.label, "C", "name", "c6");
    a1.addEdge("ab", b1);
    a1.addEdge("ab", b2);
    b1.addEdge("bc", c1);
    b2.addEdge("bc", c2);
    b2.addEdge("bc", c3);
    b2.addEdge("bc", c4);
    b2.addEdge("bc", c5);
    b2.addEdge("bc", c6);
    this.sqlgGraph.tx().commit();

    GraphTraversal&lt;Vertex, Vertex&gt; traversal = this.sqlgGraph.traversal().V()
            .hasLabel("A")
            .out()
            .out()
            .or(
                    __.has("name", "c1"),
                    __.has("name", "c3"),
                    __.has("name", "c6")
            );

    System.out.println(traversal);
    traversal.hasNext();
    System.out.println(traversal);
    List&lt;Vertex&gt; c = traversal.toList();
    assertEquals(3, c.size());
}</code></pre>
</div>
</div>
<div id="anchor-before-optimization-or-step" class="listingblock">
<div class="title">Before optimization</div>
<div class="content">
<pre class="nowrap">[GraphStep(vertex,[]), HasStep([~label.eq(A)]), VertexStep(OUT,vertex), VertexStep(OUT,vertex), OrStep([[HasStep([name.eq(c1)])], [HasStep([name.eq(c3)])], [HasStep([name.eq(c6)])]])]</pre>
</div>
</div>
<div id="anchor-after-optimization-or-step" class="listingblock">
<div class="title">After optimization</div>
<div class="content">
<pre>[SqlgGraphStep(vertex,[])@[sqlgPathFakeLabel]]</pre>
</div>
</div>
<div class="paragraph">
<p>This example is similar to the <a href="#_graph_step">Graph Step</a> example except for an additional <code>Or Step</code> which in turn contains three <code>Has Step</code> s.
It shows the two <code>Vertex Step</code> s the <code>Or Step</code> and the <code>Has Step</code> s being folded into the <code>SqlgGraphStep</code>.</p>
</div>
<div class="paragraph">
<p>The <a href="apidocs//org/umlg/sqlg/step/SqlgGraphStep.html"><code>SqlgGraphStep</code></a> will generate the following <code>sql</code> to retrieve the data.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-sql hljs" data-lang="sql">SELECT
	"public"."V_C"."ID" AS "alias1",
	"public"."V_C"."name" AS "alias2"
FROM
	"public"."V_A" INNER JOIN
	"public"."E_ab" ON "public"."V_A"."ID" = "public"."E_ab"."public.A__O" INNER JOIN
	"public"."V_B" ON "public"."E_ab"."public.B__I" = "public"."V_B"."ID" INNER JOIN
	"public"."E_bc" ON "public"."V_B"."ID" = "public"."E_bc"."public.B__O" INNER JOIN
	"public"."V_C" ON "public"."E_bc"."public.C__I" = "public"."V_C"."ID"
WHERE
(("public"."V_C"."name" = ?) OR ("public"."V_C"."name" = ?) OR ("public"."V_C"."name" = ?)
) <b class="conum">(1)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>The <code>Or Step</code> realizes itself as a sql <code>where</code> clause.</p>
</li>
</ol>
</div>
</div>
<div class="sect3">
<h4 id="_and_step">10.1.5. And Step</h4>
<div class="paragraph">
<p><a href="http://tinkerpop.apache.org/docs/current/reference/#and-step"><code>And Step</code></a>s are folded into the <a href="#_graph_step">Graph Step</a> or <a href="#_vertex_step">Vertex Step</a>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-java hljs" data-lang="java">@Test
public void showAndStep() {
    Vertex a1 = this.sqlgGraph.addVertex(T.label, "A", "name", "a1");
    Vertex b1 = this.sqlgGraph.addVertex(T.label, "B", "name", "b1");
    Vertex b2 = this.sqlgGraph.addVertex(T.label, "B", "name", "b2");
    Vertex c1 = this.sqlgGraph.addVertex(T.label, "C", "name", "c1", "surname", "x", "address", "y");
    Vertex c2 = this.sqlgGraph.addVertex(T.label, "C", "name", "c2", "surname", "x", "address", "y");
    Vertex c3 = this.sqlgGraph.addVertex(T.label, "C", "name", "c3", "surname", "x", "address", "y");
    Vertex c4 = this.sqlgGraph.addVertex(T.label, "C", "name", "c4", "surname", "x", "address", "y");
    Vertex c5 = this.sqlgGraph.addVertex(T.label, "C", "name", "c5", "surname", "x", "address", "y");
    Vertex c6 = this.sqlgGraph.addVertex(T.label, "C", "name", "c6", "surname", "x", "address", "y");
    a1.addEdge("ab", b1);
    a1.addEdge("ab", b2);
    b1.addEdge("bc", c1);
    b2.addEdge("bc", c2);
    b2.addEdge("bc", c3);
    b2.addEdge("bc", c4);
    b2.addEdge("bc", c5);
    b2.addEdge("bc", c6);
    this.sqlgGraph.tx().commit();

    GraphTraversal&lt;Vertex, Vertex&gt; traversal = this.sqlgGraph.traversal().V()
            .hasLabel("A")
            .out()
            .out()
            .and(
                    __.has("name", "c1"),
                    __.has("surname", "x"),
                    __.has("address", "y")
            );

    System.out.println(traversal);
    traversal.hasNext();
    System.out.println(traversal);
    List&lt;Vertex&gt; c = traversal.toList();
    assertEquals(1, c.size());
}</code></pre>
</div>
</div>
<div id="anchor-before-optimization-and-step" class="listingblock">
<div class="title">Before optimization</div>
<div class="content">
<pre class="nowrap">[GraphStep(vertex,[]), HasStep([~label.eq(A)]), VertexStep(OUT,vertex), VertexStep(OUT,vertex), AndStep([[HasStep([name.eq(c1)])], [HasStep([surname.eq(x)])], [HasStep([address.eq(y)])]])]</pre>
</div>
</div>
<div id="anchor-after-optimization-and-step" class="listingblock">
<div class="title">After optimization</div>
<div class="content">
<pre>[SqlgGraphStep(vertex,[])@[sqlgPathFakeLabel]]</pre>
</div>
</div>
<div class="paragraph">
<p>This example is similar to the <a href="#_graph_step">Graph Step</a> example except for an additional <code>And Step</code> which in turn contains three <code>Has Step</code> s.
It shows the two <code>Vertex Step</code> s the <code>And Step</code> and the <code>Has Step</code> s being folded into the <code>SqlgGraphStep</code>.</p>
</div>
<div class="paragraph">
<p>The <a href="apidocs//org/umlg/sqlg/step/SqlgGraphStep.html"><code>SqlgGraphStep</code></a> will generate the following <code>sql</code> to retrieve the data.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-sql hljs" data-lang="sql">SELECT
	"public"."V_C"."ID" AS "alias1",
	"public"."V_C"."address" AS "alias2",
	"public"."V_C"."surname" AS "alias3",
	"public"."V_C"."name" AS "alias4"
FROM
	"public"."V_A" INNER JOIN
	"public"."E_ab" ON "public"."V_A"."ID" = "public"."E_ab"."public.A__O" INNER JOIN
	"public"."V_B" ON "public"."E_ab"."public.B__I" = "public"."V_B"."ID" INNER JOIN
	"public"."E_bc" ON "public"."V_B"."ID" = "public"."E_bc"."public.B__O" INNER JOIN
	"public"."V_C" ON "public"."E_bc"."public.C__I" = "public"."V_C"."ID"
WHERE
(("public"."V_C"."name" = ?) AND ("public"."V_C"."surname" = ?) AND ("public"."V_C"."address" = ?)
) <b class="conum">(1)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>The <code>And Step</code> realizes itself as a sql <code>where</code> clause.</p>
</li>
</ol>
</div>
</div>
<div class="sect3">
<h4 id="_not_step">10.1.6. Not Step</h4>
<div class="paragraph">
<p><a href="http://tinkerpop.apache.org/docs/current/reference/#not-step"><code>Not Step</code></a>s are folded into the <a href="#_graph_step">Graph Step</a> or <a href="#_vertex_step">Vertex Step</a>.</p>
</div>
</div>
<div class="sect3">
<h4 id="_repeat_step">10.1.7. Repeat Step</h4>
<div class="paragraph">
<p><a href="http://tinkerpop.apache.org/docs/current/reference/#repeat-step"><code>Repeat Step</code></a></p>
</div>
<div class="paragraph">
<p>Sqlg can optimize `RepeatStep`s,</p>
</div>
<div class="ulist">
<ul>
<li>
<p>with <strong>no</strong> <code>until</code> modulator. i.e. <code>times(x)</code> must be present.</p>
</li>
<li>
<p>recursive gremlin. i.e. the repeat step must loop over the same <code>VertexLabel</code></p>
</li>
</ul>
</div>
<div class="sect4">
<h5 id="_repeat_step_with_timesx">Repeat Step with <code>times(x)</code></h5>
<div class="sect5">
<h6 id="_repeat_step_with_emit_first">Repeat Step with emit first</h6>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-java hljs" data-lang="java">@Test
public void showRepeatStepEmitFirst() {
    Vertex a1 = this.sqlgGraph.addVertex(T.label, "A", "name", "a1");
    Vertex a2 = this.sqlgGraph.addVertex(T.label, "A", "name", "a2");
    Vertex b1 = this.sqlgGraph.addVertex(T.label, "B", "name", "b1");
    Vertex b2 = this.sqlgGraph.addVertex(T.label, "B", "name", "b2");
    Vertex c1 = this.sqlgGraph.addVertex(T.label, "C", "name", "c1");
    Vertex c2 = this.sqlgGraph.addVertex(T.label, "C", "name", "c2");
    Vertex c3 = this.sqlgGraph.addVertex(T.label, "C", "name", "c3");
    a1.addEdge("ab", b1);
    a1.addEdge("ab", b2);
    b1.addEdge("bc", c1);
    b1.addEdge("bc", c2);
    b1.addEdge("bc", c3);
    this.sqlgGraph.tx().commit();

    List&lt;Path&gt; paths = this.sqlgGraph.traversal().V().hasLabel("A")
            .emit()
            .times(2)
            .repeat(
                    __.out()
            )
            .path().by("name")
            .toList();
    for (Path path : paths) {
        System.out.println(path);
    }
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">output</div>
<div class="content">
<pre>[a1, b1, c3]
[a1, b1, c2]
[a1, b1, c1]
[a1]
[a2]
[a1, b1]
[a1, b2]</pre>
</div>
</div>
<div class="listingblock">
<div class="title">sql</div>
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-sql hljs" data-lang="sql">SELECT
	"public"."V_C"."ID" AS "alias1",
	"public"."V_C"."name" AS "alias2",
	"public"."V_A"."ID" AS "alias3",
	"public"."V_A"."name" AS "alias4",
	"public"."V_B"."ID" AS "alias5",
	"public"."V_B"."name" AS "alias6",
	"public"."E_ab"."ID" AS "alias7"
FROM
	"public"."V_A" INNER JOIN
	"public"."E_ab" ON "public"."V_A"."ID" = "public"."E_ab"."public.A__O" INNER JOIN
	"public"."V_B" ON "public"."E_ab"."public.B__I" = "public"."V_B"."ID" INNER JOIN
	"public"."E_bc" ON "public"."V_B"."ID" = "public"."E_bc"."public.B__O" INNER JOIN
	"public"."V_C" ON "public"."E_bc"."public.C__I" = "public"."V_C"."ID" <b class="conum">(1)</b>

SELECT
	"public"."V_A"."ID" AS "alias1",
	"public"."V_A"."name" AS "alias2"
FROM
	"public"."V_A" <b class="conum">(2)</b>

SELECT
	"public"."V_B"."ID" AS "alias1",
	"public"."V_B"."name" AS "alias2",
	"public"."V_A"."ID" AS "alias3",
	"public"."V_A"."name" AS "alias4",
	"public"."E_ab"."ID" AS "alias5"
FROM
	"public"."V_A" INNER JOIN
	"public"."E_ab" ON "public"."V_A"."ID" = "public"."E_ab"."public.A__O" INNER JOIN
	"public"."V_B" ON "public"."E_ab"."public.B__I" = "public"."V_B"."ID" <b class="conum">(3)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Get the 'A&#8217;s to emit.</p>
</li>
<li>
<p>Get the 'B&#8217;s to emit.</p>
</li>
<li>
<p>Get the 'C&#8217;s to emit.</p>
</li>
</ol>
</div>
</div>
<div class="sect5">
<h6 id="_repeat_step_with_emit_last">Repeat Step with emit last</h6>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-java hljs" data-lang="java">@Test
public void showRepeatStepEmitLast() {
    Vertex a1 = this.sqlgGraph.addVertex(T.label, "A", "name", "a1");
    Vertex a2 = this.sqlgGraph.addVertex(T.label, "A", "name", "a2");
    Vertex b1 = this.sqlgGraph.addVertex(T.label, "B", "name", "b1");
    Vertex b2 = this.sqlgGraph.addVertex(T.label, "B", "name", "b2");
    Vertex c1 = this.sqlgGraph.addVertex(T.label, "C", "name", "c1");
    Vertex c2 = this.sqlgGraph.addVertex(T.label, "C", "name", "c2");
    Vertex c3 = this.sqlgGraph.addVertex(T.label, "C", "name", "c3");
    a1.addEdge("ab", b1);
    a1.addEdge("ab", b2);
    b1.addEdge("bc", c1);
    b1.addEdge("bc", c2);
    b1.addEdge("bc", c3);
    this.sqlgGraph.tx().commit();

    List&lt;Path&gt; paths = this.sqlgGraph.traversal().V().hasLabel("A")
            .repeat(
                    __.out()
            )
            .emit()
            .times(2)
            .path().by("name")
            .toList();
    for (Path path : paths) {
        System.out.println(path);
    }
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">output</div>
<div class="content">
<pre>[a1, b1, c3]
[a1, b1, c2]
[a1, b1, c1]
[a1, b1]
[a1, b2]</pre>
</div>
</div>
<div class="listingblock">
<div class="title">sql</div>
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-sql hljs" data-lang="sql">SELECT
	"public"."V_C"."ID" AS "alias1",
	"public"."V_C"."name" AS "alias2",
	"public"."V_A"."ID" AS "alias3",
	"public"."V_A"."name" AS "alias4",
	"public"."V_B"."ID" AS "alias5",
	"public"."V_B"."name" AS "alias6",
	"public"."E_ab"."ID" AS "alias7",
	"public"."E_bc"."ID" AS "alias8"
FROM
	"public"."V_A" INNER JOIN
	"public"."E_ab" ON "public"."V_A"."ID" = "public"."E_ab"."public.A__O" INNER JOIN
	"public"."V_B" ON "public"."E_ab"."public.B__I" = "public"."V_B"."ID" INNER JOIN
	"public"."E_bc" ON "public"."V_B"."ID" = "public"."E_bc"."public.B__O" INNER JOIN
	"public"."V_C" ON "public"."E_bc"."public.C__I" = "public"."V_C"."ID" <b class="conum">(1)</b>

SELECT
	"public"."V_B"."ID" AS "alias1",
	"public"."V_B"."name" AS "alias2",
	"public"."V_A"."ID" AS "alias3",
	"public"."V_A"."name" AS "alias4",
	"public"."E_ab"."ID" AS "alias5"
FROM
	"public"."V_A" INNER JOIN
	"public"."E_ab" ON "public"."V_A"."ID" = "public"."E_ab"."public.A__O" INNER JOIN
	"public"."V_B" ON "public"."E_ab"."public.B__I" = "public"."V_B"."ID" <b class="conum">(2)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Get the 'C&#8217;s to emit.</p>
</li>
<li>
<p>Get the 'B&#8217;s to emit.</p>
</li>
</ol>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_recursive_repeat_step">Recursive Repeat Step</h5>
<div class="paragraph">
<p>Sqlg is able to optimize recursive repeat steps by utilizing postgres&#8217;s <a href="https://www.postgresql.org/docs/current/queries-with.html#QUERIES-WITH-RECURSIVE">recursive query</a> support.</p>
</div>
<div class="paragraph">
<p>Recursive queries can be broken into 2 main groups,</p>
</div>
<div class="ulist">
<ul>
<li>
<p>return leaf nodes</p>
</li>
<li>
<p>do not return leaf nodes</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Some examples,</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-java hljs" data-lang="java">@Test
public void friendOfFriendsTillTheLeafNodes() {
    VertexLabel friendVertexLabel = this.sqlgGraph.getTopology().getPublicSchema().ensureVertexLabelExist("Friend", new LinkedHashMap&lt;&gt;() {{
        put("name", PropertyDefinition.of(PropertyType.STRING, Multiplicity.of(1, 1)));
    }});
    friendVertexLabel.ensureEdgeLabelExist(
            "of",
            friendVertexLabel,
            EdgeDefinition.of(
                    Multiplicity.of(0, -1),
                    Multiplicity.of(0, -1)
            )
    );
    this.sqlgGraph.tx().commit();
    this.sqlgGraph.getTopology().lock();

    Vertex a = this.sqlgGraph.addVertex(T.label, "Friend", "name", "a");
    Vertex b = this.sqlgGraph.addVertex(T.label, "Friend", "name", "b");
    Vertex c = this.sqlgGraph.addVertex(T.label, "Friend", "name", "c");
    Vertex d = this.sqlgGraph.addVertex(T.label, "Friend", "name", "d");
    Vertex e = this.sqlgGraph.addVertex(T.label, "Friend", "name", "e");
    Vertex f = this.sqlgGraph.addVertex(T.label, "Friend", "name", "f");

    a.addEdge("of", b);
    a.addEdge("of", c);
    c.addEdge("of", d);
    c.addEdge("of", e);
    e.addEdge("of", f);

    this.sqlgGraph.tx().commit();
    List&lt;Path&gt; paths = this.sqlgGraph.traversal().V(a)
            .repeat(__.out("of").simplePath())
            .until(
                    __.not(__.out("of").simplePath()) <b class="conum">(1)</b>
            )
            .path()
            .by("name")
            .toList();
    for (Path path : paths) {
        LOGGER.info(path.toString());
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Repeat traversing <code>of</code> till the leaf nodes.</p>
</li>
</ol>
</div>
<div class="listingblock">
<div class="title">output</div>
<div class="content">
<pre>path[a, c, e, f]
path[a, b]
path[a, c, d]</pre>
</div>
</div>
<div class="listingblock">
<div class="title">sql</div>
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-sql hljs" data-lang="sql">WITH start AS (
    SELECT
	"public"."V_Friend"."ID" AS "alias1",
	"public"."V_Friend"."name" AS "alias2"
FROM
	"public"."V_Friend"
WHERE
	( "public"."V_Friend"."ID" = ?)
), a AS (
    WITH RECURSIVE search_tree("ID", "public.Friend__O", "public.Friend__I", depth, is_cycle, previous, path) AS (
        SELECT
            e."ID", e."public.Friend__O", e."public.Friend__I", 1, false, ARRAY[e."public.Friend__O"], ARRAY[e."public.Friend__O", e."public.Friend__I"]
        FROM
            "public"."E_of" e JOIN start ON start."alias1" = e."public.Friend__O"
        UNION ALL
        SELECT
            e."ID", e."public.Friend__O", e."public.Friend__I", st.depth + 1, e."public.Friend__I" = ANY(path), path, path || e."public.Friend__I"
        FROM
            "public"."E_of" e JOIN
            search_tree st ON st."public.Friend__I" = e."public.Friend__O" JOIN
            "public"."V_Friend" v ON st."public.Friend__I" = v."ID"
        WHERE NOT is_cycle
    )
    SELECT *, gen_random_uuid() FROM search_tree WHERE NOT is_cycle
), b AS (
    SELECT a.gen_random_uuid, a.path, c.vertex_id, c.ordinal FROM a LEFT JOIN UNNEST(a.path) WITH ORDINALITY AS c(vertex_id, ordinal) ON true
    WHERE a.path NOT IN (SELECT previous from a)
)
SELECT b.path, "public"."V_Friend"."ID" AS "alias1",
	"public"."V_Friend"."name" AS "alias2" from b JOIN "public"."V_Friend" ON b.vertex_id = "public"."V_Friend"."ID"
ORDER BY b.gen_random_uuid, b.path, b.path, b.ordinal;</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-java hljs" data-lang="java">@Test
public void friendOfFriendsTillTheLeafNodesOr() {
    VertexLabel friendVertexLabel = this.sqlgGraph.getTopology().getPublicSchema().ensureVertexLabelExist("Friend", new LinkedHashMap&lt;&gt;() {{
        put("name", PropertyDefinition.of(PropertyType.STRING, Multiplicity.of(1, 1)));
    }});
    friendVertexLabel.ensureEdgeLabelExist(
            "of",
            friendVertexLabel,
            EdgeDefinition.of(
                    Multiplicity.of(0, -1),
                    Multiplicity.of(0, -1)
            )
    );
    this.sqlgGraph.tx().commit();
    this.sqlgGraph.getTopology().lock();

    Vertex a = this.sqlgGraph.addVertex(T.label, "Friend", "name", "a");
    Vertex b = this.sqlgGraph.addVertex(T.label, "Friend", "name", "b");
    Vertex c = this.sqlgGraph.addVertex(T.label, "Friend", "name", "c");
    Vertex d = this.sqlgGraph.addVertex(T.label, "Friend", "name", "d");
    Vertex e = this.sqlgGraph.addVertex(T.label, "Friend", "name", "e");
    Vertex f = this.sqlgGraph.addVertex(T.label, "Friend", "name", "f");

    a.addEdge("of", b);
    a.addEdge("of", c);
    c.addEdge("of", d);
    c.addEdge("of", e);
    e.addEdge("of", f);

    this.sqlgGraph.tx().commit();
    List&lt;Path&gt; paths = this.sqlgGraph.traversal().V(a)
            .repeat(__.out("of").simplePath())
            .until(
                    __.or(
                            __.not(__.out("of").simplePath()), <b class="conum">(1)</b>
                            __.has("name", P.within("e")) <b class="conum">(2)</b>
                    )

            )
            .path()
            .by("name")
            .toList();
    for (Path path : paths) {
        LOGGER.info(path.toString());
    }

}</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Repeat traversing <code>of</code> till the leaf nodes.</p>
</li>
<li>
<p>Repeat till friend 'e'</p>
</li>
</ol>
</div>
<div class="listingblock">
<div class="title">output</div>
<div class="content">
<pre>path[a, c, e]
path[a, b]
path[a, c, d]</pre>
</div>
</div>
<div class="listingblock">
<div class="title">sql</div>
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-sql hljs" data-lang="sql"> WITH start AS (
    SELECT
	"public"."V_Friend"."ID" AS "alias1",
	"public"."V_Friend"."name" AS "alias2"
FROM
	"public"."V_Friend"
WHERE
	( "public"."V_Friend"."ID" = ?)
), a AS (
    WITH RECURSIVE search_tree("ID", "public.Friend__O", "public.Friend__I", depth, is_cycle, previous, path) AS (
        SELECT
            e."ID", e."public.Friend__O", e."public.Friend__I", 1, false, ARRAY[e."public.Friend__O"], ARRAY[e."public.Friend__O", e."public.Friend__I"]
        FROM
            "public"."E_of" e JOIN start ON start."alias1" = e."public.Friend__O"
        UNION ALL
        SELECT
            e."ID", e."public.Friend__O", e."public.Friend__I", st.depth + 1, e."public.Friend__I" = ANY(path), path, path || e."public.Friend__I"
        FROM
            "public"."E_of" e JOIN
            search_tree st ON st."public.Friend__I" = e."public.Friend__O" JOIN
            "public"."V_Friend" v ON st."public.Friend__I" = v."ID"
        WHERE NOT is_cycle AND NOT 	((v."name" = ?))
    )
    SELECT *, gen_random_uuid() FROM search_tree WHERE NOT is_cycle
), b AS (
    SELECT a.gen_random_uuid, a.path, c.vertex_id, c.ordinal FROM a LEFT JOIN UNNEST(a.path) WITH ORDINALITY AS c(vertex_id, ordinal) ON true
    WHERE a.path NOT IN (SELECT previous from a)
)
SELECT b.path, "public"."V_Friend"."ID" AS "alias1",
	"public"."V_Friend"."name" AS "alias2" from b JOIN "public"."V_Friend" ON b.vertex_id = "public"."V_Friend"."ID"
ORDER BY b.gen_random_uuid, b.path, b.path, b.ordinal;</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-java hljs" data-lang="java">@Test
public void friendOfFriendsBoth() {
    VertexLabel friendVertexLabel = this.sqlgGraph.getTopology().getPublicSchema().ensureVertexLabelExist("Friend", new LinkedHashMap&lt;&gt;() {{
        put("name", PropertyDefinition.of(PropertyType.STRING, Multiplicity.of(1, 1)));
    }});
    friendVertexLabel.ensureEdgeLabelExist(
            "of",
            friendVertexLabel,
            EdgeDefinition.of(
                    Multiplicity.of(0, -1),
                    Multiplicity.of(0, -1)
            )
    );
    this.sqlgGraph.tx().commit();
    this.sqlgGraph.getTopology().lock();

    Vertex a = this.sqlgGraph.addVertex(T.label, "Friend", "name", "a");
    Vertex b = this.sqlgGraph.addVertex(T.label, "Friend", "name", "b");
    Vertex c = this.sqlgGraph.addVertex(T.label, "Friend", "name", "c");
    Vertex d = this.sqlgGraph.addVertex(T.label, "Friend", "name", "d");
    Vertex e = this.sqlgGraph.addVertex(T.label, "Friend", "name", "e");
    Vertex f = this.sqlgGraph.addVertex(T.label, "Friend", "name", "f");

    a.addEdge("of", b);
    a.addEdge("of", c);
    c.addEdge("of", d);
    c.addEdge("of", e);
    e.addEdge("of", f);

    this.sqlgGraph.tx().commit();
    List&lt;Path&gt; paths = this.sqlgGraph.traversal().V(c)
            .repeat(__.both("of").simplePath())
            .until(
                    __.not(__.out("of").simplePath())
            )
            .path()
            .by("name")
            .toList();
    for (Path path : paths) {
        LOGGER.info(path.toString());
    }

}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">output</div>
<div class="content">
<pre>path[c, e, f]
path[c, a, b]
path[c, d]</pre>
</div>
</div>
<div class="listingblock">
<div class="title">sql</div>
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-sql hljs" data-lang="sql">WITH start as (
    SELECT
	"public"."V_Friend"."ID" AS "alias1",
	"public"."V_Friend"."name" AS "alias2"
FROM
	"public"."V_Friend"
WHERE
	( "public"."V_Friend"."ID" = ?)
), a AS (
    WITH RECURSIVE search_tree("ID", "public.Friend__O", "public.Friend__I", depth, is_cycle, previous, path, direction) AS (
        WITH start_out as (
            SELECT e."ID", e."public.Friend__O", e."public.Friend__I", 1, false,
                ARRAY[e."public.Friend__O"],
                ARRAY[e."public.Friend__O", e."public.Friend__I"],
                'OUT'
            FROM "public"."E_of" e JOIN start ON start."alias1" = e."public.Friend__O"
        ), start_in as (
            SELECT e."ID", e."public.Friend__O", e."public.Friend__I", 1, false,
                ARRAY[e."public.Friend__I"],
                ARRAY[e."public.Friend__I", e."public.Friend__O"],
                'IN'
            FROM "public"."E_of" e JOIN start ON start."alias1" = e."public.Friend__I"
        )
        SELECT start_out.* FROM start_out UNION ALL SELECT start_in.* FROM start_in
        UNION ALL
        SELECT e."ID", e."public.Friend__O", e."public.Friend__I", st.depth + 1,
            CASE
            WHEN st.direction = 'OUT' AND st."public.Friend__I" = e."public.Friend__O" THEN e."public.Friend__I" = ANY(path)
            WHEN st.direction = 'OUT' AND st."public.Friend__I" = e."public.Friend__I" THEN e."public.Friend__O" = ANY(path)
            WHEN st.direction = 'IN' AND st."public.Friend__O" = e."public.Friend__I" THEN e."public.Friend__O" = ANY(path)
            WHEN st.direction = 'IN' AND st."public.Friend__O" = e."public.Friend__O" THEN e."public.Friend__I" = ANY(path)
            END,
            CASE
            WHEN st.direction = 'OUT' AND st."public.Friend__I" = e."public.Friend__O" THEN path
            WHEN st.direction = 'OUT' AND st."public.Friend__I" = e."public.Friend__I" THEN path
            WHEN st.direction = 'IN' AND st."public.Friend__O" = e."public.Friend__I" THEN path
            WHEN st.direction = 'IN' AND st."public.Friend__O" = e."public.Friend__O" THEN path
            END,
            CASE
            WHEN st.direction = 'OUT' AND st."public.Friend__I" = e."public.Friend__O" THEN path || e."public.Friend__I"
            WHEN st.direction = 'OUT' AND st."public.Friend__I" = e."public.Friend__I" THEN path || e."public.Friend__O"
            WHEN st.direction = 'IN' AND st."public.Friend__O" = e."public.Friend__I" THEN path || e."public.Friend__O"
            WHEN st.direction = 'IN' AND st."public.Friend__O" = e."public.Friend__O" THEN path || e."public.Friend__I"
            END,
            CASE
            WHEN st.direction = 'OUT' AND st."public.Friend__I" = e."public.Friend__O" THEN 'OUT'
            WHEN st.direction = 'OUT' AND st."public.Friend__I" = e."public.Friend__I" THEN 'IN'
            WHEN st.direction = 'IN' AND st."public.Friend__O" = e."public.Friend__I" THEN 'IN'
            WHEN st.direction = 'IN' AND st."public.Friend__O" = e."public.Friend__O" THEN 'OUT'
            END
        FROM
            "public"."E_of" e JOIN
            search_tree st ON
                ((st.direction = 'OUT' AND (st."public.Friend__I" = e."public.Friend__O" OR st."public.Friend__I" = e."public.Friend__I"))
                OR
                 (st.direction = 'IN' AND (st."public.Friend__O" = e."public.Friend__I" OR st."public.Friend__O" = e."public.Friend__O"))) JOIN
            "public"."V_Friend" v ON
                ((st.direction = 'OUT' AND (st."public.Friend__I" = v."ID"))
                OR
                (st.direction = 'IN' AND (st."public.Friend__O" = v."ID")))
        WHERE
            NOT is_cycle
    )
    SELECT *, gen_random_uuid() FROM search_tree
    WHERE NOT is_cycle
), b AS (
    SELECT a.gen_random_uuid, a.path, vertex_id, ordinal FROM a LEFT JOIN UNNEST(a.path) WITH ORDINALITY AS b(vertex_id, ordinal) ON true
    WHERE a.path NOT IN (SELECT previous from a)
    ORDER BY a.gen_random_uuid, a.path, ordinal
)
SELECT b.path, "public"."V_Friend"."ID" AS "alias1",
	"public"."V_Friend"."name" AS "alias2" from b JOIN "public"."V_Friend" ON b.vertex_id = "public"."V_Friend"."ID";</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-java hljs" data-lang="java">@Test
public void testOutRepeatWithEdgeInPathDoc() {
    VertexLabel friendVertexLabel = this.sqlgGraph.getTopology().getPublicSchema().ensureVertexLabelExist("Friend", new LinkedHashMap&lt;&gt;() {{
        put("name", PropertyDefinition.of(PropertyType.STRING, Multiplicity.of(1, 1)));
    }});
    friendVertexLabel.ensureEdgeLabelExist(
            "of",
            friendVertexLabel,
            EdgeDefinition.of(
                    Multiplicity.of(0, -1),
                    Multiplicity.of(0, -1)
            ),
            new LinkedHashMap&lt;&gt;() {{
                put("name", PropertyDefinition.of(PropertyType.STRING, Multiplicity.of(1, 1)));
            }}
    );
    this.sqlgGraph.tx().commit();
    this.sqlgGraph.getTopology().lock();

    Vertex a = sqlgGraph.addVertex(T.label, "Friend", "name", "a");
    Vertex b = sqlgGraph.addVertex(T.label, "Friend", "name", "b");
    Vertex c = sqlgGraph.addVertex(T.label, "Friend", "name", "c");
    Vertex d = sqlgGraph.addVertex(T.label, "Friend", "name", "d");
    Vertex e = sqlgGraph.addVertex(T.label, "Friend", "name", "e");
    Vertex f = sqlgGraph.addVertex(T.label, "Friend", "name", "f");

    a.addEdge("of", b, "name", "ab");
    a.addEdge("of", c, "name", "ac");
    c.addEdge("of", d, "name", "cd");
    c.addEdge("of", e, "name", "ce");
    e.addEdge("of", f, "name", "ef");

    this.sqlgGraph.tx().commit();

    List&lt;Path&gt; paths = this.sqlgGraph.traversal().V(a)
            .repeat(__.outE("of").as("e").inV().as("v").simplePath())
            .until(
                    __.select("e").has("name", "ce")
            )
            .path().by("name")
            .toList();
    for (Path path : paths) {
        LOGGER.debug(path.toString());
    }
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">output</div>
<div class="content">
<pre>path[a, ac, c, ce, e]</pre>
</div>
</div>
<div class="listingblock">
<div class="title">sql</div>
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-sql hljs" data-lang="sql">WITH start AS (
    SELECT
	"public"."V_Friend"."ID" AS "alias1",
	"public"."V_Friend"."name" AS "alias2"
FROM
	"public"."V_Friend"
WHERE
	( "public"."V_Friend"."ID" = ?)
), a AS (
	WITH RECURSIVE search_tree("ID", "public.Friend__O", "public.Friend__I", depth, is_cycle, previous, path, epath) AS (
		SELECT
            e."ID", e."public.Friend__O", e."public.Friend__I", 1, false, ARRAY[e."public.Friend__O"], ARRAY[e."public.Friend__O", e."public.Friend__I"], ARRAY[e."ID"]
        FROM
            "public"."E_of" e JOIN start ON start."alias1" = e."public.Friend__O"
		UNION ALL
		SELECT
            e."ID", e."public.Friend__O", e."public.Friend__I", st.depth + 1, e."public.Friend__I" = ANY(path), path, path || e."public.Friend__I", epath || e."ID"
		FROM
            "public"."E_of" e JOIN
            search_tree st ON st."public.Friend__I" = e."public.Friend__O" JOIN
            "public"."V_Friend" v ON st."public.Friend__I" = v."ID" JOIN
            "public"."E_of" previous_e ON st."ID" = previous_e."ID"
		WHERE NOT is_cycle AND NOT	((previous_e."name" = ?))
	)
	SELECT *, gen_random_uuid() FROM search_tree WHERE NOT is_cycle
), b AS (
 	SELECT * FROM a JOIN
 	"public"."V_Friend" v ON a."public.Friend__I" = v."ID" JOIN
 	"public"."E_of" e ON a."ID" = e."ID"
 	WHERE  	((e."name" = ?))
), c AS (
	SELECT 'vertex' as "type", b.path, b.gen_random_uuid FROM b
	WHERE b.path NOT IN (SELECT previous from b)
	UNION ALL
	SELECT 'edge' as "type", b.epath, b.gen_random_uuid FROM b
	WHERE b.path NOT IN (SELECT previous from b)
), d AS (
    SELECT * FROM c JOIN UNNEST(c.path) WITH ORDINALITY AS cc(element_id, ordinal) ON c."type" = 'vertex' WHERE c."type" = 'vertex'
    UNION ALL
	SELECT * FROM c JOIN UNNEST(c.path) WITH ORDINALITY AS cc(element_id, ordinal) ON c."type" = 'edge' WHERE c."type" = 'edge'
), e AS (
    SELECT d.path, type, "ID", "name", null as dummy, null AS "name", ordinal, d.gen_random_uuid FROM d JOIN "public"."V_Friend" AS _v on d.element_id = _v."ID" WHERE d.type = 'vertex'
	UNION ALL
    SELECT d.path, type, "ID", null AS "name", null as dummy, "name", ordinal, d.gen_random_uuid FROM d JOIN "public"."E_of" AS _e on d.element_id = _e."ID" WHERE d.type = 'edge'
)
SELECT * from e
ORDER BY gen_random_uuid, ordinal, type desc</code></pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_optional_step">10.1.8. Optional Step</h4>
<div class="paragraph">
<p><a href="http://tinkerpop.apache.org/docs/current/reference/#optional-step"><code>Optional Step</code></a></p>
</div>
<div class="paragraph">
<p>Sqlg optimizes the OptionalStep.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-java hljs" data-lang="java">@Test
public void showOptionalStep() {
    Vertex a1 = this.sqlgGraph.addVertex(T.label, "A", "name", "a1");
    Vertex a2 = this.sqlgGraph.addVertex(T.label, "A", "name", "a2");
    Vertex b1 = this.sqlgGraph.addVertex(T.label, "B", "name", "b1");
    Vertex b2 = this.sqlgGraph.addVertex(T.label, "B", "name", "b2");
    Vertex c1 = this.sqlgGraph.addVertex(T.label, "C", "name", "c1");
    Vertex c2 = this.sqlgGraph.addVertex(T.label, "C", "name", "c2");
    Vertex c3 = this.sqlgGraph.addVertex(T.label, "C", "name", "c3");
    a1.addEdge("ab", b1);
    a1.addEdge("ab", b2);
    b1.addEdge("bc", c1);
    b1.addEdge("bc", c2);
    b1.addEdge("bc", c3);
    this.sqlgGraph.tx().commit();

    List&lt;Path&gt; paths = this.sqlgGraph.traversal()
            .V().hasLabel("A")
            .optional(
                    __.out().optional(
                            __.out()
                    )
            )
            .path().by("name")
            .toList();
    for (Path path : paths) {
        System.out.println(path);
    }
}</code></pre>
</div>
</div>
<div id="anchor-before-optimization-optional-step" class="listingblock">
<div class="title">Before optimization</div>
<div class="content">
<pre class="nowrap">[GraphStep(vertex,[]), HasStep([~label.eq(A)]), OptionalStep([VertexStep(OUT,vertex), OptionalStep([VertexStep(OUT,vertex)])]), PathStep([value(name)])]</pre>
</div>
</div>
<div id="anchor-after-optimization-optional-step" class="listingblock">
<div class="title">After optimization</div>
<div class="content">
<pre>[SqlgGraphStep(vertex,[])@[sqlgPathFakeLabel], PathStep([value(name)])]</pre>
</div>
</div>
<div class="listingblock">
<div class="title">output</div>
<div class="content">
<pre>[a1, b1, c3]
[a1, b1, c2]
[a1, b1, c1]
[a2]
[a1, b2]</pre>
</div>
</div>
<div class="listingblock">
<div class="title">sql</div>
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-sql hljs" data-lang="sql">SELECT
	"public"."V_C"."ID" AS "alias1",
	"public"."V_C"."name" AS "alias2",
	"public"."V_A"."ID" AS "alias3",
	"public"."V_A"."name" AS "alias4",
	"public"."V_B"."ID" AS "alias5",
	"public"."V_B"."name" AS "alias6"
FROM
	"public"."V_A" INNER JOIN
	"public"."E_ab" ON "public"."V_A"."ID" = "public"."E_ab"."public.A__O" INNER JOIN
	"public"."V_B" ON "public"."E_ab"."public.B__I" = "public"."V_B"."ID" INNER JOIN
	"public"."E_bc" ON "public"."V_B"."ID" = "public"."E_bc"."public.B__O" INNER JOIN
	"public"."V_C" ON "public"."E_bc"."public.C__I" = "public"."V_C"."ID" <b class="conum">(1)</b>

SELECT
	"public"."V_A"."ID" AS "alias1",
	"public"."V_A"."name" AS "alias2"
FROM
	"public"."V_A" LEFT JOIN
	"public"."E_ab" ON "public"."V_A"."ID" = "public"."E_ab"."public.A__O"
WHERE
	("public"."E_ab"."public.A__O" IS NULL) <b class="conum">(2)</b>

SELECT
	"public"."V_B"."ID" AS "alias1",
	"public"."V_B"."name" AS "alias2",
	"public"."V_A"."ID" AS "alias3",
	"public"."V_A"."name" AS "alias4"
FROM
	"public"."V_A" INNER JOIN
	"public"."E_ab" ON "public"."V_A"."ID" = "public"."E_ab"."public.A__O" INNER JOIN
	"public"."V_B" ON "public"."E_ab"."public.B__I" = "public"."V_B"."ID" LEFT JOIN
	"public"."E_bc" ON "public"."V_B"."ID" = "public"."E_bc"."public.B__O"
WHERE
	("public"."E_bc"."public.B__O" IS NULL) <b class="conum">(3)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Get the 'C&#8217;s</p>
</li>
<li>
<p>Get the 'A&#8217;s that do not have 'B&#8217;s</p>
</li>
<li>
<p>Get the 'B&#8217;s that do not have 'C&#8217;s</p>
</li>
</ol>
</div>
</div>
<div class="sect3">
<h4 id="_choose_step">10.1.9. Choose Step</h4>
<div class="paragraph">
<p><a href="http://tinkerpop.apache.org/docs/current/reference/#choose-step"><code>Choose Step</code></a></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-java hljs" data-lang="java">@Test
public void showChooseStep() {
    Vertex a1 = this.sqlgGraph.addVertex(T.label, "A", "name", "a1");
    Vertex a2 = this.sqlgGraph.addVertex(T.label, "A", "name", "a2");
    Vertex b1 = this.sqlgGraph.addVertex(T.label, "B", "name", "b1");
    Vertex b2 = this.sqlgGraph.addVertex(T.label, "B", "name", "b2");
    a1.addEdge("ab", b1);
    a1.addEdge("ab", b2);
    this.sqlgGraph.tx().commit();

    Traversal&lt;Vertex, Path&gt; traversal = this.sqlgGraph.traversal()
            .V().hasLabel("A")
            .choose(__.out(), __.out())
            .path().by("name");

    printTraversalForm(traversal);

    List&lt;Path&gt; paths = traversal.toList();
    for (Path path : paths) {
        System.out.println(path);
    }
}</code></pre>
</div>
</div>
<div id="anchor-before-optimization-choose-step" class="listingblock">
<div class="title">Before optimization</div>
<div class="content">
<pre class="nowrap">[GraphStep(vertex,[]), HasStep([~label.eq(A)]), ChooseStep([VertexStep(OUT,vertex), HasNextStep],{false=[[IdentityStep, EndStep]], true=[[VertexStep(OUT,vertex), EndStep]]}), PathStep([value(name)])]</pre>
</div>
</div>
<div id="anchor-after-optimization-choose-step" class="listingblock">
<div class="title">After optimization</div>
<div class="content">
<pre>[SqlgGraphStep(vertex,[])@[sqlgPathFakeLabel], PathStep([value(name)])]</pre>
</div>
</div>
<div class="listingblock">
<div class="title">output</div>
<div class="content">
<pre>[a1, b1]
[a1, b2]
[a2]</pre>
</div>
</div>
<div class="listingblock">
<div class="title">sql</div>
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-sql hljs" data-lang="sql">SELECT
	"public"."V_B"."ID" AS "alias1",
	"public"."V_B"."name" AS "alias2",
	"public"."V_A"."ID" AS "alias3",
	"public"."V_A"."name" AS "alias4"
FROM
	"public"."V_A" INNER JOIN
	"public"."E_ab" ON "public"."V_A"."ID" = "public"."E_ab"."public.A__O" INNER JOIN
	"public"."V_B" ON "public"."E_ab"."public.B__I" = "public"."V_B"."ID"
DEBUG 2018-08-12 19:31:50,944 [main] org.umlg.sqlg.strategy.SqlgSqlExecutor:
SELECT
	"public"."V_A"."ID" AS "alias1",
	"public"."V_A"."name" AS "alias2"
FROM
	"public"."V_A" LEFT JOIN
	"public"."E_ab" ON "public"."V_A"."ID" = "public"."E_ab"."public.A__O"
WHERE
	("public"."E_ab"."public.A__O" IS NULL)</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_order_step">10.1.10. Order Step</h4>
<div class="paragraph">
<p><a href="http://tinkerpop.apache.org/docs/current/reference/#order-step"><code>Order Step</code></a></p>
</div>
<div class="paragraph">
<p>Sqlg optimizes the OrderGlobalStep if the data that the order applies to can be retrieved in one sql statement.
If not then order the ordering occurs in java via the OrderGlobalStep as per normal.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-java hljs" data-lang="java">@Test
public void testOrderBy() {
    Vertex a1 = this.sqlgGraph.addVertex(T.label, "A", "name", "a", "surname", "a");
    Vertex a2 = this.sqlgGraph.addVertex(T.label, "A", "name", "a", "surname", "b");
    Vertex a3 = this.sqlgGraph.addVertex(T.label, "A", "name", "a", "surname", "c");
    Vertex b1 = this.sqlgGraph.addVertex(T.label, "A", "name", "b", "surname", "a");
    Vertex b2 = this.sqlgGraph.addVertex(T.label, "A", "name", "b", "surname", "b");
    Vertex b3 = this.sqlgGraph.addVertex(T.label, "A", "name", "b", "surname", "c");
    this.sqlgGraph.tx().commit();

    Traversal&lt;Vertex, Vertex&gt; traversal = this.sqlgGraph.traversal().V().hasLabel("A")
            .order().by("name", Order.incr).by("surname", Order.decr);
    printTraversalForm(traversal);

    List&lt;Vertex&gt; vertices = traversal.toList();
    for (Vertex v : vertices) {
        System.out.println(v.value("name") + " " + v.value("surname"));
    }
}</code></pre>
</div>
</div>
<div id="anchor-before-optimization-order-step" class="listingblock">
<div class="title">Before optimization</div>
<div class="content">
<pre class="nowrap">[GraphStep(vertex,[]), HasStep([~label.eq(A)]), OrderGlobalStep([[value(name), incr], [value(surname), decr]])]</pre>
</div>
</div>
<div id="anchor-after-optimization-order-step" class="listingblock">
<div class="title">After optimization</div>
<div class="content">
<pre>[SqlgGraphStep(vertex,[])@[sqlgPathOrderRangeLabel]]</pre>
</div>
</div>
<div class="listingblock">
<div class="title">output</div>
<div class="content">
<pre>a c
a b
a a
b c
b b
b a</pre>
</div>
</div>
<div class="listingblock">
<div class="title">sql</div>
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-sql hljs" data-lang="sql">SELECT
	"public"."V_A"."ID" AS "alias1",
	"public"."V_A"."surname" AS "alias2",
	"public"."V_A"."name" AS "alias3"
FROM
	"public"."V_A"
ORDER BY
	 "alias3" ASC,
	 "alias2" DESC</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_range_step">10.1.11. Range Step</h4>
<div class="paragraph">
<p><a href="http://tinkerpop.apache.org/docs/current/reference/#range-step"><code>Range Step</code></a></p>
</div>
<div class="paragraph">
<p>Sqlg optimizes the <code>RangeGlobalStep</code></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-java hljs" data-lang="java">@Test
public void testRangeOnVertexLabels() {
    for (int i = 0; i &lt; 100; i++) {
        this.sqlgGraph.addVertex(T.label, "Person", "name", "person" + i);
    }
    this.sqlgGraph.tx().commit();
    Traversal&lt;Vertex, String&gt; traversal = this.sqlgGraph.traversal()
            .V().hasLabel("Person")
            .order().by("name")
            .range(1, 4)
            .values("name");
    printTraversalForm(traversal);

    List&lt;String&gt; names = traversal.toList();
    for (String name : names) {
        System.out.println(name);
    }
}</code></pre>
</div>
</div>
<div id="anchor-before-optimization-range-step" class="listingblock">
<div class="title">Before optimization</div>
<div class="content">
<pre class="nowrap">[GraphStep(vertex,[]), HasStep([~label.eq(Person)]), OrderGlobalStep([[value(name), incr]]), RangeGlobalStep(1,4), PropertiesStep([name],value)]</pre>
</div>
</div>
<div id="anchor-after-optimization-range-step" class="listingblock">
<div class="title">After optimization</div>
<div class="content">
<pre class="nowrap">[SqlgGraphStep(vertex,[])@[sqlgPathOrderRangeLabel], PropertiesStep([name],value)]</pre>
</div>
</div>
<div class="listingblock">
<div class="title">output</div>
<div class="content">
<pre>person1
person10
person11</pre>
</div>
</div>
<div class="listingblock">
<div class="title">sql</div>
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-sql hljs" data-lang="sql">SELECT
	"public"."V_Person"."ID" AS "alias1",
	"public"."V_Person"."name" AS "alias2"
FROM
	"public"."V_Person"
ORDER BY
	 "alias2" ASC
LIMIT 3 OFFSET 1</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_limit_step">10.1.12. Limit Step</h4>
<div class="paragraph">
<p><a href="http://tinkerpop.apache.org/docs/current/reference/#limit-step"><code>Limit Step</code></a></p>
</div>
<div class="paragraph">
<p>Sqlg optimizes <code>.limit(x)</code></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-java hljs" data-lang="java">@Test
public void testLimitOnVertexLabels() {
    for (int i = 0; i &lt; 100; i++) {
        this.sqlgGraph.addVertex(T.label, "Person", "name", "person" + i);
    }
    this.sqlgGraph.tx().commit();
    Traversal&lt;Vertex, String&gt; traversal = this.sqlgGraph.traversal()
            .V().hasLabel("Person")
            .order().by("name")
            .limit(3)
            .values("name");
    printTraversalForm(traversal);

    List&lt;String&gt; names = traversal.toList();
    for (String name : names) {
        System.out.println(name);
    }
}</code></pre>
</div>
</div>
<div id="anchor-before-optimization-limit-step" class="listingblock">
<div class="title">Before optimization</div>
<div class="content">
<pre class="nowrap">[GraphStep(vertex,[]), HasStep([~label.eq(Person)]), OrderGlobalStep([[value(name), incr]]), RangeGlobalStep(0,3), PropertiesStep([name],value)]</pre>
</div>
</div>
<div id="anchor-after-optimization-limit-step" class="listingblock">
<div class="title">After optimization</div>
<div class="content">
<pre class="nowrap">[SqlgGraphStep(vertex,[])@[sqlgPathOrderRangeLabel], PropertiesStep([name],value)]</pre>
</div>
</div>
<div class="listingblock">
<div class="title">output</div>
<div class="content">
<pre>person0
person1
person10</pre>
</div>
</div>
<div class="listingblock">
<div class="title">sql</div>
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-sql hljs" data-lang="sql">SELECT
	"public"."V_Person"."ID" AS "alias1",
	"public"."V_Person"."name" AS "alias2"
FROM
	"public"."V_Person"
ORDER BY
	 "alias2" ASC
LIMIT 3 OFFSET 0</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_drop_step">10.1.13. Drop Step</h4>
<div class="paragraph">
<p><a href="http://tinkerpop.apache.org/docs/current/reference/#drop-step"><code>Drop Step</code></a></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-java hljs" data-lang="java">@Test
public void testsDropStepTrivial() {
    this.sqlgGraph.addVertex(T.label, "A", "name", "a1");
    this.sqlgGraph.addVertex(T.label, "A", "name", "a2");
    this.sqlgGraph.addVertex(T.label, "A", "name", "a3");
    this.sqlgGraph.tx().commit();

    Traversal&lt;Vertex, Vertex&gt; traversal = this.sqlgGraph.traversal().V().hasLabel("A").drop();
    printTraversalForm(traversal);

    traversal.iterate();
    this.sqlgGraph.tx().commit();

    assertEquals(0, this.sqlgGraph.traversal().V().hasLabel("A").count().next(), 0);
}</code></pre>
</div>
</div>
<div id="anchor-before-optimization-drop-step-trivial" class="listingblock">
<div class="title">Before optimization</div>
<div class="content">
<pre class="nowrap">[GraphStep(vertex,[]), HasStep([~label.eq(A)]), DropStep]</pre>
</div>
</div>
<div id="anchor-after-optimization-drop-step-trivial" class="listingblock">
<div class="title">After optimization</div>
<div class="content">
<pre class="nowrap">[SqlgGraphStep(vertex,[]), SqlgDropStepBarrier]</pre>
</div>
</div>
<div class="listingblock">
<div class="title">sql</div>
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-sql hljs" data-lang="sql">TRUNCATE ONLY "public"."V_A" <b class="conum">(1)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>As vertex label 'A' has no in or out edges nor are there any predicates the <code>TRUNCATE</code> command is used.</p>
</li>
</ol>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-java hljs" data-lang="java">@Test
public void testsDropStepWithHas() {
    this.sqlgGraph.addVertex(T.label, "A", "name", "a1");
    this.sqlgGraph.addVertex(T.label, "A", "name", "a2");
    this.sqlgGraph.addVertex(T.label, "A", "name", "a3");
    this.sqlgGraph.tx().commit();

    Traversal&lt;Vertex, Vertex&gt; traversal = this.sqlgGraph.traversal().V()
            .hasLabel("A")
            .has("name", P.within("a1", "a2"))
            .drop();
    printTraversalForm(traversal);

    traversal.iterate();
    this.sqlgGraph.tx().commit();

    assertEquals(1, this.sqlgGraph.traversal().V().hasLabel("A").count().next(), 0);
}</code></pre>
</div>
</div>
<div id="anchor-before-optimization-drop-step-with-has" class="listingblock">
<div class="title">Before optimization</div>
<div class="content">
<pre class="nowrap">[GraphStep(vertex,[]), HasStep([~label.eq(A), name.within([a1, a2])]), DropStep]</pre>
</div>
</div>
<div id="anchor-after-optimization-drop-step-with-has" class="listingblock">
<div class="title">After optimization</div>
<div class="content">
<pre class="nowrap">[SqlgGraphStep(vertex,[]), SqlgDropStepBarrier]</pre>
</div>
</div>
<div class="listingblock">
<div class="title">sql</div>
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-sql hljs" data-lang="sql">WITH todelete AS (
SELECT
	"public"."V_A"."ID" AS "alias1"
FROM
	"public"."V_A"
WHERE
	( "public"."V_A"."name" in (?, ?))
)
DELETE FROM "public"."V_A" a USING todelete
WHERE a."ID" = todelete."alias1" <b class="conum">(1)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p><code>DELETE</code> with a where clause.</p>
</li>
</ol>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-java hljs" data-lang="java">@Test
public void testDropStepWithEdges() {
    Vertex a1 = this.sqlgGraph.addVertex(T.label, "A", "name", "a1");
    Vertex b1 = this.sqlgGraph.addVertex(T.label, "B", "name", "b1");
    Vertex b2 = this.sqlgGraph.addVertex(T.label, "B", "name", "b2");
    Vertex b3 = this.sqlgGraph.addVertex(T.label, "B", "name", "b3");
    a1.addEdge("ab", b1);
    a1.addEdge("ab", b2);
    a1.addEdge("ab", b3);
    this.sqlgGraph.tx().commit();

    Traversal&lt;Vertex, Vertex&gt; traversal = this.sqlgGraph.traversal().V().hasLabel("A").out().drop();
    printTraversalForm(traversal);

    traversal.iterate();
    this.sqlgGraph.tx().commit();

    assertEquals(0, this.sqlgGraph.traversal().V().hasLabel("B").count().next(), 0);
}</code></pre>
</div>
</div>
<div id="anchor-before-optimization-drop-step-with-edges" class="listingblock">
<div class="title">Before optimization</div>
<div class="content">
<pre class="nowrap">[GraphStep(vertex,[]), HasStep([~label.eq(A)]), VertexStep(OUT,vertex), DropStep]</pre>
</div>
</div>
<div id="anchor-after-optimization-drop-step-with-edges" class="listingblock">
<div class="title">After optimization</div>
<div class="content">
<pre class="nowrap">[SqlgGraphStep(vertex,[]), SqlgDropStepBarrier]</pre>
</div>
</div>
<div class="listingblock">
<div class="title">sql</div>
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-sql hljs" data-lang="sql">SET CONSTRAINTS ALL DEFERRED <b class="conum">(1)</b>

WITH todelete AS (
SELECT
	"public"."V_B"."ID" AS "alias1"
FROM
	"public"."V_A" INNER JOIN
	"public"."E_ab" ON "public"."V_A"."ID" = "public"."E_ab"."public.A__O" INNER JOIN
	"public"."V_B" ON "public"."E_ab"."public.B__I" = "public"."V_B"."ID"
)
DELETE FROM "public"."V_B" a USING todelete
WHERE a."ID" = todelete."alias1" <b class="conum">(2)</b>

WITH todelete AS (
SELECT
	"public"."E_ab"."ID" AS "alias1"
FROM
	"public"."V_A" INNER JOIN
	"public"."E_ab" ON "public"."V_A"."ID" = "public"."E_ab"."public.A__O" LEFT JOIN
	"public"."V_B" ON "public"."E_ab"."public.B__I" = "public"."V_B"."ID"
WHERE
	("public"."V_B"."ID" IS NULL) AND
	("public"."E_ab"."public.B__I" IS NOT NULL)
)
DELETE FROM "public"."E_ab" a USING todelete
WHERE a."ID" = todelete."alias1" <b class="conum">(3)</b>

SET CONSTRAINTS ALL IMMEDIATE <b class="conum">(4)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>On postgresql we defer (disable) the foreign key constraints.</p>
</li>
<li>
<p>Delete the 'B' vertices first. As the edge constraints are disabled this is possible.</p>
</li>
<li>
<p>Delete the edges.
&lt;4&gt;. Enable the foreign key constraints.</p>
</li>
</ol>
</div>
</div>
<div class="sect3">
<h4 id="_reducing_steps">10.1.14. Reducing Steps</h4>
<div class="paragraph">
<p><a href="http://tinkerpop.apache.org/docs/current/reference/#a-note-on-barrier-steps"><code>Reducing Steps</code></a></p>
</div>
<div class="sect4">
<h5 id="_min_step">Min Step</h5>
<div class="paragraph">
<p><a href="http://tinkerpop.apache.org/docs/current/reference/#min-step"><code>Min Step</code></a></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-java hljs" data-lang="java">@Test
public void testMin() {
    this.sqlgGraph.addVertex(T.label, "Person", "age", 1);
    this.sqlgGraph.addVertex(T.label, "Person", "age", 2);
    this.sqlgGraph.addVertex(T.label, "Person", "age", 3);
    this.sqlgGraph.addVertex(T.label, "Person", "age", 0);
    this.sqlgGraph.tx().commit();

    DefaultTraversal&lt;Vertex, Integer&gt; traversal = (DefaultTraversal) this.sqlgGraph.traversal().V().hasLabel("Person").values("age").min();
    Assert.assertEquals(0, traversal.next(), 0);
}</code></pre>
</div>
</div>
<div id="anchor-before-optimization-min-step" class="listingblock">
<div class="title">Before optimization</div>
<div class="content">
<pre class="nowrap">[GraphStep(vertex,[]), HasStep([~label.eq(Person)]), PropertiesStep([age],value), MinGlobalStep]</pre>
</div>
</div>
<div id="anchor-after-optimization-min-step" class="listingblock">
<div class="title">After optimization</div>
<div class="content">
<pre class="nowrap">[SqlgGraphStep(vertex,[])@[sqlgPathTempFakeLabel], SqlgPropertiesStep([age],value), SqlgMinGlobalStep]</pre>
</div>
</div>
<div class="listingblock">
<div class="title">sql</div>
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-sql hljs" data-lang="sql">SELECT
	MIN("public"."V_Person"."age") AS "alias1"
FROM
	"public"."V_Person"</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_max_step">Max Step</h5>
<div class="paragraph">
<p><a href="http://tinkerpop.apache.org/docs/current/reference/#max-step"><code>Max Step</code></a></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-java hljs" data-lang="java">@Test
public void testMax() {
    this.sqlgGraph.addVertex(T.label, "Person", "age", 1, "x", 1);
    this.sqlgGraph.addVertex(T.label, "Person", "age", 2, "x", 1);
    this.sqlgGraph.addVertex(T.label, "Person", "age", 3, "x", 1);
    this.sqlgGraph.addVertex(T.label, "Person", "age", 0, "x", 1);
    this.sqlgGraph.tx().commit();

    DefaultTraversal&lt;Vertex, Integer&gt; traversal = (DefaultTraversal) this.sqlgGraph.traversal().V().hasLabel("Person").values("age").max();
    printTraversalForm(traversal);
    Assert.assertEquals(3, traversal.next(), 0);
}</code></pre>
</div>
</div>
<div id="anchor-before-optimization-max-step" class="listingblock">
<div class="title">Before optimization</div>
<div class="content">
<pre class="nowrap">[GraphStep(vertex,[]), HasStep([~label.eq(Person)]), PropertiesStep([age],value), MaxGlobalStep]</pre>
</div>
</div>
<div id="anchor-after-optimization-max-step" class="listingblock">
<div class="title">After optimization</div>
<div class="content">
<pre class="nowrap">[SqlgGraphStep(vertex,[])@[sqlgPathTempFakeLabel], SqlgPropertiesStep([age],value), SqlgMaxGlobalStep]</pre>
</div>
</div>
<div class="listingblock">
<div class="title">sql</div>
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-sql hljs" data-lang="sql">SELECT
	MAX("public"."V_Person"."age") AS "alias1"
FROM
	"public"."V_Person"</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_sum_step">Sum Step</h5>
<div class="paragraph">
<p><a href="http://tinkerpop.apache.org/docs/current/reference/#sum-step"><code>Sum Step</code></a></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-java hljs" data-lang="java">@Test
public void testSum() {
    this.sqlgGraph.addVertex(T.label, "Person", "age", 1);
    this.sqlgGraph.addVertex(T.label, "Person", "age", 2);
    this.sqlgGraph.addVertex(T.label, "Person", "age", 3);
    this.sqlgGraph.addVertex(T.label, "Person", "age", 0);
    this.sqlgGraph.tx().commit();

    DefaultTraversal&lt;Vertex, Long&gt; traversal = (DefaultTraversal) this.sqlgGraph.traversal().V().hasLabel("Person").values("age").sum();
    printTraversalForm(traversal);
    Assert.assertEquals(6, traversal.next(), 0L);
}</code></pre>
</div>
</div>
<div id="anchor-before-optimization-sum-step" class="listingblock">
<div class="title">Before optimization</div>
<div class="content">
<pre class="nowrap">[GraphStep(vertex,[]), HasStep([~label.eq(Person)]), PropertiesStep([age],value), SumGlobalStep]</pre>
</div>
</div>
<div id="anchor-after-optimization-sum-step" class="listingblock">
<div class="title">After optimization</div>
<div class="content">
<pre class="nowrap">[SqlgGraphStep(vertex,[])@[sqlgPathTempFakeLabel], SqlgPropertiesStep([age],value), SqlgSumGlobalStep]</pre>
</div>
</div>
<div class="listingblock">
<div class="title">sql</div>
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-sql hljs" data-lang="sql">SELECT
	SUM("public"."V_Person"."age") AS "alias1"
FROM
	"public"."V_Person"</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_mean_step">Mean Step</h5>
<div class="paragraph">
<p><a href="http://tinkerpop.apache.org/docs/current/reference/#mean-step"><code>Mean Step</code></a></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-java hljs" data-lang="java">@Test
public void testMean() {
    this.sqlgGraph.addVertex(T.label, "Person", "age", 1);
    this.sqlgGraph.addVertex(T.label, "Person", "age", 2);
    this.sqlgGraph.addVertex(T.label, "Person", "age", 3);
    this.sqlgGraph.addVertex(T.label, "Person", "age", 0);
    this.sqlgGraph.tx().commit();
    DefaultTraversal&lt;Vertex, Double&gt; traversal = (DefaultTraversal) this.sqlgGraph.traversal().V().hasLabel("Person").values("age").mean();
    printTraversalForm(traversal);
    Double d = traversal.next();
    Assert.assertEquals(1.5, d, 0D);
}</code></pre>
</div>
</div>
<div id="anchor-before-optimization-mean-step" class="listingblock">
<div class="title">Before optimization</div>
<div class="content">
<pre class="nowrap">[GraphStep(vertex,[]), HasStep([~label.eq(Person)]), PropertiesStep([age],value), MeanGlobalStep]</pre>
</div>
</div>
<div id="anchor-after-optimization-mean-step" class="listingblock">
<div class="title">After optimization</div>
<div class="content">
<pre class="nowrap">[SqlgGraphStep(vertex,[])@[sqlgPathTempFakeLabel], SqlgPropertiesStep([age],value), SqlgAvgGlobalStep]</pre>
</div>
</div>
<div class="listingblock">
<div class="title">sql</div>
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-sql hljs" data-lang="sql">SELECT
	AVG("public"."V_Person"."age") AS "alias1", COUNT(1) AS "alias1_weight"
FROM
	"public"."V_Person"</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_count_step">Count Step</h5>
<div class="paragraph">
<p><a href="http://tinkerpop.apache.org/docs/current/reference/#count-step"><code>Count Step</code></a></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-java hljs" data-lang="java">@Test
public void testCount() {
    this.sqlgGraph.addVertex(T.label, "A", "name", "a");
    this.sqlgGraph.addVertex(T.label, "A", "name", "a");
    this.sqlgGraph.addVertex(T.label, "A", "name", "a");
    this.sqlgGraph.addVertex(T.label, "A", "name", "a");
    this.sqlgGraph.tx().commit();
    DefaultTraversal&lt;Vertex, Long&gt; traversal = (DefaultTraversal&lt;Vertex, Long&gt;) this.sqlgGraph.traversal().V().count();
    printTraversalForm(traversal);
    Assert.assertEquals(4, traversal.next(), 0);
}</code></pre>
</div>
</div>
<div id="anchor-before-optimization-count-step" class="listingblock">
<div class="title">Before optimization</div>
<div class="content">
<pre class="nowrap">[GraphStep(vertex,[]), CountGlobalStep]</pre>
</div>
</div>
<div id="anchor-after-optimization-count-step" class="listingblock">
<div class="title">After optimization</div>
<div class="content">
<pre class="nowrap">[SqlgGraphStep(vertex,[])@[sqlgPathTempFakeLabel], SqlgPropertiesStep([count],value), SqlgCountGlobalStep]</pre>
</div>
</div>
<div class="listingblock">
<div class="title">sql</div>
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-sql hljs" data-lang="sql">SELECT
	COUNT(1)
FROM
	"public"."V_A"</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_group_by">Group By</h5>
<div class="paragraph">
<p><a href="http://tinkerpop.apache.org/docs/current/reference/#group-step"><code>Group Step</code></a>'s are optimized with sql&#8217;s <code>group by</code> clause.</p>
</div>
</div>
<div class="sect4">
<h5 id="_group_by_and_min_step">Group By and Min Step</h5>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-java hljs" data-lang="java">@Test
public void testGroupOverOnePropertyMin() {
    this.sqlgGraph.addVertex(T.label, "Person", "name", "A", "age", 1);
    this.sqlgGraph.addVertex(T.label, "Person", "name", "B", "age", 2);
    this.sqlgGraph.addVertex(T.label, "Person", "name", "A", "age", 3);
    this.sqlgGraph.addVertex(T.label, "Person", "name", "B", "age", 4);
    this.sqlgGraph.tx().commit();

    DefaultTraversal&lt;Vertex, Map&lt;String, Integer&gt;&gt; traversal = (DefaultTraversal) sqlgGraph.traversal()
            .V().hasLabel("Person")
            .&lt;String, Integer&gt;group().by("name").by(__.values("age").min());
    printTraversalForm(traversal);
    Map&lt;String, Integer&gt; result = traversal.next();
    Assert.assertFalse(traversal.hasNext());
    Assert.assertTrue(result.containsKey("A"));
    Assert.assertTrue(result.containsKey("B"));
    Assert.assertEquals(1, result.get("A"), 0);
    Assert.assertEquals(2, result.get("B"), 0);
}</code></pre>
</div>
</div>
<div id="anchor-before-optimization-groupbymin-step" class="listingblock">
<div class="title">Before optimization</div>
<div class="content">
<pre class="nowrap">[GraphStep(vertex,[]), HasStep([~label.eq(Person)]), GroupStep(value(name),[PropertiesStep([age],value), MinGlobalStep])]</pre>
</div>
</div>
<div id="anchor-after-optimization-groupbymin-step" class="listingblock">
<div class="title">After optimization</div>
<div class="content">
<pre class="nowrap">[SqlgGraphStep(vertex,[])@[sqlgPathTempFakeLabel], SqlgGroupStep]</pre>
</div>
</div>
<div class="listingblock">
<div class="title">sql</div>
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-sql hljs" data-lang="sql">SELECT
	"public"."V_Person"."name" AS "alias1",
	MIN("public"."V_Person"."age") AS "alias2"
FROM
	"public"."V_Person"
GROUP BY
	"public"."V_Person"."name"</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_group_by_and_max_step">Group By and Max Step</h5>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-java hljs" data-lang="java">    @Test
    public void testGroupByLabelMax() {
        this.sqlgGraph.addVertex(T.label, "Person", "name", "A", "age", 10);
        this.sqlgGraph.addVertex(T.label, "Person", "name", "B", "age", 20);
        this.sqlgGraph.addVertex(T.label, "Person", "name", "C", "age", 100);
        this.sqlgGraph.addVertex(T.label, "Person", "name", "D", "age", 40);

        this.sqlgGraph.addVertex(T.label, "Dog", "name", "A", "age", 10);
        this.sqlgGraph.addVertex(T.label, "Dog", "name", "B", "age", 200);
        this.sqlgGraph.addVertex(T.label, "Dog", "name", "C", "age", 30);
        this.sqlgGraph.addVertex(T.label, "Dog", "name", "D", "age", 40);

        this.sqlgGraph.tx().commit();

        DefaultTraversal&lt;Vertex, Map&lt;String, Integer&gt;&gt; traversal = (DefaultTraversal) this.sqlgGraph.traversal().V().&lt;String, Integer&gt;group().by(T.label).by(__.values("age").max());
        printTraversalForm(traversal);

        Map&lt;String, Integer&gt; result = traversal.next();
        Assert.assertFalse(traversal.hasNext());
        Assert.assertEquals(2, result.size());
        Assert.assertTrue(result.containsKey("Person"));
        Assert.assertTrue(result.containsKey("Dog"));
        Assert.assertEquals(100, result.get("Person"), 0);
        Assert.assertEquals(200, result.get("Dog"), 0);
    }</code></pre>
</div>
</div>
<div id="anchor-before-optimization-groupbymax-step" class="listingblock">
<div class="title">Before optimization</div>
<div class="content">
<pre class="nowrap">[GraphStep(vertex,[]), GroupStep(label,[PropertiesStep([age],value), MaxGlobalStep]</pre>
</div>
</div>
<div id="anchor-after-optimization-groupbymax-step" class="listingblock">
<div class="title">After optimization</div>
<div class="content">
<pre class="nowrap">[SqlgGraphStep(vertex,[])@[sqlgPathTempFakeLabel], SqlgGroupStep]</pre>
</div>
</div>
<div class="listingblock">
<div class="title">sql</div>
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-sql hljs" data-lang="sql">SELECT
	MAX("public"."V_Person"."age") AS "alias1"
FROM
	"public"."V_Person"

SELECT
	MAX("public"."V_Dog"."age") AS "alias1"
FROM
	"public"."V_Dog"</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-java hljs" data-lang="java">@Test
public void testGroupOverTwoPropertiesWithValues() {
    this.sqlgGraph.addVertex(T.label, "Person", "name", "A", "surname", "C", "age", 1);
    this.sqlgGraph.addVertex(T.label, "Person", "name", "B", "surname", "D", "age", 2);
    this.sqlgGraph.addVertex(T.label, "Person", "name", "A", "surname", "C", "age", 3);
    this.sqlgGraph.addVertex(T.label, "Person", "name", "B", "surname", "E", "age", 4);
    this.sqlgGraph.addVertex(T.label, "Person", "name", "C", "surname", "E", "age", 5);
    this.sqlgGraph.tx().commit();

    DefaultTraversal&lt;Vertex, Map&lt;List&lt;String&gt;, Integer&gt;&gt; traversal = (DefaultTraversal) this.sqlgGraph.traversal().V().hasLabel("Person")
            .&lt;List&lt;String&gt;, Integer&gt;group()
            .by(__.values("name", "surname").fold())
            .by(__.values("age").max());

    printTraversalForm(traversal);

    Map&lt;List&lt;String&gt;, Integer&gt; result = traversal.next();
    Assert.assertTrue(result.containsKey(Arrays.asList("A", "C")) || result.containsKey(Arrays.asList("C", "A")));
    Assert.assertTrue(result.containsKey(Arrays.asList("B", "D")) || result.containsKey(Arrays.asList("D", "B")));
    Assert.assertTrue(result.containsKey(Arrays.asList("B", "E")) || result.containsKey(Arrays.asList("E", "B")));
    Assert.assertTrue(result.containsKey(Arrays.asList("C", "E")) || result.containsKey(Arrays.asList("E", "C")));
    Assert.assertEquals(4, result.size());
    Assert.assertFalse(traversal.hasNext());

    if (result.containsKey(Arrays.asList("A", "C"))) {
        Assert.assertEquals(3, result.get(Arrays.asList("A", "C")), 0);
    } else {
        Assert.assertEquals(3, result.get(Arrays.asList("C", "A")), 0);
    }
    if (result.containsKey(Arrays.asList("B", "D"))) {
        Assert.assertEquals(2, result.get(Arrays.asList("B", "D")), 0);
    } else {
        Assert.assertEquals(2, result.get(Arrays.asList("D", "B")), 0);
    }
    if (result.containsKey(Arrays.asList("B", "E"))) {
        Assert.assertEquals(4, result.get(Arrays.asList("B", "E")), 0);
    } else {
        Assert.assertEquals(4, result.get(Arrays.asList("E", "B")), 0);
    }
    if (result.containsKey(Arrays.asList("C", "E"))) {
        Assert.assertEquals(5, result.get(Arrays.asList("C", "E")), 0);
    } else {
        Assert.assertEquals(5, result.get(Arrays.asList("E", "C")), 0);
    }
}</code></pre>
</div>
</div>
<div id="anchor-before-optimization-groupbymax2-step" class="listingblock">
<div class="title">Before optimization</div>
<div class="content">
<pre class="nowrap">[GraphStep(vertex,[]), HasStep([~label.eq(Person)]), GroupStep([PropertiesStep([name, surname],value), FoldStep],[PropertiesStep([age],value), MaxGlobalStep])]</pre>
</div>
</div>
<div id="anchor-after-optimization-groupbymax2-step" class="listingblock">
<div class="title">After optimization</div>
<div class="content">
<pre class="nowrap">[SqlgGraphStep(vertex,[])@[sqlgPathTempFakeLabel], SqlgGroupStep]</pre>
</div>
</div>
<div class="listingblock">
<div class="title">sql</div>
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-sql hljs" data-lang="sql">SELECT
	"public"."V_Person"."surname" AS "alias1",
	"public"."V_Person"."name" AS "alias2",
	MAX("public"."V_Person"."age") AS "alias3"
FROM
	"public"."V_Person"
GROUP BY
	"public"."V_Person"."name",
	"public"."V_Person"."surname"</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_group_by_and_sum_step">Group By and Sum Step</h5>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-java hljs" data-lang="java">@Test
public void testGroupOverOnePropertySum() {
    this.sqlgGraph.addVertex(T.label, "Person", "name", "A", "age", 1);
    this.sqlgGraph.addVertex(T.label, "Person", "name", "B", "age", 2);
    this.sqlgGraph.addVertex(T.label, "Person", "name", "A", "age", 3);
    this.sqlgGraph.addVertex(T.label, "Person", "name", "B", "age", 4);
    this.sqlgGraph.tx().commit();

    DefaultTraversal&lt;Vertex, Map&lt;String, Long&gt;&gt; traversal = (DefaultTraversal) sqlgGraph.traversal()
            .V().hasLabel("Person")
            .&lt;String, Long&gt;group().by("name").by(__.values("age").sum());
    printTraversalForm(traversal);
    Map&lt;String, Long&gt; result = traversal.next();
    Assert.assertFalse(traversal.hasNext());
    Assert.assertTrue(result.containsKey("A"));
    Assert.assertTrue(result.containsKey("B"));
    Assert.assertEquals(4, result.get("A"), 0L);
    Assert.assertEquals(6, result.get("B"), 0L);
}</code></pre>
</div>
</div>
<div id="anchor-before-optimization-groupbysum-step" class="listingblock">
<div class="title">Before optimization</div>
<div class="content">
<pre class="nowrap">[GraphStep(vertex,[]), HasStep([~label.eq(Person)]), GroupStep(value(name),[PropertiesStep([age],value), SumGlobalStep])]</pre>
</div>
</div>
<div id="anchor-after-optimization-groupbysum-step" class="listingblock">
<div class="title">After optimization</div>
<div class="content">
<pre class="nowrap">[SqlgGraphStep(vertex,[])@[sqlgPathTempFakeLabel], SqlgGroupStep]</pre>
</div>
</div>
<div class="listingblock">
<div class="title">sql</div>
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-sql hljs" data-lang="sql">SELECT
	"public"."V_Person"."name" AS "alias1",
	SUM("public"."V_Person"."age") AS "alias2"
FROM
	"public"."V_Person"
GROUP BY
	"public"."V_Person"."name"</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_group_by_and_mean_step">Group By and Mean Step</h5>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-java hljs" data-lang="java">@Test
public void testGroupOverOnePropertyMean() {
    this.sqlgGraph.addVertex(T.label, "Person", "name", "A", "age", 1);
    this.sqlgGraph.addVertex(T.label, "Person", "name", "B", "age", 2);
    this.sqlgGraph.addVertex(T.label, "Person", "name", "A", "age", 3);
    this.sqlgGraph.addVertex(T.label, "Person", "name", "B", "age", 4);
    this.sqlgGraph.tx().commit();

    DefaultTraversal&lt;Vertex, Map&lt;String, Double&gt;&gt; traversal = (DefaultTraversal) sqlgGraph.traversal()
            .V().hasLabel("Person")
            .&lt;String, Double&gt;group().by("name").by(__.values("age").mean());
    printTraversalForm(traversal);
    Map&lt;String, Double&gt; result = traversal.next();
    Assert.assertFalse(traversal.hasNext());
    Assert.assertTrue(result.containsKey("A"));
    Assert.assertTrue(result.containsKey("B"));
    Assert.assertEquals(2.0, result.get("A"), 0D);
    Assert.assertEquals(3.0, result.get("B"), 0D);
}</code></pre>
</div>
</div>
<div id="anchor-before-optimization-groupbymean-step" class="listingblock">
<div class="title">Before optimization</div>
<div class="content">
<pre class="nowrap">[GraphStep(vertex,[]), HasStep([~label.eq(Person)]), GroupStep(value(name),[PropertiesStep([age],value), MeanGlobalStep])]</pre>
</div>
</div>
<div id="anchor-after-optimization-groupbymean-step" class="listingblock">
<div class="title">After optimization</div>
<div class="content">
<pre class="nowrap">[SqlgGraphStep(vertex,[])@[sqlgPathTempFakeLabel], SqlgGroupStep]</pre>
</div>
</div>
<div class="listingblock">
<div class="title">sql</div>
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-sql hljs" data-lang="sql">SELECT
	"public"."V_Person"."name" AS "alias1",
	AVG("public"."V_Person"."age") AS "alias2", COUNT(1) AS "alias2_weight"
FROM
	"public"."V_Person"
GROUP BY
	"public"."V_Person"."name"</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_group_by_and_count_step">Group By and Count Step</h5>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-java hljs" data-lang="java">@Test
public void testGroupByCount() {
    this.sqlgGraph.addVertex(T.label, "A", "name", "a", "age", 1);
    this.sqlgGraph.addVertex(T.label, "A", "name", "a", "age", 2);
    this.sqlgGraph.addVertex(T.label, "A", "name", "b", "age", 3);
    this.sqlgGraph.tx().commit();
    DefaultTraversal&lt;Vertex, Map&lt;Object, Long&gt;&gt; traversal = (DefaultTraversal&lt;Vertex, Map&lt;Object, Long&gt;&gt;) this.sqlgGraph.traversal().V().hasLabel("A")
            .&lt;Object, Long&gt;group().by("name").by(__.count());
    List&lt;Map&lt;Object, Long&gt;&gt; result = traversal.toList();
    Assert.assertEquals(1, result.size());
    Assert.assertTrue(result.get(0).containsKey("a"));
    Assert.assertTrue(result.get(0).containsKey("b"));
    Assert.assertEquals(2L, result.get(0).get("a"), 0);
    Assert.assertEquals(1L, result.get(0).get("b"), 0);
}</code></pre>
</div>
</div>
<div id="anchor-before-optimization-groupbycount-step" class="listingblock">
<div class="title">Before optimization</div>
<div class="content">
<pre class="nowrap">[GraphStep(vertex,[]), HasStep([~label.eq(A)]), GroupStep(value(name),[CountGlobalStep])]</pre>
</div>
</div>
<div id="anchor-after-optimization-groupbycount-step" class="listingblock">
<div class="title">After optimization</div>
<div class="content">
<pre class="nowrap">[SqlgGraphStep(vertex,[])@[sqlgPathTempFakeLabel], SqlgGroupStep]</pre>
</div>
</div>
<div class="listingblock">
<div class="title">sql</div>
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-sql hljs" data-lang="sql">SELECT
	COUNT(1) AS "count",
	"public"."V_A"."name" AS "alias1"
FROM
	"public"."V_A"
GROUP BY
	"public"."V_A"."name"</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-java hljs" data-lang="java">@Test
public void testDuplicatePathGroupCountQuery() {
    Vertex a1 = this.sqlgGraph.addVertex(T.label, "A", "name", "a1", "age", 1);
    Vertex b1 = this.sqlgGraph.addVertex(T.label, "B", "name", "b", "age", 1);
    Vertex b2 = this.sqlgGraph.addVertex(T.label, "B", "name", "b", "age", 2);
    Vertex b3 = this.sqlgGraph.addVertex(T.label, "B", "name", "b", "age", 3);
    Vertex b4 = this.sqlgGraph.addVertex(T.label, "B", "name", "b", "age", 3);
    Vertex c1 = this.sqlgGraph.addVertex(T.label, "C", "name", "b", "age", 1);
    Vertex c2 = this.sqlgGraph.addVertex(T.label, "C", "name", "b", "age", 2);
    Vertex c3 = this.sqlgGraph.addVertex(T.label, "C", "name", "b", "age", 3);
    a1.addEdge("ab", b1);
    a1.addEdge("ab", b2);
    a1.addEdge("ab", b3);
    a1.addEdge("ab", b4);
    a1.addEdge("ac", c1);
    a1.addEdge("ac", c2);
    a1.addEdge("ac", c3);
    this.sqlgGraph.tx().commit();

    DefaultTraversal&lt;Vertex, Map&lt;String, Long&gt;&gt; traversal = (DefaultTraversal) this.sqlgGraph.traversal().V(a1).out("ab", "ac").group().by("name").by(__.count());
    Assert.assertEquals(2, traversal.getSteps().size());
    Assert.assertTrue(traversal.getSteps().get(0) instanceof SqlgGraphStep);
    Assert.assertTrue(traversal.getSteps().get(1) instanceof SqlgGroupStep);
    Map&lt;String, Long&gt; result = traversal.next();
    Assert.assertEquals(1, result.size());
    Assert.assertTrue(result.containsKey("b"));
    Assert.assertEquals(7, result.get("b"), 0);
    Assert.assertFalse(traversal.hasNext());
}</code></pre>
</div>
</div>
<div id="anchor-before-optimization-groupbycount2-step" class="listingblock">
<div class="title">Before optimization</div>
<div class="content">
<pre class="nowrap">[GraphStep(vertex,[v[public.A:::1]]), VertexStep(OUT,[ab, ac],vertex), GroupStep(value(name),[CountGlobalStep])]</pre>
</div>
</div>
<div id="anchor-after-optimization-groupbycount2-step" class="listingblock">
<div class="title">After optimization</div>
<div class="content">
<pre class="nowrap">[SqlgGraphStep(vertex,[])@[sqlgPathTempFakeLabel], SqlgGroupStep]</pre>
</div>
</div>
<div class="listingblock">
<div class="title">sql</div>
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-sql hljs" data-lang="sql">SELECT
	COUNT(1) AS "count",
	"public"."V_C"."name" AS "alias1"
FROM
	"public"."V_A" INNER JOIN
	"public"."E_ac" ON "public"."V_A"."ID" = "public"."E_ac"."public.A__O" INNER JOIN
	"public"."V_C" ON "public"."E_ac"."public.C__I" = "public"."V_C"."ID"
WHERE
	( "public"."V_A"."ID" = ?)
GROUP BY
	"public"."V_C"."name";

SELECT
	COUNT(1) AS "count",
	"public"."V_B"."name" AS "alias1"
FROM
	"public"."V_A" INNER JOIN
	"public"."E_ab" ON "public"."V_A"."ID" = "public"."E_ab"."public.A__O" INNER JOIN
	"public"."V_B" ON "public"."E_ab"."public.B__I" = "public"."V_B"."ID"
WHERE
	( "public"."V_A"."ID" = ?)
GROUP BY
	"public"."V_B"."name";</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_optimization_strategy_2">10.2. Optimization (strategy 2)</h3>
<div class="paragraph">
<p>The following steps are optimized.</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#_vertex_step">Vertex Step</a></p>
</li>
<li>
<p><a href="#_repeat_step">Repeat Step</a></p>
</li>
<li>
<p><a href="#_optional_step">Optional Step</a></p>
</li>
<li>
<p><a href="#_choose_step">Choose Step</a></p>
</li>
<li>
<p><a href="#_local_step">Local Step</a></p>
</li>
<li>
<p><a href="#_and_step">And Step</a></p>
</li>
<li>
<p><a href="#_or_step">Or Step</a></p>
</li>
<li>
<p><a href="#_not_step">Not Step</a></p>
</li>
<li>
<p><a href="#_where_step">Where Step</a></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The combined step will then in turn generate the sql statements to retrieve the data.
It attempts to retrieve the data in as few distinct sql statements as possible.</p>
</div>
<div class="sect3">
<h4 id="_vertex_step_2">10.2.1. Vertex Step</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-java hljs" data-lang="java">@Test
public void testStrategy2VertexStep() {
    Vertex a1 = this.sqlgGraph.addVertex(T.label, "A", "name", "a1");
    Vertex a2 = this.sqlgGraph.addVertex(T.label, "A", "name", "a2");
    Vertex a3 = this.sqlgGraph.addVertex(T.label, "A", "name", "a3");
    Vertex b1 = this.sqlgGraph.addVertex(T.label, "B", "name", "b1");
    Vertex b2 = this.sqlgGraph.addVertex(T.label, "B", "name", "b2");
    Vertex b3 = this.sqlgGraph.addVertex(T.label, "B", "name", "b3");
    a1.addEdge("ab", b1);
    a2.addEdge("ab", b2);
    a3.addEdge("ab", b3);
    this.sqlgGraph.tx().commit();

    Traversal&lt;Vertex, String&gt; t = this.sqlgGraph.traversal()
            .V().hasLabel("A")
            .limit(2)
            .out()
            .values("name");
    printTraversalForm(t);
    List&lt;String&gt; result = t.toList();
    for (String name : result) {
        System.out.println(name);
    }
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">output</div>
<div class="content">
<pre class="nowrap">b1
b2</pre>
</div>
</div>
<div class="listingblock">
<div class="title">Before optimization</div>
<div class="content">
<pre class="nowrap">[GraphStep(vertex,[]), HasStep([~label.eq(A)]), RangeGlobalStep(0,2), VertexStep(OUT,vertex), PropertiesStep([name],value)]</pre>
</div>
</div>
<div id="anchor-after-optimization-vertex-step" class="listingblock">
<div class="title">After optimization</div>
<div class="content">
<pre class="nowrap">[SqlgGraphStep(vertex,[])@[sqlgPathOrderRangeLabel], SqlgVertexStep@[sqlgPathFakeLabel], PropertiesStep([name],value)]</pre>
</div>
</div>
<div class="paragraph">
<p><a href="#anchor-after-optimization-vertex-step">after optimization</a> shows that there is a <a href="apidocs//org/umlg/sqlg/step/SqlgVertexStep.html"><code>SqlgVertexStep</code></a>
after the <code>SqlgGraphStep</code>. The <code>SqlgVertexStep</code> will barrier the incoming <code>A</code> s and execute the next traversal for all
the incoming elements in one <code>sql</code> statement.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-sql hljs" data-lang="sql">SELECT
	"public"."V_A"."ID" AS "alias1",
	"public"."V_A"."name" AS "alias2"
FROM
	"public"."V_A"
LIMIT 2 OFFSET 0 <b class="conum">(1)</b>

SELECT
	"index" as "index",
	"public"."V_B"."ID" AS "alias1",
	"public"."V_B"."name" AS "alias2"
FROM
	"public"."V_A" INNER JOIN
	"public"."E_ab" ON "public"."V_A"."ID" = "public"."E_ab"."public.A__O" INNER JOIN
	"public"."V_B" ON "public"."E_ab"."public.B__I" = "public"."V_B"."ID" INNER JOIN
	(VALUES(1, 1),(2, 2)) AS tmp ("tmpId", "index") ON "public"."V_A"."ID" = tmp."tmpId"
ORDER BY
	"index" <b class="conum">(2)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Get all the <code>A</code> s.</p>
</li>
<li>
<p>For all the previously fetched <code>A</code> s get the <code>B</code> s.</p>
</li>
</ol>
</div>
</div>
<div class="sect3">
<h4 id="_repeat_step_2">10.2.2. Repeat Step</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-java hljs" data-lang="java">@Test
public void testStrategy2RepeatStep() {
    Vertex a1 = this.sqlgGraph.addVertex(T.label, "A", "name", "a1");
    Vertex a2 = this.sqlgGraph.addVertex(T.label, "A", "name", "a2");
    Vertex b1 = this.sqlgGraph.addVertex(T.label, "B", "name", "b1");
    Vertex b2 = this.sqlgGraph.addVertex(T.label, "B", "name", "b2");
    Vertex b3 = this.sqlgGraph.addVertex(T.label, "B", "name", "b3");
    Vertex b4 = this.sqlgGraph.addVertex(T.label, "B", "name", "b4");
    Vertex b5 = this.sqlgGraph.addVertex(T.label, "B", "name", "b5");
    Vertex b6 = this.sqlgGraph.addVertex(T.label, "B", "name", "b6");
    Vertex c1 = this.sqlgGraph.addVertex(T.label, "C", "name", "c1");
    Vertex c2 = this.sqlgGraph.addVertex(T.label, "C", "name", "c2");
    Vertex c3 = this.sqlgGraph.addVertex(T.label, "C", "name", "c3");
    Vertex c4 = this.sqlgGraph.addVertex(T.label, "C", "name", "c4");
    Vertex x = this.sqlgGraph.addVertex(T.label, "X", "name", "hallo");
    a1.addEdge("ab", b1);
    a1.addEdge("ab", b2);
    a1.addEdge("ab", b3);
    a2.addEdge("ab", b4);
    a2.addEdge("ab", b5);
    a2.addEdge("ab", b6);

    b1.addEdge("bx", x);

    b4.addEdge("bc", c1);
    b4.addEdge("bc", c2);
    b4.addEdge("bc", c3);

    c1.addEdge("cx", x);

    this.sqlgGraph.tx().commit();

    Traversal&lt;Vertex, String&gt; t = this.sqlgGraph.traversal()
            .V().hasLabel("A")
            .repeat(__.out())
            .until(__.out().has("name", "hallo"))
            .values("name");
    printTraversalForm(t);

    List&lt;String&gt; names = t.toList();
    for (String name: names) {
        System.out.println(name);
    }
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Before optimization</div>
<div class="content">
<pre class="nowrap">[GraphStep(vertex,[]), HasStep([~label.eq(A)]), RepeatStep([VertexStep(OUT,vertex), RepeatEndStep],until([VertexStep(OUT,vertex), HasStep([name.eq(hallo)])]),emit(false)), PropertiesStep([name],value)]</pre>
</div>
</div>
<div id="anchor-after-optimization-repeat-step-strategy1" class="listingblock">
<div class="title">After optimization</div>
<div class="content">
<pre class="nowrap">post-strategy:[SqlgGraphStep(vertex,[])@[sqlgPathFakeLabel], SqlgRepeatStepBarrier([SqlgVertexStep@[sqlgPathFakeLabel], SqlgRepeatEndStepBarrier],until([SqlgVertexStep@[sqlgPathFakeLabel]]),emit(false)), PropertiesStep([name],value)]</pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-sql hljs" data-lang="sql">SELECT
	"public"."V_A"."ID" AS "alias1",
	"public"."V_A"."name" AS "alias2"
FROM
	"public"."V_A" <b class="conum">(1)</b>

SELECT
	"index" as "index",
	"public"."V_B"."ID" AS "alias1",
	"public"."V_B"."name" AS "alias2"
FROM
	"public"."V_A" INNER JOIN
	"public"."E_ab" ON "public"."V_A"."ID" = "public"."E_ab"."public.A__O" INNER JOIN
	"public"."V_B" ON "public"."E_ab"."public.B__I" = "public"."V_B"."ID" INNER JOIN
	(VALUES(1, 1),(2, 2)) AS tmp ("tmpId", "index") ON "public"."V_A"."ID" = tmp."tmpId"
ORDER BY
	"index" <b class="conum">(2)</b>

SELECT
	"index" as "index",
	"public"."V_X"."ID" AS "alias1",
	"public"."V_X"."name" AS "alias2"
FROM
	"public"."V_B" INNER JOIN
	"public"."E_bx" ON "public"."V_B"."ID" = "public"."E_bx"."public.B__O" INNER JOIN
	"public"."V_X" ON "public"."E_bx"."public.X__I" = "public"."V_X"."ID" INNER JOIN
	(VALUES(3, 1),(2, 2),(1, 3),(6, 4),(5, 5),(4, 6)) AS tmp ("tmpId", "index") ON "public"."V_B"."ID" = tmp."tmpId"
WHERE
	( "public"."V_X"."name" = ?)
ORDER BY
	"index" <b class="conum">(3)</b>

SELECT
	"index" as "index",
	"public"."V_C"."ID" AS "alias1",
	"public"."V_C"."name" AS "alias2"
FROM
	"public"."V_B" INNER JOIN
	"public"."E_bc" ON "public"."V_B"."ID" = "public"."E_bc"."public.B__O" INNER JOIN
	"public"."V_C" ON "public"."E_bc"."public.C__I" = "public"."V_C"."ID" INNER JOIN
	(VALUES(3, 1),(2, 2),(1, 3),(6, 4),(5, 5),(4, 6)) AS tmp ("tmpId", "index") ON "public"."V_B"."ID" = tmp."tmpId"
WHERE
	( "public"."V_C"."name" = ?)
ORDER BY
	"index" <b class="conum">(4)</b>

SELECT
	"index" as "index",
	"public"."V_X"."ID" AS "alias1",
	"public"."V_X"."name" AS "alias2"
FROM
	"public"."V_B" INNER JOIN
	"public"."E_bx" ON "public"."V_B"."ID" = "public"."E_bx"."public.B__O" INNER JOIN
	"public"."V_X" ON "public"."E_bx"."public.X__I" = "public"."V_X"."ID" INNER JOIN
	(VALUES(3, 3),(2, 4),(6, 5),(5, 6),(4, 7)) AS tmp ("tmpId", "index") ON "public"."V_B"."ID" = tmp."tmpId"
ORDER BY
	"index" <b class="conum">(5)</b>

SELECT
	"index" as "index",
	"public"."V_C"."ID" AS "alias1",
	"public"."V_C"."name" AS "alias2"
FROM
	"public"."V_B" INNER JOIN
	"public"."E_bc" ON "public"."V_B"."ID" = "public"."E_bc"."public.B__O" INNER JOIN
	"public"."V_C" ON "public"."E_bc"."public.C__I" = "public"."V_C"."ID" INNER JOIN
	(VALUES(3, 3),(2, 4),(6, 5),(5, 6),(4, 7)) AS tmp ("tmpId", "index") ON "public"."V_B"."ID" = tmp."tmpId"
ORDER BY
	"index" <b class="conum">(6)</b>

SELECT
	"index" as "index",
	"public"."V_X"."ID" AS "alias1",
	"public"."V_X"."name" AS "alias2"
FROM
	"public"."V_C" INNER JOIN
	"public"."E_cx" ON "public"."V_C"."ID" = "public"."E_cx"."public.C__O" INNER JOIN
	"public"."V_X" ON "public"."E_cx"."public.X__I" = "public"."V_X"."ID" INNER JOIN
	(VALUES(3, 7),(2, 8),(1, 9)) AS tmp ("tmpId", "index") ON "public"."V_C"."ID" = tmp."tmpId"
WHERE
	( "public"."V_X"."name" = ?)
ORDER BY
	"index" <b class="conum">(7)</b>

SELECT
	"index" as "index",
	"public"."V_X"."ID" AS "alias1",
	"public"."V_X"."name" AS "alias2"
FROM
	"public"."V_C" INNER JOIN
	"public"."E_cx" ON "public"."V_C"."ID" = "public"."E_cx"."public.C__O" INNER JOIN
	"public"."V_X" ON "public"."E_cx"."public.X__I" = "public"."V_X"."ID" INNER JOIN
	(VALUES(3, 8),(2, 9)) AS tmp ("tmpId", "index") ON "public"."V_C"."ID" = tmp."tmpId"
ORDER BY
	"index" <b class="conum">(8)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Get all the <code>A</code> s.</p>
</li>
<li>
<p>Get all the <code>B</code> s for the incoming <code>A</code> s. This represent the first <code>out</code> iteration of the <code>repeat</code>.</p>
</li>
<li>
<p>The <code>until</code> traversal executed for all the incoming <code>B</code> s going out to <code>X</code>.</p>
</li>
<li>
<p>The <code>until</code> traversal executed for all the incoming <code>B</code> s going out to <code>C</code>.</p>
</li>
<li>
<p>Get all the <code>X</code> for the incoming <code>B</code> s. This is the second <code>out</code> iteration of the <code>repeat</code>.</p>
</li>
<li>
<p>Get all the <code>C</code> for the incoming <code>B</code> s. This is the second <code>out</code> iteration of the <code>repeat</code>.</p>
</li>
<li>
<p>The <code>until</code> traversal executed for all the incoming <code>C</code> s going out to <code>X</code>.</p>
</li>
<li>
<p>Get all the <code>X</code> for the incoming <code>C</code> s. This is the third <code>out</code> iteration of the <code>repeat</code>.</p>
</li>
</ol>
</div>
<div class="listingblock">
<div class="title">output</div>
<div class="content">
<pre>b1
c1</pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_optional_step_2">10.2.3. Optional Step</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-java hljs" data-lang="java">@Test
public void testStrategy2OptionalStep() {
    Vertex a1 = this.sqlgGraph.addVertex(T.label, "A", "name", "a1");
    Vertex a2 = this.sqlgGraph.addVertex(T.label, "A", "name", "a2");
    Vertex b1 = this.sqlgGraph.addVertex(T.label, "B", "name", "b1");
    Vertex b2 = this.sqlgGraph.addVertex(T.label, "B", "name", "b2");
    Vertex c1 = this.sqlgGraph.addVertex(T.label, "C", "name", "c1");
    a1.addEdge("ab", b1);
    a1.addEdge("ab", b2);
    b1.addEdge("bc", c1);


    this.sqlgGraph.tx().commit();

    Traversal&lt;Vertex, String&gt; traversal = this.sqlgGraph.traversal()
            .V().hasLabel("A")
            .optional(
                __.repeat(
                        __.out()
                ).times(2)
            )
            .values("name");
    printTraversalForm(traversal);
    List&lt;String&gt; names = traversal.toList();
    for (String name : names) {
        System.out.println(name);
    }
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Before optimization</div>
<div class="content">
<pre class="nowrap">[GraphStep(vertex,[]), HasStep([~label.eq(A)]), OptionalStep([RepeatStep([VertexStep(OUT,vertex), RepeatEndStep],until(loops(2)),emit(false))]), PropertiesStep([name],value)]</pre>
</div>
</div>
<div id="anchor-after-optimization-repeat-step-strategy2" class="listingblock">
<div class="title">After optimization</div>
<div class="content">
<pre class="nowrap">[SqlgGraphStep(vertex,[])@[sqlgPathFakeLabel], SqlgOptionalStepBarrier([SqlgRepeatStepBarrier([SqlgVertexStep@[sqlgPathFakeLabel], SqlgRepeatEndStepBarrier],until(loops(2)),emit(false))]), PropertiesStep([name],value)]</pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-sql hljs" data-lang="sql">SELECT
	"public"."V_A"."ID" AS "alias1",
	"public"."V_A"."name" AS "alias2"
FROM
	"public"."V_A"

SELECT
	"index" as "index",
	"public"."V_B"."ID" AS "alias1",
	"public"."V_B"."name" AS "alias2"
FROM
	"public"."V_A" INNER JOIN
	"public"."E_ab" ON "public"."V_A"."ID" = "public"."E_ab"."public.A__O" INNER JOIN
	"public"."V_B" ON "public"."E_ab"."public.B__I" = "public"."V_B"."ID" INNER JOIN
	(VALUES(1, 1),(2, 2)) AS tmp ("tmpId", "index") ON "public"."V_A"."ID" = tmp."tmpId"
ORDER BY
	"index"

SELECT
	3 as "index",
	"public"."V_C"."ID" AS "alias1",
	"public"."V_C"."name" AS "alias2"
FROM
	"public"."V_B" INNER JOIN
	"public"."E_bc" ON "public"."V_B"."ID" = "public"."E_bc"."public.B__O" INNER JOIN
	"public"."V_C" ON "public"."E_bc"."public.C__I" = "public"."V_C"."ID"
WHERE
	"public"."V_B"."ID" = 2
ORDER BY
	"index"

SELECT
	4 as "index",
	"public"."V_C"."ID" AS "alias1",
	"public"."V_C"."name" AS "alias2"
FROM
	"public"."V_B" INNER JOIN
	"public"."E_bc" ON "public"."V_B"."ID" = "public"."E_bc"."public.B__O" INNER JOIN
	"public"."V_C" ON "public"."E_bc"."public.C__I" = "public"."V_C"."ID"
WHERE
	"public"."V_B"."ID" = 1
ORDER BY
	"index"</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">output</div>
<div class="content">
<pre>a2
c1</pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_choose_step_2">10.2.4. Choose Step</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-java hljs" data-lang="java">@Test
public void testStrategy2ChooseStep() {
    Vertex a1 = this.sqlgGraph.addVertex(T.label, "A", "name", "a1");
    Vertex a2 = this.sqlgGraph.addVertex(T.label, "A", "name", "a2");
    Vertex b1 = this.sqlgGraph.addVertex(T.label, "B", "name", "a3");
    Vertex b2 = this.sqlgGraph.addVertex(T.label, "B", "name", "a4");
    a1.addEdge("ab", b1);
    a1.addEdge("ab", b2);
    this.sqlgGraph.tx().commit();

    Traversal&lt;Vertex, String&gt; traversal = this.sqlgGraph.traversal()
            .V()
            .hasLabel("A")
            .choose(
                    v -&gt; v.label().equals("A"),
                    __.out(),
                    __.in()
            ).values("name");
    printTraversalForm(traversal);

    List&lt;String&gt; names = traversal.toList();
    for (String name : names) {
        System.out.println(name);
    }
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Before optimization</div>
<div class="content">
<pre class="nowrap"></pre>
</div>
</div>
<div id="anchor-after-optimization-choose-step-strategy2" class="listingblock">
<div class="title">After optimization</div>
<div class="content">
<pre class="nowrap">[GraphStep(vertex,[]), HasStep([~label.eq(A)]), ChooseStep([LambdaFilterStep(lambda), HasNextStep],{false=[[VertexStep(IN,vertex), EndStep]], true=[[VertexStep(OUT,vertex), EndStep]]}), PropertiesStep([name],value)]</pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-sql hljs" data-lang="sql">[SqlgGraphStep(vertex,[])@[sqlgPathFakeLabel], SqlgChooseStepBarrier([LambdaFilterStep(lambda)],{false=[[SqlgVertexStep, EndStep]], true=[[SqlgVertexStep@[~gremlin.incidentToAdjacent], EndStep]]}), PropertiesStep([name],value)]</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">output</div>
<div class="content">
<pre>a4
a3</pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_local_step">10.2.5. Local Step</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-java hljs" data-lang="java">@Test
public void testStrategy2LocalStep() {
    Vertex a1 = this.sqlgGraph.addVertex(T.label, "A", "name", "a1");
    Vertex b1 = this.sqlgGraph.addVertex(T.label, "B", "name", "b1");
    Vertex b2 = this.sqlgGraph.addVertex(T.label, "B", "name", "b2");
    Vertex b3 = this.sqlgGraph.addVertex(T.label, "B", "name", "b3");
    Vertex c11 = this.sqlgGraph.addVertex(T.label, "C", "name", "c11");
    Vertex c12 = this.sqlgGraph.addVertex(T.label, "C", "name", "c12");
    Vertex c13 = this.sqlgGraph.addVertex(T.label, "C", "name", "c13");
    Vertex c21 = this.sqlgGraph.addVertex(T.label, "C", "name", "c21");
    Vertex c22 = this.sqlgGraph.addVertex(T.label, "C", "name", "c22");
    Vertex c23 = this.sqlgGraph.addVertex(T.label, "C", "name", "c23");
    Vertex c31 = this.sqlgGraph.addVertex(T.label, "C", "name", "c31");
    Vertex c32 = this.sqlgGraph.addVertex(T.label, "C", "name", "c32");
    Vertex c33 = this.sqlgGraph.addVertex(T.label, "C", "name", "c33");
    a1.addEdge("ab", b1);
    a1.addEdge("ab", b2);
    a1.addEdge("ab", b3);
    b1.addEdge("bc", c11);
    b1.addEdge("bc", c12);
    b1.addEdge("bc", c13);
    b2.addEdge("bc", c21);
    b2.addEdge("bc", c22);
    b2.addEdge("bc", c23);
    b3.addEdge("bc", c31);
    b3.addEdge("bc", c32);
    b3.addEdge("bc", c33);
    this.sqlgGraph.tx().commit();

    Traversal&lt;Vertex, String&gt; traversal = this.sqlgGraph.traversal()
            .V(a1)
            .local(
                    __.out().limit(1).out()
            ).values("name");
    printTraversalForm(traversal);

    List&lt;String&gt; names = traversal.toList();
    for (String name : names) {
        System.out.println(name);
    }
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Before optimization</div>
<div class="content">
<pre class="nowrap">[GraphStep(vertex,[v[public.A:::1]]), LocalStep([VertexStep(OUT,vertex), RangeGlobalStep(0,1), VertexStep(OUT,vertex)]), PropertiesStep([name],value)]</pre>
</div>
</div>
<div id="anchor-after-optimization-local-step-strategy2" class="listingblock">
<div class="title">After optimization</div>
<div class="content">
<pre class="nowrap">[SqlgGraphStep(vertex,[])@[sqlgPathFakeLabel], LocalStep([SqlgVertexStep@[sqlgPathOrderRangeLabel], SqlgVertexStep@[sqlgPathFakeLabel]]), PropertiesStep([name],value)]</pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-sql hljs" data-lang="sql"></code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">output</div>
<div class="content">
<pre>SELECT
	"public"."V_A"."ID" AS "alias1",
	"public"."V_A"."name" AS "alias2"
FROM
	"public"."V_A"
WHERE
	( "public"."V_A"."ID" = ?)

SELECT
	1 as "index",
	"public"."V_B"."ID" AS "alias1",
	"public"."V_B"."name" AS "alias2"
FROM
	"public"."V_A" INNER JOIN
	"public"."E_ab" ON "public"."V_A"."ID" = "public"."E_ab"."public.A__O" INNER JOIN
	"public"."V_B" ON "public"."E_ab"."public.B__I" = "public"."V_B"."ID"
WHERE
	"public"."V_A"."ID" = 1
ORDER BY
	"index"
LIMIT 1 OFFSET 0 <b class="conum">(1)</b>

SELECT
	1 as "index",
	"public"."V_C"."ID" AS "alias1",
	"public"."V_C"."name" AS "alias2"
FROM
	"public"."V_B" INNER JOIN
	"public"."E_bc" ON "public"."V_B"."ID" = "public"."E_bc"."public.B__O" INNER JOIN
	"public"."V_C" ON "public"."E_bc"."public.C__I" = "public"."V_C"."ID"
WHERE
	"public"."V_B"."ID" = 1
ORDER BY
	"index"</pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>In this case the query is simple enough for the <code>LIMIT</code> to be executed on the database.</p>
</li>
</ol>
</div>
</div>
<div class="sect3">
<h4 id="_and_step_2">10.2.6. And Step</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-java hljs" data-lang="java">@Test
public void testStrategy2AndStep() {
    Vertex a1 = this.sqlgGraph.addVertex(T.label, "A", "name", "a1");
    Vertex b1 = this.sqlgGraph.addVertex(T.label, "B", "name", "b1");
    a1.addEdge("ab", b1);
    a1.addEdge("abb", b1);
    Vertex a2 = this.sqlgGraph.addVertex(T.label, "A", "name", "a2");
    Vertex b2 = this.sqlgGraph.addVertex(T.label, "B", "name", "b2");
    a2.addEdge("abb", b2);
    Vertex a3 = this.sqlgGraph.addVertex(T.label, "A", "name", "a3");
    Vertex b3 = this.sqlgGraph.addVertex(T.label, "B", "name", "b3");
    a3.addEdge("abbb", b3);

    Traversal&lt;Vertex, String&gt; traversal = this.sqlgGraph.traversal().V().hasLabel("A").and(
            __.out("ab"),
            __.out("abb")
    ).values("name");
    printTraversalForm(traversal);

    List&lt;String&gt; names = traversal.toList();
    for (String name : names) {
        System.out.println(name);
    }
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Before optimization</div>
<div class="content">
<pre class="nowrap">[GraphStep(vertex,[]), HasStep([~label.eq(A)]), AndStep([[VertexStep(OUT,[ab],vertex)], [VertexStep(OUT,[abb],vertex)]]), PropertiesStep([name],value)]</pre>
</div>
</div>
<div id="anchor-after-optimization-and-step-strategy2" class="listingblock">
<div class="title">After optimization</div>
<div class="content">
<pre class="nowrap">[SqlgGraphStep(vertex,[])@[sqlgPathFakeLabel], SqlgAndStepBarrier([[SqlgVertexStep@[sqlgPathFakeLabel]], [SqlgVertexStep@[sqlgPathFakeLabel]]]), PropertiesStep([name],value)]</pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-sql hljs" data-lang="sql">SELECT
	"public"."V_A"."ID" AS "alias1",
	"public"."V_A"."name" AS "alias2"
FROM
	"public"."V_A"

SELECT
	"index" as "index",
	"public"."V_B"."ID" AS "alias1",
	"public"."V_B"."name" AS "alias2"
FROM
	"public"."V_A" INNER JOIN
	"public"."E_ab" ON "public"."V_A"."ID" = "public"."E_ab"."public.A__O" INNER JOIN
	"public"."V_B" ON "public"."E_ab"."public.B__I" = "public"."V_B"."ID" INNER JOIN
	(VALUES(1, 1),(2, 2),(3, 3)) AS tmp ("tmpId", "index") ON "public"."V_A"."ID" = tmp."tmpId"
ORDER BY
	"index"

SELECT
	"index" as "index",
	"public"."V_B"."ID" AS "alias1",
	"public"."V_B"."name" AS "alias2"
FROM
	"public"."V_A" INNER JOIN
	"public"."E_abb" ON "public"."V_A"."ID" = "public"."E_abb"."public.A__O" INNER JOIN
	"public"."V_B" ON "public"."E_abb"."public.B__I" = "public"."V_B"."ID" INNER JOIN
	(VALUES(1, 1),(2, 2),(3, 3)) AS tmp ("tmpId", "index") ON "public"."V_A"."ID" = tmp."tmpId"
ORDER BY
	"index"</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">output</div>
<div class="content">
<pre>a1</pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_or_step_2">10.2.7. Or Step</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-java hljs" data-lang="java">@Test
public void testStrategy2OrStep() {
    Vertex a1 = this.sqlgGraph.addVertex(T.label, "A", "name", "a1");
    Vertex b1 = this.sqlgGraph.addVertex(T.label, "B", "name", "b1");
    a1.addEdge("ab", b1);
    Vertex a2 = this.sqlgGraph.addVertex(T.label, "A", "name", "a2");
    Vertex b2 = this.sqlgGraph.addVertex(T.label, "B", "name", "b2");
    a2.addEdge("abb", b2);
    Vertex a3 = this.sqlgGraph.addVertex(T.label, "A", "name", "a3");
    Vertex b3 = this.sqlgGraph.addVertex(T.label, "B", "name", "b3");
    a3.addEdge("abbb", b3);
    Vertex a4 = this.sqlgGraph.addVertex(T.label, "A", "name", "a4");
    Vertex b4 = this.sqlgGraph.addVertex(T.label, "B", "name", "b4");
    a4.addEdge("abbbb", b4);


    Traversal&lt;Vertex, String&gt; traversal = this.sqlgGraph.traversal()
            .V().hasLabel("A")
            .or(
                    __.out("ab"),
                    __.out("abb"),
                    __.out("abbb")
            ).values("name");
    printTraversalForm(traversal);

    List&lt;String&gt; names = traversal.toList();
    for (String name : names) {
        System.out.println(name);
    }
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Before optimization</div>
<div class="content">
<pre class="nowrap">[GraphStep(vertex,[]), HasStep([~label.eq(A)]), OrStep([[VertexStep(OUT,[ab],vertex)], [VertexStep(OUT,[abb],vertex)], [VertexStep(OUT,[abbb],vertex)]]), PropertiesStep([name],value)]</pre>
</div>
</div>
<div id="anchor-after-optimization-or-step-strategy2" class="listingblock">
<div class="title">After optimization</div>
<div class="content">
<pre class="nowrap">[SqlgGraphStep(vertex,[])@[sqlgPathFakeLabel], SqlgOrStepBarrier([[SqlgVertexStep@[sqlgPathFakeLabel]], [SqlgVertexStep@[sqlgPathFakeLabel]], [SqlgVertexStep@[sqlgPathFakeLabel]]]), PropertiesStep([name],value)]</pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-sql hljs" data-lang="sql">SELECT
	"public"."V_A"."ID" AS "alias1",
	"public"."V_A"."name" AS "alias2"
FROM
	"public"."V_A"

SELECT
	"index" as "index",
	"public"."V_B"."ID" AS "alias1",
	"public"."V_B"."name" AS "alias2"
FROM
	"public"."V_A" INNER JOIN
	"public"."E_ab" ON "public"."V_A"."ID" = "public"."E_ab"."public.A__O" INNER JOIN
	"public"."V_B" ON "public"."E_ab"."public.B__I" = "public"."V_B"."ID" INNER JOIN
	(VALUES(1, 1),(2, 2),(3, 3),(4, 4)) AS tmp ("tmpId", "index") ON "public"."V_A"."ID" = tmp."tmpId"
ORDER BY
	"index"

SELECT
	"index" as "index",
	"public"."V_B"."ID" AS "alias1",
	"public"."V_B"."name" AS "alias2"
FROM
	"public"."V_A" INNER JOIN
	"public"."E_abb" ON "public"."V_A"."ID" = "public"."E_abb"."public.A__O" INNER JOIN
	"public"."V_B" ON "public"."E_abb"."public.B__I" = "public"."V_B"."ID" INNER JOIN
	(VALUES(2, 1),(3, 2),(4, 3)) AS tmp ("tmpId", "index") ON "public"."V_A"."ID" = tmp."tmpId"
ORDER BY
	"index"

SELECT
	"index" as "index",
	"public"."V_B"."ID" AS "alias1",
	"public"."V_B"."name" AS "alias2"
FROM
	"public"."V_A" INNER JOIN
	"public"."E_abbb" ON "public"."V_A"."ID" = "public"."E_abbb"."public.A__O" INNER JOIN
	"public"."V_B" ON "public"."E_abbb"."public.B__I" = "public"."V_B"."ID" INNER JOIN
	(VALUES(3, 1),(4, 2)) AS tmp ("tmpId", "index") ON "public"."V_A"."ID" = tmp."tmpId"
ORDER BY
	"index"</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">output</div>
<div class="content">
<pre>a1
a2
a3</pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_not_step_2">10.2.8. Not Step</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-java hljs" data-lang="java">@Test
public void testStrategy2NotStep() {
    Vertex a1 = this.sqlgGraph.addVertex(T.label, "A", "name", "a1");
    Vertex a2 = this.sqlgGraph.addVertex(T.label, "A", "name", "a2");
    Vertex b1 = this.sqlgGraph.addVertex(T.label, "B", "name", "b1");
    a1.addEdge("ab", b1);
    this.sqlgGraph.tx().commit();

    Traversal&lt;Vertex, String&gt; traversal = this.sqlgGraph.traversal()
            .V().hasLabel("A")
            .not(
                    __.out()
            ).values("name");

    List&lt;String&gt; names = traversal.toList();
    for (String name : names) {
        System.out.println(name);
    }
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Before optimization</div>
<div class="content">
<pre class="nowrap">[GraphStep(vertex,[]), HasStep([~label.eq(A)]), NotStep([VertexStep(OUT,vertex)]), PropertiesStep([name],value)]</pre>
</div>
</div>
<div id="anchor-after-optimization-not-step-strategy2" class="listingblock">
<div class="title">After optimization</div>
<div class="content">
<pre class="nowrap">[SqlgGraphStep(vertex,[])@[sqlgPathFakeLabel], SqlgNotStepBarrier([[SqlgVertexStep@[sqlgPathFakeLabel]]]), PropertiesStep([name],value)]</pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-sql hljs" data-lang="sql">SELECT
	"public"."V_A"."ID" AS "alias1",
	"public"."V_A"."name" AS "alias2"
FROM
	"public"."V_A"

SELECT
	"index" as "index",
	"public"."V_B"."ID" AS "alias1",
	"public"."V_B"."name" AS "alias2"
FROM
	"public"."V_A" INNER JOIN
	"public"."E_ab" ON "public"."V_A"."ID" = "public"."E_ab"."public.A__O" INNER JOIN
	"public"."V_B" ON "public"."E_ab"."public.B__I" = "public"."V_B"."ID" INNER JOIN
	(VALUES(1, 1),(2, 2)) AS tmp ("tmpId", "index") ON "public"."V_A"."ID" = tmp."tmpId"
ORDER BY
	"index"</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">output</div>
<div class="content">
<pre>a2</pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_where_step">10.2.9. Where Step</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-java hljs" data-lang="java">@Test
public void testStrategy2WhereStep() {
    Vertex a1 = this.sqlgGraph.addVertex(T.label, "A", "name", "a1");
    Vertex a2 = this.sqlgGraph.addVertex(T.label, "A", "name", "a2");
    Vertex b1 = this.sqlgGraph.addVertex(T.label, "B", "name", "b1");
    Vertex b2 = this.sqlgGraph.addVertex(T.label, "B", "name", "b2");
    Vertex b3 = this.sqlgGraph.addVertex(T.label, "B", "name", "b3");
    a1.addEdge("ab", b1);
    a1.addEdge("ab", b2);
    a1.addEdge("ab", b3);
    a2.addEdge("ab", b1);
    this.sqlgGraph.tx().commit();

    Traversal&lt;Vertex, String&gt; traversal = this.sqlgGraph.traversal()
            .V().hasLabel("A")
            .where(
                    __.out()
            ).values("name");
    printTraversalForm(traversal);

    List&lt;String&gt; names = traversal.toList();
    for (String name : names) {
        System.out.println(name);
    }
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Before optimization</div>
<div class="content">
<pre class="nowrap">[GraphStep(vertex,[]), HasStep([~label.eq(A)]), TraversalFilterStep([VertexStep(OUT,vertex)]), PropertiesStep([name],value)]</pre>
</div>
</div>
<div id="anchor-after-optimization-where-step-strategy2" class="listingblock">
<div class="title">After optimization</div>
<div class="content">
<pre class="nowrap">[SqlgGraphStep(vertex,[])@[sqlgPathFakeLabel], SqlgTraversalFilterStepBarrier([SqlgVertexStep@[sqlgPathFakeLabel]]), PropertiesStep([name],value)]</pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-sql hljs" data-lang="sql">SELECT
	"public"."V_A"."ID" AS "alias1",
	"public"."V_A"."name" AS "alias2"
FROM
	"public"."V_A"

SELECT
	"index" as "index",
	"public"."V_B"."ID" AS "alias1",
	"public"."V_B"."name" AS "alias2"
FROM
	"public"."V_A" INNER JOIN
	"public"."E_ab" ON "public"."V_A"."ID" = "public"."E_ab"."public.A__O" INNER JOIN
	"public"."V_B" ON "public"."E_ab"."public.B__I" = "public"."V_B"."ID" INNER JOIN
	(VALUES(1, 1),(2, 2)) AS tmp ("tmpId", "index") ON "public"."V_A"."ID" = tmp."tmpId"
ORDER BY
	"index"</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_predicates">10.3. Predicates</h3>
<div class="paragraph">
<p>TinkerPop&#8217;s <a href="http://tinkerpop.apache.org/javadocs/current/full/org/apache/tinkerpop/gremlin/process/traversal/Compare.html">Compare</a> and
<a href="http://tinkerpop.apache.org/javadocs/current/full/org/apache/tinkerpop/gremlin/process/traversal/Contains.html">Contains</a> predicates are optimized
to execute on the database.</p>
</div>
<div class="sect3">
<h4 id="_compare_predicate">10.3.1. Compare predicate</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-java hljs" data-lang="java">@Test
public void showComparePredicates() {
    Vertex a1 = this.sqlgGraph.addVertex(T.label, "A", "name", "a1");
    Vertex b1 = this.sqlgGraph.addVertex(T.label, "B", "name", "b1");
    Vertex b2 = this.sqlgGraph.addVertex(T.label, "B", "name", "b2");
    Vertex c1 = this.sqlgGraph.addVertex(T.label, "C", "name", "c1");
    Vertex c2 = this.sqlgGraph.addVertex(T.label, "C", "name", "c2");
    Vertex c3 = this.sqlgGraph.addVertex(T.label, "C", "name", "c3");
    Vertex c4 = this.sqlgGraph.addVertex(T.label, "C", "name", "c4");
    a1.addEdge("ab", b1);
    a1.addEdge("ab", b2);
    b1.addEdge("bc", c1);
    b1.addEdge("bc", c2);
    b2.addEdge("bc", c3);
    b2.addEdge("bc", c4);
    this.sqlgGraph.tx().commit();

    List&lt;String&gt; result = this.sqlgGraph.traversal()
            .V().hasLabel("A")
            .out().has("name", P.eq("b1"))
            .out().has("name", P.eq("c2")) <b class="conum">(1)</b>
            .&lt;String&gt;values("name")
            .toList();
    for (String name : result) {
        System.out.println(name);
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>The <code>P</code> predicates will resolve on the database as a <code>sql</code> <code>where</code> clause.</p>
</li>
</ol>
</div>
<div class="listingblock">
<div class="title">sql</div>
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-sql hljs" data-lang="sql">SELECT
	"public"."V_C"."ID" AS "alias1",
	"public"."V_C"."name" AS "alias2"
FROM
	"public"."V_A" INNER JOIN
	"public"."E_ab" ON "public"."V_A"."ID" = "public"."E_ab"."public.A__O" INNER JOIN
	"public"."V_B" ON "public"."E_ab"."public.B__I" = "public"."V_B"."ID" INNER JOIN
	"public"."E_bc" ON "public"."V_B"."ID" = "public"."E_bc"."public.B__O" INNER JOIN
	"public"."V_C" ON "public"."E_bc"."public.C__I" = "public"."V_C"."ID"
WHERE
	( "public"."V_B"."name" = ?) AND ( "public"."V_C"."name" = ?)</code></pre>
</div>
</div>
<div class="paragraph">
<p>The same pattern is used for all the
<a href="http://tinkerpop.apache.org/javadocs/current/full/org/apache/tinkerpop/gremlin/process/traversal/Compare.html">Compare</a> predicates.</p>
</div>
</div>
<div class="sect3">
<h4 id="_contains_predicate">10.3.2. Contains predicate</h4>
<div class="paragraph">
<p>Sqlg&#8217;s implementation of <a href="http://tinkerpop.apache.org/javadocs/current/full/org/apache/tinkerpop/gremlin/process/traversal/Contains.html">Contains</a>
is slightly more complex.</p>
</div>
<div class="paragraph">
<p>For Postgresql, MSSqlServer and HSQLDB a join onto a <code>values expression</code> is used.</p>
</div>
<div class="paragraph">
<p>For H2 and MariaDB a regular <code>in</code> clause is used.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-java hljs" data-lang="java">@Test
public void showContainsPredicate() {
    List&lt;Integer&gt; numbers = new ArrayList&lt;&gt;(10000);
    for (int i = 0; i &lt; 10000; i++) {
        this.sqlgGraph.addVertex(T.label, "A", "number", i);
        numbers.add(i);
    }
    this.sqlgGraph.tx().commit();

    List&lt;Vertex&gt; persons = this.sqlgGraph.traversal().V()
            .hasLabel("A")
            .has("number", P.within(numbers))
            .toList();

    assertEquals(10000, persons.size());
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">sql</div>
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-sql hljs" data-lang="sql">SELECT
	"public"."V_A"."ID" AS "alias1",
	"public"."V_A"."number" AS "alias2"
FROM
	"public"."V_A" INNER JOIN
	(VALUES (0::INTEGER), (1::INTEGER), ... (9998::INTEGER), (9999::INTEGER)) as tmp1(within) on "public"."V_A"."number" = tmp1.within</code></pre>
</div>
</div>
<div class="paragraph">
<p>This pattern makes <code>P.within</code> and <code>p.without</code> very fast even with millions of values being passed into the query.
For the case of there being only one value Sqlg will use an <code>equals</code> instead of a values statement or an <code>in</code> statement.</p>
</div>
</div>
<div class="sect3">
<h4 id="_text_predicate">10.3.3. Text predicate</h4>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
Sqlg assumes a case-sensitive collation.
MSSqlServer does not default to a case-sensitive collation.
Create the database with <code>CREATE DATABASE sqlgraphdb COLLATE sql_latin1_general_cp1_cs_as</code>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Sqlg includes its own Text predicate for full text queries.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Text.contains (case sensitive string contains)</p>
</li>
<li>
<p>Text.ncontains (case sensitive string does not contain)</p>
</li>
<li>
<p>Text.containsCIS (case insensitive string contains)</p>
</li>
<li>
<p>Text.ncontainsCIS (case insensitive string does not contain)</p>
</li>
<li>
<p>Text.startsWith (case sensitive string starts with)</p>
</li>
<li>
<p>Text.nstartsWith (case sensitive string does not start with)</p>
</li>
<li>
<p>Text.endsWith (case sensitive string ends with)</p>
</li>
<li>
<p>Text.nendsWith (case sensitive string does not end with)</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-java hljs" data-lang="java">@Test
public void showTextPredicate() {
    Vertex john = this.sqlgGraph.addVertex(T.label, "Person", "name", "John XXX Doe");
    Vertex peter = this.sqlgGraph.addVertex(T.label, "Person", "name", "Peter YYY Snow");
    this.sqlgGraph.tx().commit();

    List&lt;Vertex&gt; persons = this.sqlgGraph.traversal().V()
            .hasLabel("Person")
            .has("name", Text.contains("XXX")).toList();

    assertEquals(1, persons.size());
    assertEquals(john, persons.get(0));
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">sql</div>
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-sql hljs" data-lang="sql">SELECT
	"public"."V_Person"."ID" AS "alias1",
	"public"."V_Person"."name" AS "alias2"
FROM
	"public"."V_Person"
WHERE
	( "public"."V_Person"."name" like ?)</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_full_text_search">10.3.4. Full text search</h4>
<div class="paragraph">
<p>Full text search is supported on postgresql.</p>
</div>
<div class="paragraph">
<p>This is shown under <a href="#anchor-full-text-indexing">full text indexing</a></p>
</div>
</div>
<div class="sect3">
<h4 id="_datetime_queries">10.3.5. DateTime queries</h4>
<div class="paragraph">
<p>LocalDateTime, LocalDate and LocalTime queries are supported.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-java hljs" data-lang="java">@Test
public void showSearchOnLocalDateTime() {
    LocalDateTime born1 = LocalDateTime.of(1990, 1, 1, 1, 1, 1);
    LocalDateTime born2 = LocalDateTime.of(1990, 1, 1, 1, 1, 2);
    LocalDateTime born3 = LocalDateTime.of(1990, 1, 1, 1, 1, 3);
    Vertex john = this.sqlgGraph.addVertex(T.label, "Person", "name", "John", "born", born1);
    Vertex peter = this.sqlgGraph.addVertex(T.label, "Person", "name", "Peter", "born", born2);
    Vertex paul = this.sqlgGraph.addVertex(T.label, "Person", "name", "Paul", "born", born3);
    this.sqlgGraph.tx().commit();

    List&lt;Vertex&gt; persons = this.sqlgGraph.traversal().V().hasLabel("Person")
            .has("born", P.eq(born1))
            .toList();
    assertEquals(1, persons.size());
    assertEquals(john, persons.get(0));

    persons = this.sqlgGraph.traversal().V().hasLabel("Person")
            .has("born", P.between(LocalDateTime.of(1990, 1, 1, 1, 1, 1), LocalDateTime.of(1990, 1, 1, 1, 1, 3)))
            .toList();
    //P.between is inclusive to exclusive
    assertEquals(2, persons.size());
    assertTrue(persons.contains(john));
    assertTrue(persons.contains(peter));
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">sql</div>
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-sql hljs" data-lang="sql">SELECT
	"public"."V_Person"."ID" AS "alias1",
	"public"."V_Person"."born" AS "alias2",
	"public"."V_Person"."name" AS "alias3"
FROM
	"public"."V_Person"
WHERE
	( "public"."V_Person"."born" &gt;= ?) AND ( "public"."V_Person"."born" &lt; ?)</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_ltree_queries">10.3.6. Ltree queries</h4>
<div class="paragraph">
<p>Postgresql&#8217;s <a href="https://www.postgresql.org/docs/current/ltree.html">ltree</a> extension is supported.
Sqlg includes two custom predicates to help query a <code>ltree</code> column.</p>
</div>
</div>
<div class="sect3">
<h4 id="_lquery_predicate">10.3.7. Lquery predicate</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-java hljs" data-lang="java">@Test
public void testLTreeLquery() {
    Assume.assumeTrue(isPostgres());
    this.sqlgGraph.getTopology().getPublicSchema()
            .ensureVertexLabelExist("Tree", new HashMap&lt;&gt;() {{
                put("path", PropertyDefinition.of(PropertyType.LTREE)); <b class="conum">(1)</b>
            }});
    this.sqlgGraph.tx().commit();
    this.sqlgGraph.addVertex(T.label, "Tree", "path", "one");
    this.sqlgGraph.addVertex(T.label, "Tree", "path", "one.two");
    this.sqlgGraph.addVertex(T.label, "Tree", "path", "one.two.three"); <b class="conum">(2)</b>
    this.sqlgGraph.tx().commit();
    List&lt;Vertex&gt; tree = this.sqlgGraph.traversal().V().hasLabel("Tree")
            .has("path", Lquery.descendantOfRightOrEquals("one.two")) <b class="conum">(3)</b>
            .toList();
    Assert.assertEquals(2, tree.size());

    tree = this.sqlgGraph.traversal().V().hasLabel("Tree")
            .has("path", Lquery.ancestorOfRightOrEquals("one.two")) <b class="conum">(4)</b>
            .toList();
    Assert.assertEquals(2, tree.size());

    tree = this.sqlgGraph.traversal().V().hasLabel("Tree")
            .has("path", Lquery.lquery("one.two.*")) <b class="conum">(5)</b>
            .toList();
    Assert.assertEquals(2, tree.size());
}</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Create a table with a column of type <code>PropertyType.LTREE</code></p>
</li>
<li>
<p>Insert some path hierarchical data.</p>
</li>
<li>
<p>Query the <code>path</code> using the <code>Lquery</code> predicate. In this case searching for descendants.</p>
</li>
<li>
<p>Query the <code>path</code> using the <code>Lquery</code> predicate. In this case searching for ancestors.</p>
</li>
<li>
<p>Query the <code>path</code> using the <code>Lquery</code> predicate. In this case using ltree&#8217;s query syntax.</p>
</li>
</ol>
</div>
<div class="listingblock">
<div class="title">sql</div>
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-sql hljs" data-lang="sql">SELECT
	"public"."V_Tree"."ID" AS "alias1",
	"public"."V_Tree"."path" AS "alias2"
FROM
	"public"."V_Tree"
WHERE
	( "public"."V_Tree"."path" &lt;@ ?)


SELECT
	"public"."V_Tree"."ID" AS "alias1",
	"public"."V_Tree"."path" AS "alias2"
FROM
	"public"."V_Tree"
WHERE
	( "public"."V_Tree"."path" @&gt; ?)

SELECT
	"public"."V_Tree"."ID" AS "alias1",
	"public"."V_Tree"."path" AS "alias2"
FROM
	"public"."V_Tree"
WHERE
	( "public"."V_Tree"."path" ~ ?)</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_lqueryarray_predicate">10.3.8. LqueryArray predicate</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-java hljs" data-lang="java">@Test
public void testLTreeLqueryArray() throws SQLException {
    Assume.assumeTrue(isPostgres());
    this.sqlgGraph.getTopology().getPublicSchema()
            .ensureVertexLabelExist("Tree", new HashMap&lt;&gt;() {{
                put("path", PropertyDefinition.of(PropertyType.LTREE));
            }});
    this.sqlgGraph.tx().commit();
    this.sqlgGraph.addVertex(T.label, "Tree", "path", "one");
    this.sqlgGraph.addVertex(T.label, "Tree", "path", "one.two");
    this.sqlgGraph.addVertex(T.label, "Tree", "path", "one.two.one");
    this.sqlgGraph.addVertex(T.label, "Tree", "path", "one.two.two");
    this.sqlgGraph.addVertex(T.label, "Tree", "path", "one.three");
    this.sqlgGraph.addVertex(T.label, "Tree", "path", "one.three.one");
    this.sqlgGraph.addVertex(T.label, "Tree", "path", "one.three.two");
    this.sqlgGraph.tx().commit();

    List&lt;Vertex&gt; tree = this.sqlgGraph.traversal().V().hasLabel("Tree")
            .has("path", LqueryArray.descendantOfRightOrEquals(new String[]{"one.two", "one.three"})) <b class="conum">(1)</b>
            .toList();
    Assert.assertEquals(6, tree.size());

    tree = this.sqlgGraph.traversal().V().hasLabel("Tree")
            .has("path", LqueryArray.ancestorOfRightOrEquals(new String[]{"one.two", "one.three"}))
            .toList();
    Assert.assertEquals(3, tree.size());
}</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Use <code>LqueryArray</code> to do a ltree query passing in an array</p>
</li>
</ol>
</div>
<div class="listingblock">
<div class="title">sql</div>
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-sql hljs" data-lang="sql">SELECT
	"public"."V_Tree"."ID" AS "alias1",
	"public"."V_Tree"."path" AS "alias2"
FROM
	"public"."V_Tree"
WHERE
	( "public"."V_Tree"."path" &lt;@ ?)</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_custom_functions">10.4. Custom functions</h3>
<div class="paragraph">
<p>Sqlg has support to call any operator the database supports in its <code>select</code> clause.</p>
</div>
<div class="listingblock">
<div class="title">Eg. the <code>+</code> operator</div>
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-java hljs" data-lang="java">    @Test
    public void testFunctions() {
        Schema publicSchema = this.sqlgGraph.getTopology().getPublicSchema();
        VertexLabel personVertexLabel = publicSchema.ensureVertexLabelExist("Person",
                new HashMap&lt;&gt;() {{
                    put("name", PropertyDefinition.of(PropertyType.STRING));
                    put("surname", PropertyDefinition.of(PropertyType.STRING));
                    put("age", PropertyDefinition.of(PropertyType.INTEGER));
                }});
        this.sqlgGraph.tx().commit();
        for (int i = 0; i &lt; 10; i++) {
            this.sqlgGraph.addVertex(T.label, "Person", "name", "name_" + i, "surname", "surname_" + i, "age", i);
        }
        this.sqlgGraph.tx().commit();

        List&lt;Vertex&gt; _additions = this.sqlgGraph.traversal().V().hasLabel("Person")
                .&lt;Vertex&gt;fun(
                        "addition", #<b class="conum">(1)</b>
                        PropertyType.LONG, #<b class="conum">(2)</b>
                        o -&gt; "(" + sqlgGraph.getSqlDialect().maybeWrapInQoutes("age") + " + 10)" #<b class="conum">(3)</b>
                )
                .toList();
        for (Vertex addition : _additions) {
            long agePlus10 = addition.value("addition"); #<b class="conum">(4)</b>
        }

    }</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>The name of the property that will hold the result of the function (operator)</p>
</li>
<li>
<p>The type of the resulting property.</p>
</li>
<li>
<p>The <code>String</code> result of the 3rd parameter will be passed as is to the select clause.
In the case it is saying return <code>"age" + 10</code></p>
</li>
<li>
<p>The age is returned in a custom property</p>
</li>
</ol>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_batch_mode">11. Batch Mode</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Sqlg supports 3 distinct batch modes. Normal, streaming and streaming with lock. Batch modes are only implemented on Postgresql.
Batch mode is activated on the transaction object itself. After every <code>commit</code> the batchMode needs to be reactivated.</p>
</div>
<div class="paragraph">
<p>Sqlg introduces an extra method on the transaction, <code>flush()</code>.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>In normal batch mode <code>flush()</code> will send all the data to Postgresql, assign id(s) and clear the cache.</p>
</li>
<li>
<p>In streaming mode <code>flush()</code> will close the OutputStream that the data has been written to.</p>
</li>
<li>
<p>In streaming mode with lock <code>flush()</code> will close the OutputStream that the data has been written to and assign id(s).</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The Postgresql '<a href="https://www.postgresql.org/docs/current/static/sql-copy.html">copy</a>' command is used to bulk insert data.</p>
</div>
<div class="sect2">
<h3 id="_normal_batch_mode">11.1. Normal batch mode</h3>
<div class="paragraph">
<p>In normal batch mode the standard TinkerPop modification api can be used. Normal batch mode caches all modifications in memory
and on <code>commit()</code> or <code>flush()</code> sends the modifications to the server.</p>
</div>
<div class="paragraph">
<p>Because all modifications are held in memory it is important to call <code>commit()</code> or <code>flush()</code> to prevent an <code>OutOfMemoryError</code>.</p>
</div>
<div class="paragraph">
<p>In batch mode vertices and edges returned from <code>Graph.addVertex</code> and <code>vertex.addEdge</code> respectively do <strong>not</strong> yet have their id(s) assigned to them.
This is because the new vertices and edges are cached in memory and are only sent to Postgresql on <code>commit()</code> or <code>flush()</code>.
After <code>commit()</code> or <code>flush()</code> the new vertices and edges have their id(s) assigned.</p>
</div>
<div class="paragraph">
<p>The transaction must be manually placed in normal batch mode. i.e. <code>SqlgGraph.tx().normalBatchModeOn()</code> must occur before any batch processing.
After every <code>commit()</code> the transaction reverts to a regular transaction and must be placed in normal batch mode again
for batch processing to continue.</p>
</div>
<div class="paragraph">
<p>Vertices and edges can be created and updated and removed as per normal making normal batch mode easy to use.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
Sqlg does not query the cache. If a gremlin query is executed while in batch mode the batch is first flushed.
Take care not to query the graph while in batch mode as flushing often will defeat the purpose of batching in the first place.
</td>
</tr>
</table>
</div>
<div class="listingblock">
<div class="title">custom api</div>
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-java hljs" data-lang="java">sqlgGraph.tx().normalBatchModeOn();
sqlgGraph.tx().flush();</code></pre>
</div>
</div>
<div class="paragraph">
<p>Create 10 000 000 Persons each with a car. 20 000 000 vertices and 10 000 000 edges in total.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-java hljs" data-lang="java">@Test
public void showNormalBatchMode() {
    StopWatch stopWatch = new StopWatch();
    stopWatch.start();
    this.sqlgGraph.tx().normalBatchModeOn();
    for (int i = 1; i &lt;= 10_000_000; i++) {
        Vertex person = this.sqlgGraph.addVertex(T.label, "Person", "name", "John" + i);
        Vertex car = this.sqlgGraph.addVertex(T.label, "Car", "name", "Dodge" + i);
        person.addEdge("drives", car);
        if (i % 100_000 == 0) { # <b class="conum">(1)</b>
            this.sqlgGraph.tx().flush(); # <b class="conum">(1)</b>
        }
    }
    this.sqlgGraph.tx().commit();
    stopWatch.stop();
    System.out.println(stopWatch.toString());
}</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>To preserve memory <code>commit</code> or <code>flush</code> every so often.</p>
</li>
</ol>
</div>
<div class="listingblock">
<div class="title">output without edge foreign keys</div>
<div class="content">
<pre>Time taken: 0:05:48.889</pre>
</div>
</div>
<div class="listingblock">
<div class="title">output with edge foreign keys</div>
<div class="content">
<pre>Time taken: 0:02:33.313</pre>
</div>
</div>
<div class="paragraph">
<div class="title">memory</div>
<p><span class="image"><img src="./img/sqlg/normalBatchModeMemory.png" alt="image of tinkerpop-classic"></span></p>
</div>
</div>
<div class="sect2">
<h3 id="_streaming_batch_mode">11.2. Streaming batch mode</h3>
<div class="paragraph">
<p>Streaming batch writes any new vertex or edge immediately to Postgresql via its <code>stdin</code> api. I.e. the data is written
directly to a Postgresql jdbc driver OutputStream.</p>
</div>
<div class="paragraph">
<p>Streaming batch mode does <strong>not</strong> use the <code>Graph.addVertex</code> method. Instead <code>SqlgGraph.streamVertex</code> is defined.</p>
</div>
<div class="paragraph">
<p>The transaction must be placed in streaming batch mode manually before any streaming batch modification can happen. <code>SqlgGraph.tx().streamingBatchModeOn()</code>
After every <code>commit()</code> the transaction reverts to normal mode and must be placed into streaming batch mode again
for streaming batch mode to continue.</p>
</div>
<div class="paragraph">
<p>The benefit of streaming mode is that the memory consumption is very low as nothing is cached. It is also somewhat faster than
the normal batch mode (+/- 25% faster).</p>
</div>
<div class="paragraph">
<p>However the caveat is that, per transaction/thread only one label/table can be written between consecutive calls to <code>SqlgTransaction.flush()</code>.
Further it is not possible to assign an id to the vertex or element. As such the <code>SqlgGraph.streamVertex</code> method returns void.</p>
</div>
<div class="listingblock">
<div class="title">custom api</div>
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-java hljs" data-lang="java">sqlgGraph.tx().streamingBatchModeOn();</code></pre>
</div>
</div>
<div class="paragraph">
<p>Create 10 000 000 Persons and 10 000 000 cars.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-java hljs" data-lang="java">@Test
public void showStreamingBatchMode() {
    StopWatch stopWatch = new StopWatch();
    stopWatch.start();
    //enable streaming mode
    this.sqlgGraph.tx().streamingBatchModeOn();
    for (int i = 1; i &lt;= 10_000_000; i++) {
        this.sqlgGraph.streamVertex(T.label, "Person", "name", "John" + i);
    }
    this.sqlgGraph.tx().flush(); # <b class="conum">(1)</b>
    for (int i = 1; i &lt;= 10_000_000; i++) {
        this.sqlgGraph.streamVertex(T.label, "Car", "name", "Dodge" + i);
    }
    this.sqlgGraph.tx().commit();
    stopWatch.stop();
    System.out.println(stopWatch.toString());
}</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>flushing is needed before starting streaming Car. Only only one label/table can stream at a time.</p>
</li>
</ol>
</div>
<div class="listingblock">
<div class="title">output</div>
<div class="content">
<pre>Time taken: 0:00:42.014</pre>
</div>
</div>
<div class="paragraph">
<div class="title">memory</div>
<p><span class="image"><img src="./img/sqlg/streamingBatchModeMemory.png" alt="image of tinkerpop-classic"></span></p>
</div>
</div>
<div class="sect2">
<h3 id="_bulk_edge_creation">11.3. Bulk edge creation</h3>
<div class="paragraph">
<p>To create an edge via the normal api a handle to the <code>Vertex</code> is needed.
This is not always the case. In particula if the <code>SqlgGraph.streamVertex</code> api is used no handle to the <code>Vertex</code> is returned.</p>
</div>
<div class="paragraph">
<p>For this scenario there is a bulk edge creation method.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-java hljs" data-lang="java">public &lt;L, R&gt; void bulkAddEdges(String outVertexLabel, String inVertexLabel, String edgeLabel, Pair&lt;String, String&gt; idFields, Collection&lt;Pair&lt;L, R&gt;&gt; uids) {</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p><code>outLabel</code> and <code>inLabel</code> specifies the out and in vertex labels that the edges will be between.</p>
</li>
<li>
<p><code>edgeLabel</code> is the label of the edges to be created.</p>
</li>
<li>
<p><code>idFields</code> specifies the fields that uniquely identify the out and in vertex.</p>
</li>
<li>
<p><code>uids</code> are the actual unique identifies for each out/in vertex pairing.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Sqlg will then first copy the <code>uids</code> into a temporary table. Then it joins the temporary table on the out and in vertex tables
to retrieve the in and out ids.
These ids are then inserted into the edge table.
All this happens on Postgresql, having minimal processing and memory impact on the java process.</p>
</div>
<div class="paragraph">
<p>The unique identifiers still have to be kept in memory, but its is not necessary to have the actual out and in vertices in memory.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
The unique identifiers do not need to be the vertices&#8217;s id. It can be any property as long as it is unique.
</td>
</tr>
</table>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-java hljs" data-lang="java">@Test
public void showBulkEdgeCreation() {
    StopWatch stopWatch = new StopWatch();
    stopWatch.start();
    int count = 0;
    for (int i = 1; i &lt;= 10; i++) {
        List&lt;Pair&lt;String, String&gt;&gt; identifiers = new ArrayList&lt;&gt;();
        this.sqlgGraph.tx().streamingBatchModeOn();
        for (int j = 1; j &lt;= 1_000_000; j++) {
            this.sqlgGraph.streamVertex(T.label, "Person", "name", "John" + count, "personUid", String.valueOf(count));
        }
        this.sqlgGraph.tx().flush();
        for (int j = 1; j &lt;= 1_000_000; j++) {
            this.sqlgGraph.streamVertex(T.label, "Car", "name", "Dodge" + count, "carUid", String.valueOf(count));
            identifiers.add(Pair.of(String.valueOf(count), String.valueOf(count++)));
        }
        this.sqlgGraph.tx().flush();
        this.sqlgGraph.bulkAddEdges("Person", "Car", "drives", Pair.of("personUid", "carUid"), identifiers);
        this.sqlgGraph.tx().commit();
    }
    stopWatch.stop();
    System.out.println("Time taken: " + stopWatch.toString());
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">output (with edge foreign keys)</div>
<div class="content">
<pre>Time taken: 0:10:03.397</pre>
</div>
</div>
<div class="listingblock">
<div class="title">output (without edge foreign keys)</div>
<div class="content">
<pre>Time taken: 0:03:45.951</pre>
</div>
</div>
<div class="paragraph">
<div class="title">memory</div>
<p><span class="image"><img src="./img/sqlg/bulkAddEdgesMemory.png" alt="image of tinkerpop-classic"></span></p>
</div>
</div>
<div class="sect2">
<h3 id="_streaming_with_lock_batch_mode">11.4. Streaming with lock batch mode</h3>
<div class="paragraph">
<p>Streaming with lock batch mode is similar to streaming batch mode. The difference being that the label/table being written to is
locked. Locking the table ensures that no concurrent changes will occur on the table. This allows Sqlg to query the id sequence and
assigned ids to the elements.</p>
</div>
<div class="paragraph">
<p>This means that the normal <code>Vertex vertex = graph.addVertex(&#8230;&#8203;)</code> method can be used. This is useful if a pointer to the new vertices are needed.</p>
</div>
<div class="paragraph">
<p>The transaction must be placed into streaming with lock batch mode manually before any streaming with lock batch modification can happen.
<code>SqlgGraph.tx().streamingWithLockBatchModeOn()</code> After every <code>commit()</code> the transaction reverts to normal mode and must
be placed into streaming batch mode again for streaming batch mode to continue.</p>
</div>
<div class="listingblock">
<div class="title">custom api</div>
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-java hljs" data-lang="java">sqlgGraph.tx().streamingWithLockBatchModeOn();</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-java hljs" data-lang="java">@Test
public void showStreamingWithLockBulkEdgeCreation() {
    StopWatch stopWatch = new StopWatch();
    stopWatch.start();
    int count = 0;
    for (int i = 1; i &lt;= 10; i++) {
        List&lt;Vertex&gt; persons = new ArrayList&lt;&gt;();
        this.sqlgGraph.tx().streamingWithLockBatchModeOn();
        for (int j = 1; j &lt;= 1_000_000; j++) {
            Vertex person = this.sqlgGraph.addVertex(T.label, "Person", "name", "John" + count);
            persons.add(person);
        }
        this.sqlgGraph.tx().flush();
        List&lt;Vertex&gt; cars = new ArrayList&lt;&gt;();
        for (int j = 1; j &lt;= 1_000_000; j++) {
            Vertex car = this.sqlgGraph.addVertex(T.label, "Car", "name", "Dodge" + count++);
            cars.add(car);
        }
        this.sqlgGraph.tx().flush();
        Iterator&lt;Vertex&gt; carIter = cars.iterator();
        for (Vertex person : persons) {
            person.addEdge("drives", carIter.next());
        }
        this.sqlgGraph.tx().commit();
    }
    stopWatch.stop();
    System.out.println(stopWatch.toString());
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">output without edge foreign keys</div>
<div class="content">
<pre>Time taken: 0:02:42.363</pre>
</div>
</div>
<div class="paragraph">
<div class="title">memory</div>
<p><span class="image"><img src="./img/sqlg/streamingBatchModeWithLockMemory.png" alt="image of tinkerpop-classic"></span></p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="anchor-topology">12. Topology</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Sqlg stores the graph&#8217;s topology information in the graph itself as a graph.
The topology is stored in the <code>sqlg_schema</code> schema.</p>
</div>
<div class="paragraph">
<div class="title">UML diagram of Sqlg&#8217;s topology.</div>
<p><span class="image"><img src="./img/uml/Package_topology_propertyClassDiagramQualifier.PNG" alt="image of Sqlg&#8217;s topology"></span></p>
</div>
<div class="paragraph">
<p>TinkerPop has no notion of schema or topology. However any TinkerPop graph has an implicit schema.
Sqlg manages the schema as a first class construct.</p>
</div>
<div class="paragraph">
<p>Sqlg follows the normal TinkerPop semantics in that the schema does not need to be defined upfront.
Every graph modification first checks to see if the element&#8217;s schema (label,name) exists.
If not, it will create the element&#8217;s schema. For <code>Postgresql</code> this works well as it supports transactional schema creation/modification.</p>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<div class="title">Warning</div>
</td>
<td class="content">
Hsqldb, H2 do not support transactional schema creation/modification. They will both silently commit the
transaction and continue. This breaks the user&#8217;s transaction boundaries. For Hsqldb and H2 it is recommended to
create the schema upfront.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>It is possible to query and traverse the topology as a normal TinkerPop graph.
To query the topology the <code>TopologyStrategy</code> is used. To facilitate ease of use, <code>SqlgGraph.topology()</code> method is added to enable the strategy.
Being able to query the topology is helpful to understand a graph&#8217;s structure.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-java hljs" data-lang="java">@Test
public void showTopologyTraversals() {
    Io.Builder&lt;GraphSONIo&gt; builder = GraphSONIo.build(GraphSONVersion.V3_0);
    final GraphReader reader = sqlgGraph.io(builder).reader().create();
    try (final InputStream stream = AbstractGremlinTest.class.getResourceAsStream("/tinkerpop-modern-v3d0.json")) {
        reader.readGraph(stream, sqlgGraph);
    } catch (IOException e) {
        Assert.fail(e.getMessage());
    } <b class="conum">(1)</b>
    System.out.println("//All vertex labels");
    sqlgGraph.topology().V()
            .hasLabel(Topology.SQLG_SCHEMA + "." + Topology.SQLG_SCHEMA_VERTEX_LABEL) # <b class="conum">(2)</b>
            .forEachRemaining(
                    v -&gt; System.out.println(v.&lt;String&gt;value(Topology.SQLG_SCHEMA_VERTEX_LABEL_NAME))
            );

    System.out.println("//All edge labels");
    sqlgGraph.topology().V()
            .hasLabel(Topology.SQLG_SCHEMA + "." + Topology.SQLG_SCHEMA_VERTEX_LABEL)
            .out(Topology.SQLG_SCHEMA_OUT_EDGES_EDGE) # <b class="conum">(3)</b>
            .forEachRemaining(
                    v -&gt; System.out.println(v.&lt;String&gt;value(Topology.SQLG_SCHEMA_EDGE_LABEL_NAME))
            );

    System.out.println("//'person' properties");
    sqlgGraph.topology().V()
            .hasLabel(Topology.SQLG_SCHEMA + "." + Topology.SQLG_SCHEMA_VERTEX_LABEL)
            .has(Topology.SQLG_SCHEMA_VERTEX_LABEL_NAME, "person") # <b class="conum">(4)</b>
            .out(Topology.SQLG_SCHEMA_VERTEX_PROPERTIES_EDGE) # <b class="conum">(5)</b>
            .forEachRemaining(
                    v -&gt; {
                        System.out.print(v.&lt;String&gt;value(Topology.SQLG_SCHEMA_PROPERTY_NAME) + " : ");
                        System.out.println(v.&lt;String&gt;value(Topology.SQLG_SCHEMA_PROPERTY_TYPE));
                    }
            );

    System.out.println("//'software' properties");
    sqlgGraph.topology().V()
            .hasLabel(Topology.SQLG_SCHEMA + "." + Topology.SQLG_SCHEMA_VERTEX_LABEL)
            .has(Topology.SQLG_SCHEMA_VERTEX_LABEL_NAME, "software")
            .out(Topology.SQLG_SCHEMA_VERTEX_PROPERTIES_EDGE)
            .forEachRemaining(
                    v -&gt; {
                        System.out.print(v.&lt;String&gt;value(Topology.SQLG_SCHEMA_PROPERTY_NAME) + " : ");
                        System.out.println(v.&lt;String&gt;value(Topology.SQLG_SCHEMA_PROPERTY_TYPE));
                    }
            );

    System.out.println("//'created' properties");
    sqlgGraph.topology().V()
            .hasLabel(Topology.SQLG_SCHEMA + "." + Topology.SQLG_SCHEMA_VERTEX_LABEL) # <b class="conum">(6)</b>
            .out(Topology.SQLG_SCHEMA_OUT_EDGES_EDGE) # <b class="conum">(7)</b>
            .has(Topology.SQLG_SCHEMA_EDGE_LABEL_NAME, "created") # <b class="conum">(8)</b>
            .out(Topology.SQLG_SCHEMA_EDGE_PROPERTIES_EDGE) # <b class="conum">(9)</b>
            .forEachRemaining(
                    v -&gt; {
                        System.out.print(v.&lt;String&gt;value(Topology.SQLG_SCHEMA_PROPERTY_NAME) + " : ");
                        System.out.println(v.&lt;String&gt;value(Topology.SQLG_SCHEMA_PROPERTY_TYPE));
                    }
            );

    System.out.println("//'knows' properties");
    sqlgGraph.topology().V()
            .hasLabel(Topology.SQLG_SCHEMA + "." + Topology.SQLG_SCHEMA_VERTEX_LABEL)
            .out(Topology.SQLG_SCHEMA_OUT_EDGES_EDGE)
            .has(Topology.SQLG_SCHEMA_EDGE_LABEL_NAME, "knows")
            .out(Topology.SQLG_SCHEMA_EDGE_PROPERTIES_EDGE)
            .forEachRemaining(
                    v -&gt; {
                        System.out.print(v.&lt;String&gt;value(Topology.SQLG_SCHEMA_PROPERTY_NAME) + " : ");
                        System.out.println(v.&lt;String&gt;value(Topology.SQLG_SCHEMA_PROPERTY_TYPE));
                    }
            );

}</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Use TinkerPop&#8217;s i.o. infrastructure to load the modern graph.</p>
</li>
<li>
<p>Find all VertexLabels, they are in <code>sqlg_schema.vertex</code></p>
</li>
<li>
<p>Traverse out on the <code>out_edges</code> edge to find all the edges. 'WARNING' this may produce duplicates as a single edge label
may have many different distinct out vertex labels.</p>
</li>
<li>
<p>Find the <code>person</code> vertex.</p>
</li>
<li>
<p>Traverse out on the <code>vertex_property</code> edge to find the 'person' vertex labels properties.</p>
</li>
<li>
<p>Find all vertex labels. i.e. vertices in <code>sqlg_schema.vertex</code></p>
</li>
<li>
<p>Traverse the <code>out_edges</code> edge.</p>
</li>
<li>
<p>Filter the out edges for only the 'created' edges.</p>
</li>
<li>
<p>Traverse the <code>edge_properties</code> edge to find the 'created' edge&#8217;s properties.</p>
</li>
</ol>
</div>
<div class="listingblock">
<div class="title">output</div>
<div class="content">
<pre>//All vertex labels
person
software
//All edge labels
knows
created
//'person' properties
name : STRING
age : INTEGER
//'software' properties
name : STRING
lang : STRING
//'created' properties
weight : DOUBLE
//'knows' properties
weight : DOUBLE</pre>
</div>
</div>
<div class="sect2">
<h3 id="_topology_eager_creation">12.1. Topology eager creation</h3>
<div class="paragraph">
<p>It is often useful to create the topology upfront. The topology creation api is accessed via the <code>Topology</code> object.
It is a singleton. <code>Topology topology = sqlgGraph.getTopology();</code>
To create new topology objects use the <code>ensureXXX</code> methods. They will return a topology object representing the specific
topology element. i.e. <code>Schema</code>, <code>VertexLabel</code>, <code>EdgeLabel</code>, <code>PropertyColumn</code>, <code>Index</code>, <code>Partition</code></p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
The <code>ensureXXX</code> methods will create the topology object if it does not exists.
If it does exist it will simply return the relevant topology object.
On any topology object one can call <code>isCommitted</code> or <code>isUncommitted</code> to check the state of the object.
<code>committed</code> indicates that it already exists. <code>uncommitted</code> indicates that it has been created in the current active transaction.
</td>
</tr>
</table>
</div>
<div class="listingblock">
<div class="title">eg</div>
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-java hljs" data-lang="java">@Test
public void createModernTopology() {
    Topology topology = this.sqlgGraph.getTopology(); # <b class="conum">(1)</b>
    VertexLabel personVertexLabel = topology.ensureVertexLabelExist("public", "person", new HashMap&lt;&gt;() {{
        put("name", PropertyDefinition.of(PropertyType.STRING));
        put("age", PropertyDefinition.of(PropertyType.INTEGER));
    }}); # <b class="conum">(2)</b>
    VertexLabel softwareVertexLabel = topology.ensureVertexLabelExist("public", "software", new HashMap&lt;&gt;() {{
        put("name", PropertyDefinition.of(PropertyType.STRING));
        put("lang", PropertyDefinition.of(PropertyType.STRING));
    }});
    EdgeLabel createdEdgeLabel = personVertexLabel.ensureEdgeLabelExist("created", softwareVertexLabel, new HashMap&lt;&gt;() {{
        put("weight", PropertyDefinition.of(PropertyType.DOUBLE));
    }}); # <b class="conum">(3)</b>
    EdgeLabel knowsEdgeLabel = personVertexLabel.ensureEdgeLabelExist("knows", personVertexLabel, new HashMap&lt;&gt;() {{
        put("weight", PropertyDefinition.of(PropertyType.DOUBLE));
    }});
    this.sqlgGraph.tx().commit(); # <b class="conum">(4)</b>
}</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Get the <code>Topology</code> object.</p>
</li>
<li>
<p>Create the 'person' VertexLabel. The <code>HashMap&lt;String, PropertyDefinition&gt;</code> defines the 'person''s properties.</p>
</li>
<li>
<p>Create the 'created' EdgeLabel. The format is outVertexLabel.ensureEdgeLabelExist(name, inVertexLabel, properties)</p>
</li>
<li>
<p>Be sure to commit the transaction. Postgresql and MSSqlServer supports transactional schema creation. Hsqldb,H2 and MariaDB do not.</p>
</li>
</ol>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-java hljs" data-lang="java">@Test
public void generalTopologyCreationWithSchema() {
    Schema schema = this.sqlgGraph.getTopology().ensureSchemaExist("Humans"); # <b class="conum">(1)</b>
    VertexLabel personVertexLabel = schema.ensureVertexLabelExist("Person", new HashMap&lt;&gt;() {{
        put("name", PropertyDefinition.of(PropertyType.STRING));
        put("date", PropertyDefinition.of(PropertyType.LOCALDATE));
    }}); # <b class="conum">(2)</b>
    this.sqlgGraph.tx().commit();
}</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Create the 'Humans' schema</p>
</li>
<li>
<p>Create the 'Person' VertexLabel via the Schema object.</p>
</li>
</ol>
</div>
</div>
<div class="sect2">
<h3 id="_propertydefinition">12.2. PropertyDefinition</h3>
<div class="paragraph">
<p>The <code>PropertyDefinition</code> class defines a Sqlg property. It is responsible for,</p>
</div>
<div class="ulist">
<ul>
<li>
<p>PropertyType</p>
</li>
<li>
<p>Multiplicity</p>
</li>
<li>
<p>defaultLiteral</p>
</li>
<li>
<p>checkConstraint</p>
</li>
</ul>
</div>
<div class="sect3">
<h4 id="_propertytype">12.2.1. PropertyType</h4>
<div class="paragraph">
<p><code>PropertyType</code> holds all the types Sqlg supports.</p>
</div>
</div>
<div class="sect3">
<h4 id="_multiplicity">12.2.2. Multiplicity</h4>
<div class="listingblock">
<div class="content">
<pre>record Multiplicity(long lower, long upper, boolean unique, boolean ordered)</pre>
</div>
</div>
<div class="paragraph">
<p><code>lower</code> and <code>upper</code> specifies the cardinality limits of a property.
For a <code>PropertyDefinition</code> only <code>lower</code> and <code>upper</code> parts of <code>Multiplicity</code> is supported.</p>
</div>
<div class="paragraph">
<p><code>unique</code> and <code>ordered</code> is not implemented for a <code>PropertyDefinition</code>.</p>
</div>
<div class="paragraph">
<p>A <code>lower</code> multiplicity of 0 indicates that the property is <strong>not</strong> required.<br>
A <code>lower</code> multiplicity of 1 indicates that the property <strong>is</strong> required. Sqlg will generate a <code>NOT NULL</code> clause for the property.<br>
A <code>upper</code> multiplicity &gt; 1 only makes sense for a property with an array type.<br>
A <code>upper</code> multiplicity of -1 indicates that there is <strong>no</strong> upper limit.<br>
For a multiplicity &gt; -1 Sqlg will generate a <code>CHECK</code> constraint to validate the multiplicity.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-java hljs" data-lang="java">@Test
public void testNameIsRequired() {
    VertexLabel personVertexLabel = this.sqlgGraph.getTopology().getPublicSchema()
            .ensureVertexLabelExist("Person",
                    new HashMap&lt;&gt;() {{
                        put("name", PropertyDefinition.of(PropertyType.STRING, Multiplicity.of(1, 1))); # <b class="conum">(1)</b>
                    }}
            );
    boolean failure = false;
    try {
        this.sqlgGraph.addVertex(T.label, "Person"); #<b class="conum">(2)</b>
        this.sqlgGraph.tx().commit();
    } catch (Exception e) {
        LOGGER.error(e.getMessage(), e); #<b class="conum">(3)</b>
        failure = true;
    }
    assertTrue(failure);
}</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Specify a multiplicity of [1,1], i.e. the property is required.</p>
</li>
<li>
<p>The <code>name</code> property is <strong>not</strong> specified.</p>
</li>
<li>
<p>An exception is thrown by the database.</p>
</li>
</ol>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-none hljs">org.postgresql.util.PSQLException: ERROR: null value in column "name" of relation "V_Person" violates not-null constraint
Detail: Failing row contains (1, null).</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-java hljs" data-lang="java">@Test
public void testArrayLowerMultiplicity() {
    this.sqlgGraph.getTopology().getPublicSchema()
            .ensureVertexLabelExist("Person",
                    new HashMap&lt;&gt;() {{
                        put("names", PropertyDefinition.of(PropertyType.STRING_ARRAY, Multiplicity.of(2, 4))); #<b class="conum">(1)</b>
                    }}
            );
    this.sqlgGraph.tx().commit();
    boolean failure = false;
    try {
        this.sqlgGraph.addVertex(T.label, "Person", "names", new String[]{"John"}); #<b class="conum">(2)</b>
        this.sqlgGraph.tx().commit();
    } catch (Exception e) {
        LOGGER.error(e.getMessage(), e); #<b class="conum">(3)</b>
        failure = true;
        this.sqlgGraph.tx().rollback();
    }
    assertTrue(failure);
}</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Specify a lower multiplicity of 2. i.e. the Person must have at least 2 names.</p>
</li>
<li>
<p>Only one name is specified.</p>
</li>
<li>
<p>An exception is thrown by the database.</p>
</li>
</ol>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-none hljs">org.postgresql.util.PSQLException: ERROR: new row for relation "V_Person" violates check constraint "V_Person_names_check"
  Detail: Failing row contains (1, {John}).</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-java hljs" data-lang="java">@Test
public void testArrayUpperMultiplicity() {
    this.sqlgGraph.getTopology().getPublicSchema()
            .ensureVertexLabelExist("Person",
                    new HashMap&lt;&gt;() {{
                        put("names", PropertyDefinition.of(PropertyType.STRING_ARRAY, Multiplicity.of(2, 4))); #<b class="conum">(1)</b>
                    }}
            );
    this.sqlgGraph.tx().commit();
    boolean failure = false;
    try {
        this.sqlgGraph.addVertex(T.label, "Person", "names", new String[]{"John", "Joe", "Jonathan", "James", "Peter"}); #<b class="conum">(2)</b>
        this.sqlgGraph.tx().commit();
    } catch (Exception e) {
        LOGGER.error(e.getMessage(), e); #<b class="conum">(3)</b>
        failure = true;
        this.sqlgGraph.tx().rollback();
    }
    assertTrue(failure);
}</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>upper multiplicity of 4 is specified. i.e. Person may not have more than 4 names.</p>
</li>
<li>
<p>5 names are specified.</p>
</li>
<li>
<p>An exception is thrown by the database.</p>
</li>
</ol>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-none hljs">org.postgresql.util.PSQLException: ERROR: new row for relation "V_Person" violates check constraint "V_Person_names_check"
  Detail: Failing row contains (1, {John,Joe,Jonathan,James,Peter}).</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_default_values">12.2.3. Default values</h4>
<div class="paragraph">
<p>Sqlg supports specifying a default value for a property. The value needs to be a valid literal as it is passed directly to the database without parsing.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-java hljs" data-lang="java">@Test
public void testDefaultValue() {
    this.sqlgGraph.getTopology().getPublicSchema()
            .ensureVertexLabelExist("Person",
                    new HashMap&lt;&gt;() {{
                        put("name", PropertyDefinition.of(PropertyType.STRING, Multiplicity.of(1, 1), "'John'")); #<b class="conum">(1)</b>
                    }}
            );
    this.sqlgGraph.tx().commit();
    this.sqlgGraph.addVertex(T.label, "Person"); #<b class="conum">(2)</b>
    this.sqlgGraph.tx().commit();
    List&lt;String&gt; names = this.sqlgGraph.traversal().V().hasLabel("Person").&lt;String&gt;values("name").toList();
    assertEquals(1, names.size());
    assertEquals("John", names.get(0)); #<b class="conum">(3)</b>
}</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Specify a default literal <code>'John'</code> for the <code>name</code> property.</p>
</li>
<li>
<p>Not specifying a value for the <code>name</code> property.</p>
</li>
<li>
<p>Assert that the value is indeed the default value of <code>'John'</code>;</p>
</li>
</ol>
</div>
</div>
<div class="sect3">
<h4 id="_check_constraints">12.2.4. Check constraints</h4>
<div class="paragraph">
<p>Sqlg supports adding <code>CHECK</code> constraints to any property.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-java hljs" data-lang="java">@Test
public void testCheckConstraints() {
    this.sqlgGraph.getTopology().getPublicSchema()
            .ensureVertexLabelExist("Person",
                    new HashMap&lt;&gt;() {{
                        put("name", PropertyDefinition.of(PropertyType.STRING, Multiplicity.of(), "'Peter'", "name &lt;&gt; 'John'")); #<b class="conum">(1)</b>
                    }}
            );
    this.sqlgGraph.tx().commit();
    this.sqlgGraph.addVertex(T.label, "Person"); #<b class="conum">(2)</b>
    this.sqlgGraph.tx().commit();
    boolean failure = false;
    try {
        this.sqlgGraph.addVertex(T.label, "Person", "name", "John"); #<b class="conum">(3)</b>
        this.sqlgGraph.tx().commit();
    } catch (Exception e) {
        LOGGER.error(e.getMessage(), e); #<b class="conum">(4)</b>
        failure = true;
    }
    assertTrue(failure);
}</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Add a <code>CHECK</code> constraint that the Person&#8217;s name may not be 'John'</p>
</li>
<li>
<p>The default value is 'Peter'</p>
</li>
<li>
<p>Try to add `John'</p>
</li>
<li>
<p>An exception is thrown by the database.</p>
</li>
</ol>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-none hljs">org.postgresql.util.PSQLException: ERROR: new row for relation "V_Person" violates check constraint "V_Person_name_check"
  Detail: Failing row contains (2, John).</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_update_propertydefinition">12.2.5. Update PropertyDefinition</h4>
<div class="paragraph">
<p>Sqlg supports updating the <code>PropertyDefinition</code>.
<code>PropertyColumn.updatePropertyDefinition(&#8230;&#8203;)</code> allows for updating the property&#8217;s definition.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-java hljs" data-lang="java">@Test
public void testUpdatePropertyDefinition() {
    this.sqlgGraph.getTopology().getPublicSchema().ensureVertexLabelExist("A", new HashMap&lt;&gt;() {{
        put("col1", PropertyDefinition.of(PropertyType.STRING, Multiplicity.of(0, 1))); <b class="conum">(1)</b>
    }});
    this.sqlgGraph.tx().commit();
    Vertex a = this.sqlgGraph.addVertex(T.label, "A");
    this.sqlgGraph.tx().commit();
    a = this.sqlgGraph.traversal().V().hasLabel("A").tryNext().orElseThrow();
    Assert.assertNull(a.value("col1")); <b class="conum">(2)</b>
    a.property("col1", "test"); <b class="conum">(3)</b>
    this.sqlgGraph.tx().commit();

    VertexLabel aVertexLabel = this.sqlgGraph.getTopology().getPublicSchema().getVertexLabel("A").orElseThrow();
    PropertyColumn propertyColumn = aVertexLabel.getProperty("col1").orElseThrow();
    propertyColumn.updatePropertyDefinition(PropertyDefinition.of(PropertyType.STRING, Multiplicity.of(1, 1))); <b class="conum">(4)</b>
    this.sqlgGraph.tx().commit();

    try {
        this.sqlgGraph.addVertex(T.label, "A"); <b class="conum">(5)</b>
        Assert.fail("not null constraint expected");
    } catch (Exception e) {
        this.sqlgGraph.tx().rollback();
    }

    propertyColumn.updatePropertyDefinition(PropertyDefinition.of(PropertyType.STRING, Multiplicity.of(1, 1), "'test'")); <b class="conum">(6)</b>
    a = this.sqlgGraph.addVertex(T.label, "A");
    Assert.assertEquals("test", a.value("col1")); <b class="conum">(7)</b>
    this.sqlgGraph.tx().commit();

    propertyColumn.updatePropertyDefinition(PropertyDefinition.of(PropertyType.STRING, Multiplicity.of(1, 1), "'test'", "(starts_with(" + sqlgGraph.getSqlDialect().maybeWrapInQoutes("col1") + ", 't'))")); <b class="conum">(8)</b>
    try {
        a = this.sqlgGraph.addVertex(T.label, "A", "col1", "x"); <b class="conum">(9)</b>
        Assert.fail("check constraint expected");
    } catch (Exception e) {
        this.sqlgGraph.tx().rollback();
    }
    a = this.sqlgGraph.addVertex(T.label, "A", "col1", "taaa"); <b class="conum">(10)</b>
    this.sqlgGraph.tx().commit();
}</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Property 'col1' is not required.</p>
</li>
<li>
<p>Check that 'col1' is null.</p>
</li>
<li>
<p>Set 'col1' to "b"</p>
</li>
<li>
<p>Update 'col1' to be a required field.</p>
</li>
<li>
<p>This will fail as 'col1' is not being set.</p>
</li>
<li>
<p>Give the column a <code>default literal</code></p>
</li>
<li>
<p>Assert that the default literal was applied to the column.</p>
</li>
<li>
<p>Add a check constraint that check that 'col1' must start with a 't'</p>
</li>
<li>
<p>This will fail as 'col1' does not start with a 't'</p>
</li>
<li>
<p>This will pass the check constraint.</p>
</li>
</ol>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_edgedefinition">12.3. EdgeDefinition</h3>
<div class="listingblock">
<div class="content">
<pre>public record EdgeDefinition(Multiplicity outMultiplicity, Multiplicity inMultiplicity) {}</pre>
</div>
</div>
<div class="paragraph">
<p><code>EdgeDefinition</code> defines the <code>Multiplicity</code> of the in and out edge roles.</p>
</div>
<div class="paragraph">
<p><code>TinkerPop</code> itself has no notion of multiplicity on edges labels. For <code>TinkerPop</code> all edge labels is a many-to-many relationship.
Sqlg extends the semantics by specifying the in and out multiplicity of the edge label.</p>
</div>
<div class="sect3">
<h4 id="_one_to_one">12.3.1. One-to-one</h4>
<div class="paragraph">
<p>One-to-one is implemented by generating a unique index on each of the <code>in</code> and <code>out</code> foreign key columns in the edge table.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-java hljs" data-lang="java">@Test
public void testOneToOne() {
    VertexLabel computerVertexLabel = this.sqlgGraph.getTopology().getPublicSchema().ensureVertexLabelExist("Computer",
            new LinkedHashMap&lt;&gt;() {{
                put("serialNo", PropertyDefinition.of(PropertyType.STRING, Multiplicity.of(1, 1)));
            }}
    );
    VertexLabel cpuVertexLabel = this.sqlgGraph.getTopology().getPublicSchema().ensureVertexLabelExist("Cpu",
            new LinkedHashMap&lt;&gt;() {{
                put("serialNo", PropertyDefinition.of(PropertyType.STRING, Multiplicity.of(1, 1)));
            }}
    );
     computerVertexLabel.ensureEdgeLabelExist(
            "cpu",
            cpuVertexLabel,
            EdgeDefinition.of(
                    Multiplicity.of(1, 1),
                    Multiplicity.of(1, 1)
            )
    ); <b class="conum">(1)</b>
    this.sqlgGraph.tx().commit();
    this.sqlgGraph.getTopology().lock(); <b class="conum">(2)</b>
    Vertex computer1 = this.sqlgGraph.addVertex(T.label, "Computer", "name", "1111");
    Vertex cpu1 = this.sqlgGraph.addVertex(T.label, "Cpu", "name", "aaab");
    Vertex cpu2 = this.sqlgGraph.addVertex(T.label, "Cpu", "name", "aaac");
    computer1.addEdge("cpu", cpu1);
    this.sqlgGraph.tx().commit();
    try {
        computer1.addEdge("cpu", cpu2); <b class="conum">(3)</b>
    } catch (RuntimeException e) {
        if (isPostgres()) {
            Assert.assertTrue(e.getMessage().contains("duplicate key value violates unique constraint"));
        }
    }
    this.sqlgGraph.tx().rollback();
    Vertex computer2 = this.sqlgGraph.addVertex(T.label, "Computer", "name", "2222");
    try {
        computer2.addEdge("cpu", cpu1); <b class="conum">(4)</b>
    } catch (RuntimeException e) {
        if (isPostgres()) {
            Assert.assertTrue(e.getMessage().contains("duplicate key value violates unique constraint"));
        }
    }
    this.sqlgGraph.tx().rollback();
}</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Specified a one-to-one association between Computer and Cpu</p>
</li>
<li>
<p>Lock the topology to ensure no further schema elements are created on the db.</p>
</li>
<li>
<p>Fails as the computer already has a cpu.</p>
</li>
<li>
<p>Fails as the cpu already has a computer.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>The constraints on the edge table.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-sql hljs" data-lang="sql">CREATE UNIQUE INDEX IF NOT EXISTS "E_cpu_public.Computer__O_idx"
    ON public."E_cpu" USING btree
    ("public.Computer__O" ASC NULLS LAST)
    TABLESPACE pg_default;

CREATE UNIQUE INDEX IF NOT EXISTS "E_cpu_public.Cpu__I_idx"
    ON public."E_cpu" USING btree
    ("public.Cpu__I" ASC NULLS LAST)
    TABLESPACE pg_default;</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_one_to_many">12.3.2. One-to-many</h4>
<div class="paragraph">
<p>One-to-many can only be efficiently implemented on the database if the many side is also <code>unique</code>. <code>unique</code> implies set semantics, that no element on the many side will repeat.</p>
</div>
<div class="paragraph">
<p>One-to-many is implemented by generating a unique index over both the <code>in</code> and <code>out</code> foreign key columns in the edge table.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-java hljs" data-lang="java">@Test
public void testOneToMany() {
    VertexLabel personVertexLabel = this.sqlgGraph.getTopology().getPublicSchema().ensureVertexLabelExist("Person",
            new LinkedHashMap&lt;&gt;() {{
                put("name", PropertyDefinition.of(PropertyType.STRING, Multiplicity.of(1, 1)));
            }}
    );
    VertexLabel countryVertexLabel = this.sqlgGraph.getTopology().getPublicSchema().ensureVertexLabelExist("Country",
            new LinkedHashMap&lt;&gt;() {{
                put("name", PropertyDefinition.of(PropertyType.STRING, Multiplicity.of(1, 1)));
            }}
    );
    personVertexLabel.ensureEdgeLabelExist(
            "visited",
            countryVertexLabel,
            EdgeDefinition.of(
                    Multiplicity.of(0, 1),
                    Multiplicity.of(-1, -1, true)
            )
    ); <b class="conum">(1)</b>
    this.sqlgGraph.tx().commit();
    this.sqlgGraph.getTopology().lock();
    Vertex john = this.sqlgGraph.addVertex(T.label, "Person", "name", "John");
    Vertex usa = this.sqlgGraph.addVertex(T.label, "Country", "name", "USA");
    Vertex sa = this.sqlgGraph.addVertex(T.label, "Country", "name", "SA");
    john.addEdge("visited", usa);
    john.addEdge("visited", sa); <b class="conum">(2)</b>
    this.sqlgGraph.tx().commit();
    try {
        john.addEdge("visited", usa); <b class="conum">(3)</b>
    } catch (RuntimeException e) {
        if (isPostgres()) {
            Assert.assertTrue(e.getMessage().contains("duplicate key value violates unique constraint"));
        }
    }
    this.sqlgGraph.tx().rollback();
    Vertex peter = this.sqlgGraph.addVertex(T.label, "Person", "name", "John");
    peter.addEdge("visited", usa); <b class="conum">(4)</b>
    this.sqlgGraph.tx().commit();
}</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Create a one-to-many edge with the many side specified as <code>unique</code>.</p>
</li>
<li>
<p>Add another <code>visited</code> edge to a country.</p>
</li>
<li>
<p>This fails as the john has already 'visited' the 'USA'</p>
</li>
<li>
<p>Peter can visit the 'USA'</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>The constraint on the edge table.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-sql hljs" data-lang="sql">CREATE UNIQUE INDEX IF NOT EXISTS "E_visited_public.Person__O_public.Country__I_idx"
    ON public."E_visited" USING btree
    ("public.Person__O" ASC NULLS LAST, "public.Country__I" ASC NULLS LAST)
    TABLESPACE pg_default;</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_many_to_many_unique">12.3.3. Many-to-many (unique)</h4>
<div class="paragraph">
<p>The database can efficiently check the uniqueness of a many-to-many association. This means that there can be not be more than one edge between any two vertices.</p>
</div>
<div class="paragraph">
<p>many-to-many (unique) is implemented by generating a unique index over both the <code>in</code> and <code>out</code> foreign key columns in the edge table.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-java hljs" data-lang="java">@Test
public void testUniqueManyToMany() {
    VertexLabel personVertexLabel = this.sqlgGraph.getTopology().getPublicSchema().ensureVertexLabelExist("Person",
            new LinkedHashMap&lt;&gt;() {{
                put("name", PropertyDefinition.of(PropertyType.STRING, Multiplicity.of(1, 1)));
            }}
    );
    VertexLabel vehicleVertexLabel = this.sqlgGraph.getTopology().getPublicSchema().ensureVertexLabelExist("Vehicle",
            new LinkedHashMap&lt;&gt;() {{
                put("name", PropertyDefinition.of(PropertyType.STRING, Multiplicity.of(1, 1)));
            }}
    );
    personVertexLabel.ensureEdgeLabelExist(
            "drives",
            vehicleVertexLabel,
            EdgeDefinition.of(
                    Multiplicity.of(-1, -1, true),
                    Multiplicity.of(-1, -1, true)
            )
    ); <b class="conum">(1)</b>
    this.sqlgGraph.tx().commit();
    this.sqlgGraph.getTopology().lock();
    Vertex john = this.sqlgGraph.addVertex(T.label, "Person", "name", "John");
    Vertex peter = this.sqlgGraph.addVertex(T.label, "Person", "name", "Peter");
    Vertex toyota = this.sqlgGraph.addVertex(T.label, "Vehicle", "name", "Toyota");
    Vertex kia = this.sqlgGraph.addVertex(T.label, "Vehicle", "name", "Kia");
    john.addEdge("drives", toyota);
    john.addEdge("drives", kia);
    peter.addEdge("drives", toyota);
    peter.addEdge("drives", kia);
    this.sqlgGraph.tx().commit(); <b class="conum">(2)</b>
    try {
        john.addEdge("drives", toyota); <b class="conum">(3)</b>
    } catch (RuntimeException e) {
        if (isPostgres()) {
            Assert.assertTrue(e.getMessage().contains("duplicate key value violates unique constraint"));
        }
    }
    this.sqlgGraph.tx().rollback();
}</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Create a many-to-many unique edge label.</p>
</li>
<li>
<p>John drives multiple cars and Toyota has multiple drivers.</p>
</li>
<li>
<p>No duplicate edges are allowed.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>The constraint on the edge table.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-sql hljs" data-lang="sql">CREATE UNIQUE INDEX IF NOT EXISTS "E_drives_public.Person__O_public.Vehicle__I_idx"
    ON public."E_drives" USING btree
    ("public.Person__O" ASC NULLS LAST, "public.Vehicle__I" ASC NULLS LAST)
    TABLESPACE pg_default;</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_one_to_many_many_to_many_multiplicity">12.3.4. one-to-many, many-to-many, multiplicity</h4>
<div class="paragraph">
<p>Currently Sqlg does not automatically check the multiplicities as no efficient way of doing it has been found.</p>
</div>
<div class="paragraph">
<p>However sqlg does provide a helper method for application code to call to validate multiplicities. There are two checks the user can call. Either for an individual vertex or for a VertexLabel.</p>
</div>
<div class="sect4">
<h5 id="_1_checkmultiplicity_per_vertex">1 checkMultiplicity (per vertex)</h5>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-java hljs" data-lang="java">@Test
public void testCheckMultiplicitiesPerVertex() {
    VertexLabel personVertexLabel = this.sqlgGraph.getTopology().getPublicSchema().ensureVertexLabelExist("Person",
            new LinkedHashMap&lt;&gt;() {{
                put("name", PropertyDefinition.of(PropertyType.STRING, Multiplicity.of(1, 1)));
            }}
    );
    VertexLabel addressVertexLabel = this.sqlgGraph.getTopology().getPublicSchema().ensureVertexLabelExist("Address",
            new LinkedHashMap&lt;&gt;() {{
                put("name", PropertyDefinition.of(PropertyType.STRING, Multiplicity.of(1, 1)));
            }}
    );
    EdgeLabel personAddressEdgeLabel = personVertexLabel.ensureEdgeLabelExist(
            "address",
            addressVertexLabel,
            EdgeDefinition.of(
                    Multiplicity.of(0, 1, true),
                    Multiplicity.of(1, 3, true)
            )
    ); <b class="conum">(1)</b>
    this.sqlgGraph.tx().commit();
    this.sqlgGraph.getTopology().lock();
    Vertex john = this.sqlgGraph.addVertex(T.label, "Person", "name", "John");
    Vertex peter = this.sqlgGraph.addVertex(T.label, "Person", "name", "peter");
    Vertex johnHomeAddress = this.sqlgGraph.addVertex(T.label, "Address", "name", "home");
    Vertex johnWorkAddress = this.sqlgGraph.addVertex(T.label, "Address", "name", "work");
    Vertex johnVacationAddress = this.sqlgGraph.addVertex(T.label, "Address", "name", "vacation");
    try {
        this.sqlgGraph.tx().checkMultiplicity(john, Direction.OUT, personAddressEdgeLabel, addressVertexLabel);
    } catch (RuntimeException e) {
        if (isPostgres()) {
            assertTrue(e.getMessage().contains("Multiplicity check for EdgeLabel 'address' fails.\n" +
                    "Lower multiplicity is 1 current lower multiplicity is 0"));
        }
    }
    john.addEdge("address", johnHomeAddress);
    john.addEdge("address", johnWorkAddress);
    john.addEdge("address", johnVacationAddress);
    this.sqlgGraph.tx().checkMultiplicity(john, Direction.OUT, personAddressEdgeLabel, addressVertexLabel); <b class="conum">(2)</b>

    peter.addEdge("address", johnHomeAddress);
    boolean fails = false;
    try {
        this.sqlgGraph.tx().checkMultiplicity(johnHomeAddress, Direction.IN, personAddressEdgeLabel, personVertexLabel); <b class="conum">(3)</b>
    } catch (RuntimeException e) {
        fails = true;
        if (isPostgres()) {
            System.out.println(e.getMessage());
            assertTrue(e.getMessage().contains("Multiplicity check for EdgeLabel 'address' fails.\n" +
                    "Upper multiplicity is 1 current upper multiplicity is 2"));
        }
    }
    assertTrue(fails);
    this.sqlgGraph.tx().commit();
}</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>A <code>Person</code> must have at least one <code>Address</code> but no more than three.
An <code>Address</code> can only be associated to zero or one <code>Person</code></p>
</li>
<li>
<p>Check the multiplicity of 'john&#8217;s addresses. It passes as its between 1 and 3.</p>
</li>
<li>
<p>Check that John&#8217;s home address is associated to only on <code>Person</code>. It fails as its also been associated to 'peter'.</p>
</li>
</ol>
</div>
</div>
<div class="sect4">
<h5 id="_2_checkmultiplicity_per_vertexlabel">2 checkMultiplicity (per VertexLabel)</h5>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-java hljs" data-lang="java">@Test
public void testCheckMultiplicitiesPerVertexLabel() {
    VertexLabel personVertexLabel = this.sqlgGraph.getTopology().getPublicSchema().ensureVertexLabelExist("Person",
            new LinkedHashMap&lt;&gt;() {{
                put("name", PropertyDefinition.of(PropertyType.STRING, Multiplicity.of(1, 1)));
            }}
    );
    VertexLabel addressVertexLabel = this.sqlgGraph.getTopology().getPublicSchema().ensureVertexLabelExist("Address",
            new LinkedHashMap&lt;&gt;() {{
                put("name", PropertyDefinition.of(PropertyType.STRING, Multiplicity.of(1, 1)));
            }}
    );
    EdgeLabel personAddressEdgeLabel = personVertexLabel.ensureEdgeLabelExist(
            "address",
            addressVertexLabel,
            EdgeDefinition.of(
                    Multiplicity.of(0, 1, true),
                    Multiplicity.of(1, 3, true)
            )
    );
    this.sqlgGraph.tx().commit();
    this.sqlgGraph.getTopology().lock();
    Vertex john = this.sqlgGraph.addVertex(T.label, "Person", "name", "John");
    Vertex peter = this.sqlgGraph.addVertex(T.label, "Person", "name", "peter");
    Vertex johnHomeAddress = this.sqlgGraph.addVertex(T.label, "Address", "name", "home");
    Vertex johnWorkAddress = this.sqlgGraph.addVertex(T.label, "Address", "name", "work");
    Vertex johnVacationAddress = this.sqlgGraph.addVertex(T.label, "Address", "name", "vacation");
    john.addEdge("address", johnHomeAddress);
    john.addEdge("address", johnWorkAddress);
    john.addEdge("address", johnVacationAddress);
    peter.addEdge("address", johnHomeAddress);

    this.sqlgGraph.tx().checkMultiplicity(personVertexLabel, Direction.OUT, personAddressEdgeLabel, addressVertexLabel);
    boolean fails = false;
    try {
        this.sqlgGraph.tx().checkMultiplicity(addressVertexLabel, Direction.IN, personAddressEdgeLabel, personVertexLabel);
    } catch (RuntimeException e) {
        fails = true;
        if (isPostgres()) {
            System.out.println(e.getMessage());
            String msg = String.format("Multiplicity check for EdgeLabel 'address' fails for '%s'.\nUpper multiplicity is [1] current multiplicity is [2]", johnHomeAddress.id().toString());
            System.out.println(msg);
            assertTrue(e.getMessage().contains(msg));
        }
    }
    assertTrue(fails);
    this.sqlgGraph.tx().commit();
}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_query_the_topology">12.4. Query the topology</h3>
<div class="paragraph">
<p>Sqlg keeps an in-memory cache of the graphs entire topology. It is possible query this cache directly.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-java hljs" data-lang="java">@Test
public void queryCache() {
    loadModern();
    Optional&lt;Schema&gt; publicSchema = this.sqlgGraph.getTopology().getSchema(this.sqlgGraph.getSqlDialect().getPublicSchema()); # <b class="conum">(1)</b>
    assertTrue(publicSchema.isPresent());
    Schema publicSchemaViaShortCut = this.sqlgGraph.getTopology().getPublicSchema(); # <b class="conum">(2)</b>
    Optional&lt;VertexLabel&gt; personVertexLabel = publicSchema.get().getVertexLabel("person"); # <b class="conum">(3)</b>
    assertTrue(personVertexLabel.isPresent());
    Optional&lt;EdgeLabel&gt; createEdgeLabel = personVertexLabel.get().getOutEdgeLabel("created"); # <b class="conum">(4)</b>
    assertTrue(createEdgeLabel.isPresent());
    Optional&lt;EdgeLabel&gt; knowsEdgeLabel = personVertexLabel.get().getOutEdgeLabel("knows"); # <b class="conum">(5)</b>
    assertTrue(knowsEdgeLabel.isPresent());

    Optional&lt;PropertyColumn&gt; namePropertyColumn = personVertexLabel.get().getProperty("name"); # <b class="conum">(6)</b>
    assertTrue(namePropertyColumn.isPresent());
    assertEquals(PropertyType.STRING, namePropertyColumn.get().getPropertyType()); # <b class="conum">(7)</b>
    Optional&lt;PropertyColumn&gt; agePropertyColumn = personVertexLabel.get().getProperty("age");
    assertTrue(agePropertyColumn.isPresent());
    assertEquals(PropertyType.INTEGER, agePropertyColumn.get().getPropertyType());
    Optional&lt;PropertyColumn&gt; weightPropertyColumn = createEdgeLabel.get().getProperty("weight");
    assertTrue(weightPropertyColumn.isPresent());
    assertEquals(PropertyType.DOUBLE, weightPropertyColumn.get().getPropertyType());
}</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Get the 'public' schema object.</p>
</li>
<li>
<p>Because the 'public' schema will always exist there is a shortcut method to get it.</p>
</li>
<li>
<p>Use the 'Schema' object the get the 'person' VertexLabel</p>
</li>
<li>
<p>Use the 'person' VertexLabel to get its 'created' out edge.</p>
</li>
<li>
<p>Use the 'person' VertexLabel to get its 'knows' out edge.</p>
</li>
<li>
<p>Use the 'person' VertexLabel to get its 'name' property. Properties are represented by the <code>PropertyColumn</code> class.</p>
</li>
<li>
<p>On the <code>PropertyColumn</code> object one can get the <code>PropertyType</code>. PropertyType is an enum representing all data types supported by Sqlg.</p>
</li>
</ol>
</div>
</div>
<div class="sect2">
<h3 id="anchor-user-supplied-identifiers">12.5. User supplied identifiers</h3>
<div class="paragraph">
<p>You can define your own identifiers for a VertexLabel or EdgeLabel. This will result in Sqlg generating primary keys on the specified identifiers instead of using an auto generated sequence.</p>
</div>
<div class="listingblock">
<div class="title">eg.</div>
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-java hljs" data-lang="java">@Test
public void testUserSuppliedIds() {
    VertexLabel personVertexLabel = this.sqlgGraph.getTopology().getPublicSchema().ensureVertexLabelExist(
            "Person",
            new LinkedHashMap&lt;&gt;() {{
                put("name", PropertyDefinition.of(PropertyType.STRING));
                put("surname", PropertyDefinition.of(PropertyType.STRING));
                put("nickname", PropertyDefinition.of(PropertyType.STRING));
            }},
            ListOrderedSet.listOrderedSet(Arrays.asList("name", "surname")) # <b class="conum">(1)</b>
    );
    personVertexLabel.ensureEdgeLabelExist(
            "marriedTo",
            personVertexLabel,
            new LinkedHashMap&lt;&gt;() {{
                put("place", PropertyDefinition.of(PropertyType.STRING));
                put("when", PropertyDefinition.of(PropertyType.LOCALDATETIME));
            }},
            ListOrderedSet.listOrderedSet(List.of("place", "when")) # <b class="conum">(2)</b>
    );
    this.sqlgGraph.tx().commit();

    Vertex john = this.sqlgGraph.addVertex(T.label, "Person", "name", "John", "surname", "Longfellow", "nickname", "Longboy");
    Vertex sue = this.sqlgGraph.addVertex(T.label, "Person", "name", "Sue", "surname", "Pretty");
    john.addEdge("marriedTo", sue, "place", "Timbuck2", "when", LocalDateTime.now());
    this.sqlgGraph.tx().commit();

    List&lt;Vertex&gt; marriedTo = this.sqlgGraph.traversal().V().hasLabel("Person")
            .has("name", "John")
            .out("marriedTo")
            .toList();
    Assert.assertEquals(1, marriedTo.size());
    Assert.assertEquals(sue, marriedTo.get(0));
}</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Specify the <code>name</code> and <code>surname</code> properties as the primary key for the <code>Person</code> vertex label.</p>
</li>
<li>
<p>Specify the  <code>place</code> and <code>when</code> properties as the primary key for the <code>marriedTo</code> edge label.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>This will generate a table with <code>name</code> and <code>surname</code>, and <code>place</code> and <code>when</code> as composite primary keys.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-sql hljs" data-lang="sql">CREATE TABLE public."V_Person"
(
    name text COLLATE pg_catalog."default" NOT NULL,
    surname text COLLATE pg_catalog."default" NOT NULL,
    nickname text COLLATE pg_catalog."default",
    CONSTRAINT "V_Person_pkey" PRIMARY KEY (name, surname)
);

CREATE TABLE public."E_marriedTo"
(
    place text COLLATE pg_catalog."default" NOT NULL,
    "when" timestamp without time zone NOT NULL,
    "public.Person.name__I" text COLLATE pg_catalog."default",
    "public.Person.surname__I" text COLLATE pg_catalog."default",
    "public.Person.name__O" text COLLATE pg_catalog."default",
    "public.Person.surname__O" text COLLATE pg_catalog."default",
    CONSTRAINT "E_marriedTo_pkey" PRIMARY KEY (place, "when"),
    CONSTRAINT "E_marriedTo_public.Person.name__I_public.Person.surname__I_fkey" FOREIGN KEY ("public.Person.name__I", "public.Person.surname__I")
        REFERENCES public."V_Person" (name, surname) MATCH SIMPLE
        ON UPDATE NO ACTION
        ON DELETE NO ACTION
        DEFERRABLE,
    CONSTRAINT "E_marriedTo_public.Person.name__O_public.Person.surname__O_fkey" FOREIGN KEY ("public.Person.name__O", "public.Person.surname__O")
        REFERENCES public."V_Person" (name, surname) MATCH SIMPLE
        ON UPDATE NO ACTION
        ON DELETE NO ACTION
        DEFERRABLE
)</code></pre>
</div>
</div>
<div class="paragraph">
<p>The gremlin query will execute the following sql,</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-sql hljs" data-lang="sql">SELECT
	a2."alias1", a2."alias2", a2."alias3"
FROM (
SELECT
	"public"."E_marriedTo"."public.Person.name__I" AS "public.E_marriedTo.public.Person.name__I",
	"public"."E_marriedTo"."public.Person.surname__I" AS "public.E_marriedTo.public.Person.surname__I"
FROM
	"public"."V_Person" INNER JOIN
	"public"."E_marriedTo" ON "public"."V_Person"."name" = "public"."E_marriedTo"."public.Person.name__O" AND "public"."V_Person"."surname" = "public"."E_marriedTo"."public.Person.surname__O"
WHERE
	( "public"."V_Person"."name" = ?)
) a1 INNER JOIN (
SELECT
	"public"."V_Person"."name" AS "alias1",
	"public"."V_Person"."surname" AS "alias2",
	"public"."V_Person"."nickname" AS "alias3"
FROM
	"public"."V_Person"
) a2 ON a1."public.E_marriedTo.public.Person.name__I" = a2."alias1" AND a1."public.E_marriedTo.public.Person.surname__I" = a2."alias2"</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_lock_the_topology">12.6. Lock the topology</h3>
<div class="paragraph">
<p>It is possible to lock the topology. This will prevent any creation of topology elements without explicitly unlocking the topology.
The topology can only be locked globally. However, there are two ways to unlock the topology. Either globally or per transaction.
Unlocking the topology on the transaction unlocks the topology only for the current transaction. This means that globally
the topology remains locked and that other threads (transactions) will not be able to change the topology. To do so they
too will have to first unlock the topology.  There is no need to lock the topology again for the transaction. It will
automatically do so on <code>commit</code> or <code>rollback</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-sql hljs" data-lang="sql">@Test
public void topologyGlobalLockUnlock() {
    this.sqlgGraph.getTopology().lock(); # <b class="conum">(1)</b>
    try {
        this.sqlgGraph.addVertex(T.label, "A"); # <b class="conum">(2)</b>
        Assert.fail("Expected IllegalStateException");
    } catch (IllegalStateException e) {
        //The topology is locked so an IllegalStateException is thrown.
    }
    this.sqlgGraph.getTopology().unlock(); # <b class="conum">(3)</b>
    this.sqlgGraph.addVertex(T.label, "A"); # <b class="conum">(4)</b>
    this.sqlgGraph.tx().commit();
    Assert.assertTrue(this.sqlgGraph.getTopology()
            .getPublicSchema()
            .getVertexLabel("A")
            .isPresent());
}</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Globally lock the topology.</p>
</li>
<li>
<p>Try to create a VertexLabel 'A', it will fail with an <code>IllegalStateException</code> as the topology is locked.</p>
</li>
<li>
<p>Globally unlock the topology.</p>
</li>
<li>
<p>Create a VertexLabel 'A'. This time it will succeed as the topology is not locked.</p>
</li>
</ol>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-sql hljs" data-lang="sql">@Test
public void topologyGlobalLockTransactionUnlock() {
    this.sqlgGraph.getTopology().lock(); # <b class="conum">(1)</b>
    this.sqlgGraph.tx().unlockTopology(); # <b class="conum">(2)</b>
    this.sqlgGraph.addVertex(T.label, "A"); # <b class="conum">(3)</b>
    this.sqlgGraph.tx().commit(); # <b class="conum">(4)</b>
    Assert.assertTrue(this.sqlgGraph.getTopology()
            .getPublicSchema()
            .getVertexLabel("A")
            .isPresent());
}</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Globally lock the topology.</p>
</li>
<li>
<p>Unlock the topology only for the current transaction.</p>
</li>
<li>
<p>Create a VertexLabel 'A'. This will succeed for the current transaction.</p>
</li>
<li>
<p>On commit the <code>unlockTopology</code> is automatically no longer valid.</p>
</li>
</ol>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_postgresql_partitioning">13. Postgresql Partitioning</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Sqlg supports <code>postgresql</code> partitioning. To partition a table it needs to be created upfront using the <code>Topology</code> api.
Sqlg currently supports <code>RANGE</code>, <code>LIST</code> and <code>HASH</code> partitions.
Sub-partitioning is also supported.</p>
</div>
<div class="paragraph">
<div class="title">UML diagram of Sqlg&#8217;s topology.</div>
<p><span class="image"><img src="./img/uml/Package_topology_partitionClassDiagram.PNG" alt="image of Sqlg&#8217;s topology"></span></p>
</div>
<div class="sect2">
<h3 id="_range_partitioning">13.1. Range partitioning</h3>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-java hljs" data-lang="java">@Test
public void testPartitioningRange() {
    Schema publicSchema = this.sqlgGraph.getTopology().getPublicSchema(); # <b class="conum">(1)</b>
    VertexLabel partitionedVertexLabel = publicSchema.ensurePartitionedVertexLabelExist(
            "Measurement",
            new LinkedHashMap&lt;&gt;() {{
                put("date", PropertyDefinition.of(PropertyType.LOCALDATE));
                put("temp", PropertyDefinition.of(PropertyType.INTEGER));
            }},
            ListOrderedSet.listOrderedSet(Collections.singletonList("date")),
            PartitionType.RANGE, #<b class="conum">(2)</b>
            "date"); # <b class="conum">(3)</b>
    partitionedVertexLabel.ensureRangePartitionExists("measurement1", "'2016-07-01'", "'2016-08-01'"); # <b class="conum">(4)</b>
    partitionedVertexLabel.ensureRangePartitionExists("measurement2", "'2016-08-01'", "'2016-09-01'"); # <b class="conum">(5)</b>
    this.sqlgGraph.tx().commit();

    LocalDate localDate1 = LocalDate.of(2016, 7, 1);
    this.sqlgGraph.addVertex(T.label, "Measurement", "date", localDate1);
    LocalDate localDate2 = LocalDate.of(2016, 8, 1);
    this.sqlgGraph.addVertex(T.label, "Measurement", "date", localDate2);
    this.sqlgGraph.tx().commit();

    Assert.assertEquals(2, this.sqlgGraph.traversal().V().hasLabel("Measurement").count().next(), 0);
    Assert.assertEquals(1, this.sqlgGraph.traversal().V().hasLabel("Measurement").has("date", localDate1).count().next(), 0);
    Assert.assertEquals(1, this.sqlgGraph.traversal().V().hasLabel("Measurement").has("date", localDate2).count().next(), 0);

    Partition partition = this.sqlgGraph.getTopology().getPublicSchema().getVertexLabel("Measurement").get().getPartition("measurement1").get(); # <b class="conum">(6)</b>
    partition.remove(); # <b class="conum">(7)</b>
    this.sqlgGraph.tx().commit();

    Assert.assertEquals(1, this.sqlgGraph.traversal().V().hasLabel("Measurement").count().next(), 0);
    Assert.assertEquals(0, this.sqlgGraph.traversal().V().hasLabel("Measurement").has("date", localDate1).count().next(), 0);
    Assert.assertEquals(1, this.sqlgGraph.traversal().V().hasLabel("Measurement").has("date", localDate2).count().next(), 0);

    Assert.assertEquals(1, this.sqlgGraph.topology().V().hasLabel(Topology.SQLG_SCHEMA + "." + Topology.SQLG_SCHEMA_PARTITION).count().next(), 0); # <b class="conum">(8)</b>
}</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Get the 'public' schema object.</p>
</li>
<li>
<p>Indicates a <code>RANGE</code> partition.</p>
</li>
<li>
<p>Create a <code>VertexLabel</code> with a range partition on the <code>date</code> field.</p>
</li>
<li>
<p>Create a named partition for the range '2016-07-01' to '2016-08-01'.</p>
</li>
<li>
<p>Create a named partition for the range '2016-08-01' to '2016-09-01'.</p>
</li>
<li>
<p>Using the <code>Topology</code> api get the <code>measurement1</code> partition.</p>
</li>
<li>
<p>Remove the <code>measurement1</code> partition.</p>
</li>
<li>
<p>Assert that `Sqlg`s topology only has one partition.</p>
</li>
</ol>
</div>
</div>
<div class="sect2">
<h3 id="_list_partitioning">13.2. List partitioning</h3>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-java hljs" data-lang="java">//the partitionExpression 'left(lower(name), 1)' is to complex for the query planner to optimize.
//i.e. select * from Cities where name = 'asdasd' willscan all partitions.
@Test
public void testPartitioningList() {
    Schema publicSchema = this.sqlgGraph.getTopology().getPublicSchema();
    VertexLabel partitionedVertexLabel = publicSchema.ensurePartitionedVertexLabelExist("Cities",
            new LinkedHashMap&lt;&gt;() {{
                put("name", PropertyDefinition.of(PropertyType.STRING));
                put("population", PropertyDefinition.of(PropertyType.LONG));
            }},
            ListOrderedSet.listOrderedSet(Collections.singletonList("name")),
            PartitionType.LIST, # <b class="conum">(1)</b>
            "left(lower(name), 1)"); # <b class="conum">(2)</b>
    partitionedVertexLabel.ensureListPartitionExists("Cities_a", "'a'"); # <b class="conum">(3)</b>
    partitionedVertexLabel.ensureListPartitionExists("Cities_b", "'b'");
    partitionedVertexLabel.ensureListPartitionExists("Cities_c", "'c'");
    partitionedVertexLabel.ensureListPartitionExists("Cities_d", "'d'");
    this.sqlgGraph.tx().commit();

    this.sqlgGraph.tx().normalBatchModeOn();
    for (int i = 0; i &lt; 100; i++) {
        this.sqlgGraph.addVertex(T.label, "Cities", "name", "aasbc", "population", 1000L);
    }
    this.sqlgGraph.addVertex(T.label, "Cities", "name", "basbc", "population", 1000L);
    for (int i = 0; i &lt; 100; i++) {
        this.sqlgGraph.addVertex(T.label, "Cities", "name", "casbc", "population", 1000L);
    }
    this.sqlgGraph.addVertex(T.label, "Cities", "name", "dasbc", "population", 1000L);
    this.sqlgGraph.tx().commit();

    Assert.assertEquals(202, this.sqlgGraph.traversal().V().hasLabel("Cities").count().next(), 0);
    Assert.assertEquals(100, this.sqlgGraph.traversal().V().hasLabel("Cities").has("name", "aasbc").count().next(), 0);
    Assert.assertEquals(1, this.sqlgGraph.traversal().V().hasLabel("Cities").has("name", "basbc").count().next(), 0);
    Assert.assertEquals(100, this.sqlgGraph.traversal().V().hasLabel("Cities").has("name", "casbc").count().next(), 0);

    Partition partition = this.sqlgGraph.getTopology().getPublicSchema().getVertexLabel("Cities").get().getPartition("Cities_a").get();
    partition.remove();
    this.sqlgGraph.tx().commit();

    Assert.assertEquals(102, this.sqlgGraph.traversal().V().hasLabel("Cities").count().next(), 0);
    Assert.assertEquals(3, this.sqlgGraph.topology().V().hasLabel(Topology.SQLG_SCHEMA + "." + Topology.SQLG_SCHEMA_PARTITION).count().next(), 0);
}</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Indicates a <code>LIST</code> partition.</p>
</li>
<li>
<p>The partition expression.</p>
</li>
<li>
<p>Create a named partition for the list entry 'a'.</p>
</li>
</ol>
</div>
</div>
<div class="sect2">
<h3 id="_hash_partitioning">13.3. Hash partitioning</h3>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-java hljs" data-lang="java">@Test
public void testPartitioningHash() {
        VertexLabel vertexLabel = this.sqlgGraph.getTopology().getPublicSchema().ensurePartitionedVertexLabelExist(
                "A",
                new LinkedHashMap&lt;&gt;() {{
                    put("uid1", PropertyDefinition.of(PropertyType.INTEGER));
                    put("name", PropertyDefinition.of(PropertyType.STRING));
                    put("surname", PropertyDefinition.of(PropertyType.STRING));
                }},
                ListOrderedSet.listOrderedSet(List.of("uid1")),
                PartitionType.HASH, <b class="conum">(1)</b>
                "\"uid1\"" <b class="conum">(2)</b>
        );
        for (int i = 0; i &lt; 10; i++) {
            vertexLabel.ensureHashPartitionExists("hashPartition" + i, 10, i); <b class="conum">(3)</b>
        }
        this.sqlgGraph.tx().commit();
        for (int i = 0; i &lt; 1000; i++) {
            this.sqlgGraph.addVertex(T.label, "A", "uid1", i, "name", "name" + i, "surname", "surname" + i);
        }
        this.sqlgGraph.tx().commit();
        Assert.assertEquals(1000, this.sqlgGraph.traversal().V().hasLabel("A").count().next(), 0);

        Connection connection = this.sqlgGraph.tx().getConnection();
        try (Statement s = connection.createStatement()) {
            ResultSet rs = s.executeQuery("select tableoid::regclass as partition_name, count(*) from \"V_A\" group by 1 order by 1;"); <b class="conum">(4)</b>
            int count = 0;
            Map&lt;String, Long&gt; partitionDistributionCount = new HashMap&lt;&gt;();
            while (rs.next()) {
                count++;
                partitionDistributionCount.put(rs.getString(1), rs.getLong(2));
            }
            Assert.assertEquals(10, count); <b class="conum">(5)</b>
            Assert.assertEquals(10, partitionDistributionCount.size());
            for (int i = 0; i &lt; 10; i++) {
                Assert.assertTrue(partitionDistributionCount.containsKey("\"hashPartition" + i + "\""));
            }
            Assert.assertEquals(100, partitionDistributionCount.get("\"hashPartition0\""), 0);
            Assert.assertEquals(92, partitionDistributionCount.get("\"hashPartition1\""), 0);
            Assert.assertEquals(103, partitionDistributionCount.get("\"hashPartition2\""), 0);
            Assert.assertEquals(88, partitionDistributionCount.get("\"hashPartition3\""), 0);
            Assert.assertEquals(113, partitionDistributionCount.get("\"hashPartition4\""), 0);
            Assert.assertEquals(90, partitionDistributionCount.get("\"hashPartition5\""), 0);
            Assert.assertEquals(119, partitionDistributionCount.get("\"hashPartition6\""), 0);
            Assert.assertEquals(92, partitionDistributionCount.get("\"hashPartition7\""), 0);
            Assert.assertEquals(100, partitionDistributionCount.get("\"hashPartition8\""), 0);
            Assert.assertEquals(103, partitionDistributionCount.get("\"hashPartition9\""), 0);
        } catch (SQLException throwables) {
            Assert.fail(throwables.getMessage());
        }

}</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Indicates a <code>HASH</code> partition.</p>
</li>
<li>
<p>The partition expression.</p>
</li>
<li>
<p>Create a named partition for the hash entry with it <code>modulus</code> and <code>remainder</code>.</p>
</li>
<li>
<p>Fetch the partitions for the assertion</p>
</li>
<li>
<p>Assert that there are as many partitions as the <code>modulus</code></p>
</li>
</ol>
</div>
</div>
<div class="sect2">
<h3 id="_sub_partitioning">13.4. Sub partitioning</h3>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-java hljs" data-lang="java">@Test
public void testSubPartition() {
    Schema publicSchema = this.sqlgGraph.getTopology().getPublicSchema();
    VertexLabel partitionedVertexLabel = publicSchema.ensurePartitionedVertexLabelExist(
            "User",
            new LinkedHashMap&lt;&gt;() {{
                put("username", PropertyDefinition.of(PropertyType.STRING));
                put("country", PropertyDefinition.of(PropertyType.STRING));
                put("age", PropertyDefinition.of(PropertyType.INTEGER));
                put("dateOfBirth", PropertyDefinition.of(PropertyType.LOCALDATE));
            }},
            ListOrderedSet.listOrderedSet(List.of("username", "country", "age")),
            PartitionType.LIST,
            "country"); <b class="conum">(1)</b>
    Partition usa = partitionedVertexLabel.ensureListPartitionWithSubPartitionExists("USA", "'USA'", PartitionType.RANGE, "age"); <b class="conum">(2)</b>
    Partition sa = partitionedVertexLabel.ensureListPartitionWithSubPartitionExists("SA", "'SA'", PartitionType.RANGE, "age"); <b class="conum">(3)</b>
    Partition gb = partitionedVertexLabel.ensureListPartitionWithSubPartitionExists("GB", "'GB'", PartitionType.RANGE, "age"); <b class="conum">(4)</b>
    usa.ensureRangePartitionExists("usa0to10", "0", "10"); <b class="conum">(5)</b>
    usa.ensureRangePartitionExists("usa10to20", "10", "20");
    sa.ensureRangePartitionExists("sa0to10", "0", "10");
    sa.ensureRangePartitionExists("sa10to20", "10", "20");
    gb.ensureRangePartitionExists("gb0to10", "0", "10");
    gb.ensureRangePartitionExists("gb10to20", "10", "20");
    this.sqlgGraph.tx().commit();

    LocalDate localDate = LocalDate.now();
    for (int age = 0; age &lt; 20; age++) {
        for (String country : List.of("USA", "SA", "GB")) {
            for (String username : List.of("John", "Peter", "David")) {
                this.sqlgGraph.addVertex(
                        T.label, "User",
                        "username", username,
                        "country", country,
                        "age", age,
                        "dateOfBirth", localDate.minusYears(age)
                );
            }
        }
    }
    this.sqlgGraph.tx().commit();

    List&lt;Vertex&gt; users = this.sqlgGraph.traversal().V()
            .hasLabel("User")
            .has("country", P.eq("USA"))
            .has("age", 5)
            .toList(); <b class="conum">(6)</b>
    Assert.assertEquals(3, users.size());

}</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Create a partitioned VertexLabel.</p>
</li>
<li>
<p>Create a partition for <code>USA</code> and together with a sub-partition on <code>age</code>.</p>
</li>
<li>
<p>Create a partition for <code>SA</code> and together with a sub-partition on <code>age</code>.</p>
</li>
<li>
<p>Create a partition for <code>GB</code> and together with a sub-partition on <code>age</code>.</p>
</li>
<li>
<p>Create an <code>RANGE</code> sub-partition on the <code>age</code> property of the <code>USA</code> partition.</p>
</li>
<li>
<p>The below sql will execute on the relevant partitions.</p>
</li>
</ol>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-sql hljs" data-lang="sql">SELECT
	"public"."V_User"."username" AS "alias1",
	"public"."V_User"."country" AS "alias2",
	"public"."V_User"."age" AS "alias3",
	"public"."V_User"."dateOfBirth" AS "alias4"
FROM
	"public"."V_User"
WHERE
	( "public"."V_User"."country" = 'USA') AND ( "public"."V_User"."age" = 5)</code></pre>
</div>
</div>
<div class="paragraph">
<div class="title">Sub-partition and postgresql explain plan.</div>
<p><span class="image"><img src="./img/sqlg/sub-partitions.png" alt="image of Sqlg&#8217;s topology"></span></p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_postgresql_foreign_data_wrappers">14. Postgresql Foreign Data Wrappers</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Sqlg supports <a href="https://www.postgresql.org/docs/current/postgres-fdw.html">postgres-fdw</a>.
This allows the graph to scale horizontally over multiple databases.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
<div class="ulist">
<ul>
<li>
<p><code>postgres_fdw</code> does not support distributed <a href="https://www.postgresql.org/docs/current/postgres-fdw.html#id-1.11.7.44.14">transactions</a>.</p>
</li>
<li>
<p>It is <strong>not</strong> possible to use <code>SERIAL</code> id fields for inserting data into a remote database via <code>postgres_fdw</code></p>
</li>
<li>
<p>It <strong>is</strong> possible to read <code>VertexLabel(s)</code> and <code>EdgeLabel(s)</code> with a <code>SERIAL</code> id field from a remote database via <code>postgres_fdw</code>.</p>
</li>
</ul>
</div>
</td>
</tr>
</table>
</div>
<div class="sect2">
<h3 id="_how_it_works">14.1. How it works</h3>
<div class="paragraph">
<p>Sqlg imports the foreign graph schema/topology, either complete schemas or a subset of <code>VertexLabel(s)</code> and <code>EdgeLabel(s)</code>
This allows Sqlg to refer to parts of the foreign graph as though it is local.
The rest, postgresql takes care of by forwarding sql statements to the remote server.</p>
</div>
</div>
<div class="sect2">
<h3 id="_prepare">14.2. Prepare</h3>
<div class="paragraph">
<p>The user is responsible to prepare the environment. i.e.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-none hljs">CREATE EXTENSION IF NOT EXISTS postgres_fdw;
CREATE SERVER "sqlgraph_fwd_server" FOREIGN DATA WRAPPER postgres_fdw OPTIONS (host 'localhost', dbname 'sqlgraphdb_fdw', port '5432')
CREATE USER MAPPING FOR postgres SERVER "sqlgraph_fwd_server" OPTIONS (user 'postgres', password 'postgres');</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_import_a_foreign_schema">14.3. Import a foreign schema</h3>
<div class="paragraph">
<p>First we need to create 2 separate graphs pointing to different databases.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
<div class="paragraph">
<p>We are creating the <code>VertexLabel</code> and <code>EdgeLabel</code> using <a href="#anchor-user-supplied-identifiers">identifiers</a> as it is not possible to insert into a <code>SERIAL</code> auto generated primary key.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-java hljs" data-lang="java">@Test
public void testImportForeignSchema() {
    PropertiesConfiguration properties = new PropertiesConfiguration();
    properties.setProperty("jdbc.url", "jdbc:postgresql://localhost:5432/sqlgraphdb");
    properties.setProperty("jdbc.username", "postgres");
    properties.setProperty("jdbc.password", "postgres");
    SqlgGraph sqlgGraph = SqlgGraph.open(properties); <b class="conum">(1)</b>

    PropertiesConfiguration propertiesForeign = new PropertiesConfiguration();
    propertiesForeign.setProperty("jdbc.url", "jdbc:postgresql://localhost:5432/sqlgraphdb_fdw");
    propertiesForeign.setProperty("jdbc.username", "postgres");
    propertiesForeign.setProperty("jdbc.password", "postgres");
    SqlgGraph sqlgGraphForeign = SqlgGraph.open(propertiesForeign); <b class="conum">(2)</b>

    Schema foreignSchemaA = sqlgGraphForeign.getTopology().ensureSchemaExist("A"); <b class="conum">(3)</b>
    VertexLabel aVertexLabel = foreignSchemaA.ensureVertexLabelExist("A", new HashMap&lt;&gt;() {{
                put("ID", PropertyDefinition.of(PropertyType.UUID));
                put("name", PropertyDefinition.of(PropertyType.STRING));
            }},
            ListOrderedSet.listOrderedSet(List.of("ID"))
    ); <b class="conum">(4)</b>
    VertexLabel bVertexLabel = foreignSchemaA.ensureVertexLabelExist("B", new HashMap&lt;&gt;() {{
                put("ID", PropertyDefinition.of(PropertyType.UUID));
                put("name", PropertyDefinition.of(PropertyType.STRING));
            }},
            ListOrderedSet.listOrderedSet(List.of("ID"))
    ); <b class="conum">(5)</b>
    aVertexLabel.ensureEdgeLabelExist("ab", bVertexLabel, new HashMap&lt;&gt;() {{
                put("ID", PropertyDefinition.of(PropertyType.UUID));
                put("name", PropertyDefinition.of(PropertyType.STRING));
            }}, ListOrderedSet.listOrderedSet(Set.of("ID"))
    ); <b class="conum">(6)</b>
    sqlgGraphForeign.tx().commit();

    Connection connection = sqlgGraph.tx().getConnection();
    try (Statement statement = connection.createStatement()) {
        String sql = String.format(
                "CREATE SCHEMA \"%s\";",
                "A"
        ); <b class="conum">(7)</b>
        statement.execute(sql);
        sql = String.format(
                "IMPORT FOREIGN SCHEMA \"%s\" FROM SERVER \"%s\" INTO \"%s\";",
                "A",
                "sqlgraph_fwd_server",
                "A"
        ); <b class="conum">(8)</b>
        statement.execute(sql);
    } catch (SQLException e) {
        Assert.fail(e.getMessage());
    }
    sqlgGraph.tx().commit();
    sqlgGraph.getTopology().importForeignSchemas(Set.of(foreignSchemaA)); <b class="conum">(9)</b>

    Assert.assertTrue(sqlgGraph.getTopology().getSchema("A").isPresent());
    Assert.assertTrue(sqlgGraph.getTopology().getSchema("A").orElseThrow().getVertexLabel("A").isPresent());
    Assert.assertTrue(sqlgGraph.getTopology().getSchema("A").orElseThrow().getVertexLabel("B").isPresent());
    Assert.assertTrue(sqlgGraph.getTopology().getSchema("A").orElseThrow().getEdgeLabel("ab").isPresent()); <b class="conum">(10)</b>

    Vertex aVertex = sqlgGraph.addVertex(T.label, "A.A", "ID", UUID.randomUUID(), "name", "John");
    Vertex bVertex = sqlgGraph.addVertex(T.label, "A.B", "ID", UUID.randomUUID(), "name", "Joe");
    aVertex.addEdge("ab", bVertex, "ID", UUID.randomUUID(), "name", "myEdge");
    sqlgGraph.tx().commit();
    Assert.assertEquals(1L, sqlgGraph.traversal().V()
            .hasLabel("A.A")
            .has("name", P.eq("John"))
            .out("ab")
            .count().next(), 0); <b class="conum">(11)</b>
}</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>A SqlgGraph pointing to <code>sqlgraphdb</code></p>
</li>
<li>
<p>A SqlgGraph pointing to <code>sqlgraphdb_fwd</code></p>
</li>
<li>
<p>Create a <code>Schema</code> <code>A</code> in `sqlgrapdb_fdw</p>
</li>
<li>
<p>Create a <code>VertexLabel</code> <code>A</code> in <code>sqlgraphdb_fdw</code></p>
</li>
<li>
<p>Create a <code>VertexLabel</code> <code>B</code> in <code>sqlgraphdb_fdw</code></p>
</li>
<li>
<p>Create a <code>EdgeLabel</code> <code>ab</code> in <code>sqlgraphdb_fdw</code></p>
</li>
<li>
<p>Create the schema <code>A</code> in <code>sqlgraphdb</code></p>
</li>
<li>
<p>Import the foreign schema <code>A</code> in <code>sqlgraphdb_fdw</code> into <code>A</code> in <code>sqlgraphdb</code></p>
</li>
<li>
<p>Inform SqlgGraph of <code>sqlgraphdb</code> about the foreign elements it can refer to as local.</p>
</li>
<li>
<p>Assert that the foreign schema elements are available to the local SqlgGraph pointing to <code>sqlgraphdb</code>.</p>
</li>
<li>
<p>Insert and query data into <code>sqlgraphdb_fdw</code> using the local SqlgGraph on <code>sqlgraphdb</code></p>
</li>
</ol>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-java hljs" data-lang="java">@Test
public void testImportForeignSchemaWithSERIAL() {
    PropertiesConfiguration properties = new PropertiesConfiguration();
    properties.setProperty("jdbc.url", "jdbc:postgresql://localhost:5432/sqlgraphdb");
    properties.setProperty("jdbc.username", "postgres");
    properties.setProperty("jdbc.password", "postgres");
    SqlgGraph sqlgGraph = SqlgGraph.open(properties); <b class="conum">(1)</b>

    PropertiesConfiguration propertiesForeign = new PropertiesConfiguration();
    propertiesForeign.setProperty("jdbc.url", "jdbc:postgresql://localhost:5432/sqlgraphdb_fdw");
    propertiesForeign.setProperty("jdbc.username", "postgres");
    propertiesForeign.setProperty("jdbc.password", "postgres");
    SqlgGraph sqlgGraphForeign = SqlgGraph.open(propertiesForeign); <b class="conum">(2)</b>

    Schema foreignSchemaA = sqlgGraphForeign.getTopology().ensureSchemaExist("A"); <b class="conum">(3)</b>
    VertexLabel aVertexLabel = foreignSchemaA.ensureVertexLabelExist("A",
            new HashMap&lt;&gt;() {{
                put("name", PropertyDefinition.of(PropertyType.STRING));
            }}
    ); <b class="conum">(4)</b>
    VertexLabel bVertexLabel = foreignSchemaA.ensureVertexLabelExist("B",
            new HashMap&lt;&gt;() {{
                put("name", PropertyDefinition.of(PropertyType.STRING));
            }}
    ); <b class="conum">(5)</b>
    aVertexLabel.ensureEdgeLabelExist("ab", bVertexLabel,
            new HashMap&lt;&gt;() {{
                put("name", PropertyDefinition.of(PropertyType.STRING));
            }}
    ); <b class="conum">(6)</b>
    sqlgGraphForeign.tx().commit();

    Connection connection = sqlgGraph.tx().getConnection();
    try (Statement statement = connection.createStatement()) {
        String sql = String.format(
                "CREATE SCHEMA \"%s\";",
                "A"
        ); <b class="conum">(7)</b>
        statement.execute(sql);
        sql = String.format(
                "IMPORT FOREIGN SCHEMA \"%s\" FROM SERVER \"%s\" INTO \"%s\";",
                "A",
                "sqlgraph_fwd_server",
                "A"
        ); <b class="conum">(8)</b>
        statement.execute(sql);
    } catch (SQLException e) {
        Assert.fail(e.getMessage());
    }
    sqlgGraph.tx().commit();
    sqlgGraph.getTopology().importForeignSchemas(Set.of(foreignSchemaA)); <b class="conum">(9)</b>

    Vertex aVertex = sqlgGraphForeign.addVertex(T.label, "A.A", "name", "John");
    Vertex bVertex = sqlgGraphForeign.addVertex(T.label, "A.B", "name", "Joe");
    aVertex.addEdge("ab", bVertex, "name", "myEdge");
    sqlgGraphForeign.tx().commit(); <b class="conum">(10)</b>

    Assert.assertEquals(1L, sqlgGraph.traversal().V()
            .hasLabel("A.A")
            .has("name", P.eq("John"))
            .out("ab")
            .count().next(), 0); <b class="conum">(11)</b>
}</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>A SqlgGraph pointing to <code>sqlgraphdb</code></p>
</li>
<li>
<p>A SqlgGraph pointing to <code>sqlgraphdb_fwd</code></p>
</li>
<li>
<p>Create a <code>Schema</code> <code>A</code> in `sqlgrapdb_fdw</p>
</li>
<li>
<p>Create a <code>VertexLabel</code> <code>A</code> with a <code>SERIAL</code> id in <code>sqlgraphdb_fdw</code></p>
</li>
<li>
<p>Create a <code>VertexLabel</code> <code>B</code> with a <code>SERIAL</code> id in <code>sqlgraphdb_fdw</code></p>
</li>
<li>
<p>Create a <code>EdgeLabel</code> <code>ab</code> with a <code>SERIAL</code> id in <code>sqlgraphdb_fdw</code></p>
</li>
<li>
<p>Create the schema <code>A</code> in <code>sqlgraphdb</code></p>
</li>
<li>
<p>Import the foreign schema <code>A</code> in <code>sqlgraphdb_fdw</code> into <code>A</code> in <code>sqlgraphdb</code></p>
</li>
<li>
<p>Inform SqlgGraph of <code>sqlgraphdb</code> about the foreign elements it can refer to as local.</p>
</li>
<li>
<p>Insert the data directly into <code>sqlgraphdb_fdw</code></p>
</li>
<li>
<p>Read the data from <code>sqlgraphdb</code> via <code>postgres_fdw</code></p>
</li>
</ol>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_postgresql_pgrouting">15. Postgresql pgRouting</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Sqlg has partial support for <a href="https://docs.pgrouting.org/latest/en/#"><strong>pgRouting</strong></a>.</p>
</div>
<div class="paragraph">
<p><code>pgRouting</code> functions can only be executed on self referencing graph. i.e. where a <code>VertexLabel</code> has an edge to itself.
<code>pgRouting</code> works by querying the in and out vertex ids on the edge table.</p>
</div>
<div class="sect2">
<h3 id="_dijkstra">15.1. Dijkstra</h3>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-java hljs" data-lang="java">    private void loadWikiGraph() {
        VertexLabel vertexLabel = this.sqlgGraph.getTopology().getPublicSchema()
                .ensureVertexLabelExist("wiki", new LinkedHashMap&lt;&gt;() {{
                    put("name", PropertyDefinition.of(PropertyType.STRING, Multiplicity.of(1, 1)));
                    put("_index", PropertyDefinition.of(PropertyType.INTEGER, Multiplicity.of(1, 1)));
                }});
        EdgeLabel edgeLabel = vertexLabel.ensureEdgeLabelExist("connects", vertexLabel,
                new LinkedHashMap&lt;&gt;() {{
                    put("source", PropertyDefinition.of(PropertyType.INTEGER));
                    put("target", PropertyDefinition.of(PropertyType.INTEGER));
                    put("cost", PropertyDefinition.of(PropertyType.DOUBLE, Multiplicity.of(1, 1), "'-1'"));
                    put("reverse_cost", PropertyDefinition.of(PropertyType.DOUBLE, Multiplicity.of(1, 1), "'-1'"));
                }}
        ); #<b class="conum">(1)</b>
        this.sqlgGraph.tx().commit();

        Map&lt;Integer, Vertex&gt; vertexMap = new HashMap&lt;&gt;();
        for (Integer i : List.of(1, 2, 3, 4, 5, 6)) {
            vertexMap.put(i, this.sqlgGraph.addVertex(T.label, "wiki", "name", String.valueOf(i), "_index", i));
        }

        Vertex _1 = vertexMap.get(1);
        Vertex _2 = vertexMap.get(2);
        Vertex _3 = vertexMap.get(3);
        Vertex _4 = vertexMap.get(4);
        Vertex _5 = vertexMap.get(5);
        Vertex _6 = vertexMap.get(6);

        _1.addEdge("connects", _2, "source", 1, "target", 2, "cost", 7D);
        _1.addEdge("connects", _3, "source", 1, "target", 3, "cost", 9D);
        _1.addEdge("connects", _6, "source", 1, "target", 6, "cost", 14D);

        _2.addEdge("connects", _3, "source", 2, "target", 3, "cost", 10D);
        _2.addEdge("connects", _4, "source", 2, "target", 4, "cost", 15D);

        _3.addEdge("connects", _6, "source", 3, "target", 6, "cost", 2D);
        _3.addEdge("connects", _4, "source", 3, "target", 4, "cost", 11D);

        _4.addEdge("connects", _5, "source", 4, "target", 5, "cost", 6D);
        _5.addEdge("connects", _6, "source", 5, "target", 6, "cost", 9D);

        this.sqlgGraph.tx().commit(); #<b class="conum">(2)</b>
    }

    @Test
    public void testDijkstra() {
        loadWikiGraph();
        List&lt;Path&gt; result1 = sqlgGraph.traversal(SqlgTraversalSource.class).E()
                .hasLabel("connects")
                .dijkstra(1L, 5L, false)
                .toList(); #<b class="conum">(3)</b>
    }</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Create the graph&#8217;s topology.</p>
</li>
<li>
<p>Insert the graph.</p>
</li>
<li>
<p>Run the <code>dijkstra</code> step. The result are the shortest paths as calculated using <a href="https://docs.pgrouting.org/latest/en/pgr_bdDijkstra.html#"><strong>pgr_bdDijkstra</strong></a></p>
</li>
</ol>
</div>
<div class="paragraph">
<p>The above <code>dijksta</code> step will result in the following sql being executed.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-sql hljs" data-lang="sql">WITH a AS (
    SELECT * FROM pgr_dijkstra(
    'SELECT a."alias3" as id, a."alias2" as source, a."alias1" as target, a."alias4" as cost, a."alias7" as reverse_cost FROM (
        SELECT
	"public"."E_connects"."public.wiki__O" AS "alias1",
	"public"."E_connects"."public.wiki__I" AS "alias2",
	"public"."E_connects"."ID" AS "alias3",
	"public"."E_connects"."cost" AS "alias4",
	"public"."E_connects"."source" AS "alias5",
	"public"."E_connects"."target" AS "alias6",
	"public"."E_connects"."reverse_cost" AS "alias7"
FROM
	"public"."E_connects"
    ) a', 1, 5, false)
), b AS (
    SELECT * from "public"."V_wiki"
), c AS (
    SELECT * from "public"."E_connects"
)
SELECT c."ID" as edge_id , c."cost", c."source", c."target", c."reverse_cost", c."public.wiki__I", c."public.wiki__O", b."ID" as vertex_id , b."_index", b."name", a."cost" as "traversal_cost", a.agg_cost as "traversal_agg_cost", a.start_vid, a.end_vid FROM
    a JOIN
    b ON a.node = b."ID" LEFT JOIN
    c ON a.edge = c."ID"</code></pre>
</div>
</div>
<div class="paragraph">
<p>Sqlg has support for one to one, one to many, many to one and many to many dijkstra function calls.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-java hljs" data-lang="java">  @Override
  default SqlgTraversal&lt;S, Path&gt; dijkstra(long startVid, long endVid, boolean directed) {
    return (SqlgTraversal) SqlgTraversalDsl.super.dijkstra(startVid,endVid,directed);
  }

  @Override
  default SqlgTraversal&lt;S, Path&gt; dijkstra(List&lt;Long&gt; startVids, List&lt;Long&gt; endVids,
      boolean directed) {
    return (SqlgTraversal) SqlgTraversalDsl.super.dijkstra(startVids,endVids,directed);
  }

  @Override
  default SqlgTraversal&lt;S, Path&gt; dijkstra(long startVid, List&lt;Long&gt; endVids, boolean directed) {
    return (SqlgTraversal) SqlgTraversalDsl.super.dijkstra(startVid,endVids,directed);
  }

  @Override
  default SqlgTraversal&lt;S, Path&gt; dijkstra(List&lt;Long&gt; startVids, long endVid, boolean directed) {
    return (SqlgTraversal) SqlgTraversalDsl.super.dijkstra(startVids,endVid,directed);
  }</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_postgresql_pgvector">16. Postgresql PGVector</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Sqlg supports <a href="https://github.com/pgvector/pgvector#"><strong>pgvector</strong></a>.</p>
</div>
<div class="paragraph">
<p><code>PGVector</code> adds new data types to <code>Sqlg</code>.</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#pgvector">vector</a></p>
</li>
<li>
<p><a href="#pgbit">bit</a></p>
</li>
<li>
<p><a href="#pgsparcvec">sparcvec</a></p>
</li>
<li>
<p><a href="#pghalfvec">halfvec</a></p>
</li>
</ul>
</div>
<div class="sect2">
<h3 id="_data_types_2">16.1. Data types</h3>
<div class="sect3">
<h4 id="pgvector">16.1.1. vector</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-java hljs" data-lang="java">    @Test
    public void testPgVector() {
        this.sqlgGraph.getTopology().getPublicSchema()
                .ensureVertexLabelExist("PGVector", new HashMap&lt;&gt;() {{
                    put("embedding", PropertyDefinition.of(PropertyType.pgvector(3))); #<b class="conum">(1)</b>
                }});
        this.sqlgGraph.tx().commit();
        this.sqlgGraph.addVertex(T.label, "PGVector", "embedding", new PGvector(new float[]{1, 2, 3}));
        this.sqlgGraph.addVertex(T.label, "PGVector", "embedding", new PGvector(new float[]{1, 2, 3}));
        this.sqlgGraph.addVertex(T.label, "PGVector", "embedding", new PGvector(new float[]{1, 2, 3}));
        this.sqlgGraph.addVertex(T.label, "PGVector", "embedding", new PGvector(new float[]{1, 2, 3}));
        this.sqlgGraph.tx().commit();

        List&lt;Vertex&gt; pgvectors = this.sqlgGraph.traversal().V().hasLabel("PGVector").toList();
        Assert.assertEquals(4, pgvectors.size());
        for (Vertex pgvector : pgvectors) {
            PGvector embedding = pgvector.value("embedding");
            Assert.assertArrayEquals(new float[]{1, 2, 3}, embedding.toArray(), 0F);
        }
    }</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Add a column of type <code>pgvector</code> with dimension 3.</p>
</li>
</ol>
</div>
</div>
<div class="sect3">
<h4 id="pgbit">16.1.2. bit</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-java hljs" data-lang="java">    @Test
    public void testPgBit() {
        this.sqlgGraph.getTopology().getPublicSchema()
                .ensureVertexLabelExist("PGVector", new HashMap&lt;&gt;() {{
                    put("embedding", PropertyDefinition.of(PropertyType.pgbit(3))); #<b class="conum">(1)</b>
                }});
        this.sqlgGraph.tx().commit();
        this.sqlgGraph.addVertex(T.label, "PGVector", "embedding", new PGbit(new boolean[]{true, false, true}));
        this.sqlgGraph.addVertex(T.label, "PGVector", "embedding", new PGbit(new boolean[]{true, false, true}));
        this.sqlgGraph.addVertex(T.label, "PGVector", "embedding", new PGbit(new boolean[]{true, false, true}));
        this.sqlgGraph.addVertex(T.label, "PGVector", "embedding", new PGbit(new boolean[]{true, false, true}));
        this.sqlgGraph.tx().commit();

        List&lt;Vertex&gt; pgvectors = this.sqlgGraph.traversal().V().hasLabel("PGVector").toList();
        Assert.assertEquals(4, pgvectors.size());
        for (Vertex pgvector : pgvectors) {
            PGbit embedding = pgvector.value("embedding");
            Assert.assertArrayEquals(new boolean[]{true, false, true}, embedding.toArray());
        }
    }</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Add a column of type <code>pgbit</code> with dimension 3.</p>
</li>
</ol>
</div>
</div>
<div class="sect3">
<h4 id="pghalfvec">16.1.3. halfvec</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-java hljs" data-lang="java">    @Test
    public void testPgHalfvec() {
        this.sqlgGraph.getTopology().getPublicSchema()
                .ensureVertexLabelExist("PGVector", new HashMap&lt;&gt;() {{
                    put("embedding", PropertyDefinition.of(PropertyType.pghalfvec(3))); #<b class="conum">(1)</b>
                }});
        this.sqlgGraph.tx().commit();
        this.sqlgGraph.addVertex(T.label, "PGVector", "embedding", new PGhalfvec(new float[]{1, 2, 3}));
        this.sqlgGraph.addVertex(T.label, "PGVector", "embedding", new PGhalfvec(new float[]{1, 2, 3}));
        this.sqlgGraph.addVertex(T.label, "PGVector", "embedding", new PGhalfvec(new float[]{1, 2, 3}));
        this.sqlgGraph.addVertex(T.label, "PGVector", "embedding", new PGhalfvec(new float[]{1, 2, 3}));
        this.sqlgGraph.tx().commit();

        List&lt;Vertex&gt; pgvectors = this.sqlgGraph.traversal().V().hasLabel("PGVector").toList();
        Assert.assertEquals(4, pgvectors.size());
        for (Vertex pgvector : pgvectors) {
            PGhalfvec embedding = pgvector.value("embedding");
            Assert.assertArrayEquals(new float[]{1, 2, 3}, embedding.toArray(), 0F);
        }
    }</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Add a column of type <code>pghalfvec</code> with dimension 3.</p>
</li>
</ol>
</div>
</div>
<div class="sect3">
<h4 id="pgsparcvec">16.1.4. sparcvec</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-java hljs" data-lang="java">    @Test
    public void testPgSparcvec() {
        this.sqlgGraph.getTopology().getPublicSchema()
                .ensureVertexLabelExist("PGVector", new HashMap&lt;&gt;() {{
                    put("embedding", PropertyDefinition.of(PropertyType.pgsparcvec(3))); #<b class="conum">(1)</b>
                }});
        this.sqlgGraph.tx().commit();
        this.sqlgGraph.addVertex(T.label, "PGVector", "embedding", new PGsparsevec(new float[]{1, 2, 3}));
        this.sqlgGraph.addVertex(T.label, "PGVector", "embedding", new PGsparsevec(new float[]{1, 2, 3}));
        this.sqlgGraph.addVertex(T.label, "PGVector", "embedding", new PGsparsevec(new float[]{1, 2, 3}));
        this.sqlgGraph.addVertex(T.label, "PGVector", "embedding", new PGsparsevec(new float[]{1, 2, 3}));
        this.sqlgGraph.tx().commit();

        List&lt;Vertex&gt; pgvectors = this.sqlgGraph.traversal().V().hasLabel("PGVector").toList();
        Assert.assertEquals(4, pgvectors.size());
        for (Vertex pgvector : pgvectors) {
            PGsparsevec embedding = pgvector.value("embedding");
            Assert.assertArrayEquals(new float[]{1, 2, 3}, embedding.toArray(), 0F);
        }
    }</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Add a column of type <code>pgsparcvec</code> with dimension 3.</p>
</li>
</ol>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_query">16.2. Query</h3>
<div class="paragraph">
<p><code>Sqlg</code> supports pgvector queries.</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#OrderBy">Queries using order by</a></p>
</li>
<li>
<p><a href="#Predicate">Queries using filter predicates</a></p>
</li>
<li>
<p><a href="#Distance">Queries using custom <code>distance</code> step</a></p>
</li>
</ul>
</div>
<div class="sect3">
<h4 id="OrderBy">16.2.1. Queries using order by</h4>
<div class="ulist">
<ul>
<li>
<p><a href="#l2distance">Order by l2distance</a></p>
</li>
<li>
<p><a href="#l1distance">Order by l1distance</a></p>
</li>
<li>
<p><a href="#innerProduct">Order by inner product</a></p>
</li>
<li>
<p><a href="#cosineDistance">Order by cosine distance</a></p>
</li>
<li>
<p><a href="#hammingDistance">Order by hamming distance</a></p>
</li>
</ul>
</div>
<div id="l2distance" class="listingblock">
<div class="title">Order by l2distance</div>
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-java hljs" data-lang="java">    List&lt;Vertex&gt; nearestNeighbours = this.sqlgGraph.traversal().V().hasLabel("PGVector")
            .order().by("embedding", PGVectorOrderByComparator.l2distance(toSearchFor)) #<b class="conum">(1)</b>
            .limit(5)
            .toList();</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Orders the results using the <code>l2distance</code> comparator.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>This will execute the following sql,</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-sql hljs" data-lang="sql">    SELECT
        "public"."V_PGVector"."ID" AS "alias1",
        "public"."V_PGVector"."name" AS "alias2",
        "public"."V_PGVector"."embedding" AS "alias3"
    FROM
        "public"."V_PGVector"
    ORDER BY
         "public"."V_PGVector"."embedding" &lt;-&gt; %s
    LIMIT 5 OFFSET 0</code></pre>
</div>
</div>
<div id="l1distance" class="listingblock">
<div class="title">Order by l1distance</div>
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-java hljs" data-lang="java">    List&lt;Vertex&gt; nearestNeighbours = this.sqlgGraph.traversal().V().hasLabel("PGVector")
            .order().by("embedding", PGVectorOrderByComparator.l1distance(toSearchFor)) #<b class="conum">(1)</b>
            .limit(5)
            .toList();</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Orders the results using the <code>l1distance</code> comparator.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>This will execute the following sql,</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-sql hljs" data-lang="sql">    SELECT
        "public"."V_PGVector"."ID" AS "alias1",
        "public"."V_PGVector"."name" AS "alias2",
        "public"."V_PGVector"."embedding" AS "alias3"
    FROM
        "public"."V_PGVector"
    ORDER BY
         "public"."V_PGVector"."embedding" &lt;+&gt; %s
    LIMIT 5 OFFSET 0</code></pre>
</div>
</div>
<div id="innerProduct" class="listingblock">
<div class="title">Order by inner product</div>
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-java hljs" data-lang="java">    List&lt;Vertex&gt; nearestNeighbours = this.sqlgGraph.traversal().V().hasLabel("PGVector")
            .order().by("embedding", PGVectorOrderByComparator.innerProduct(toSearchFor)) #<b class="conum">(1)</b>
            .limit(5)
            .toList();</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Orders the results using the <code>innerProduct</code> comparator.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>This will execute the following sql,</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-sql hljs" data-lang="sql">    SELECT
        "public"."V_PGVector"."ID" AS "alias1",
        "public"."V_PGVector"."name" AS "alias2",
        "public"."V_PGVector"."embedding" AS "alias3"
    FROM
        "public"."V_PGVector"
    ORDER BY
         ("public"."V_PGVector"."embedding" &lt;#&gt; %s) * -1
    LIMIT 5 OFFSET 0</code></pre>
</div>
</div>
<div id="cosineDistance" class="listingblock">
<div class="title">Order by cosine distance</div>
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-java hljs" data-lang="java">    List&lt;Vertex&gt; nearestNeighbours = this.sqlgGraph.traversal().V().hasLabel("PGVector")
            .order().by("embedding", PGVectorOrderByComparator.cosineDistance(toSearchFor)) #<b class="conum">(1)</b>
            .limit(5)
            .toList();</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Orders the results using the <code>cosineDistance</code> comparator.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>This will execute the following sql,</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-sql hljs" data-lang="sql">    SELECT
        "public"."V_PGVector"."ID" AS "alias1",
        "public"."V_PGVector"."name" AS "alias2",
        "public"."V_PGVector"."embedding" AS "alias3"
    FROM
        "public"."V_PGVector"
    ORDER BY
         1 - ("public"."V_PGVector"."embedding" &lt;=&gt; %s)
    LIMIT 5 OFFSET 0</code></pre>
</div>
</div>
<div id="hammingDistance" class="listingblock">
<div class="title">Order by hamming distance</div>
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-java hljs" data-lang="java">    List&lt;Vertex&gt; nearestNeighbours = this.sqlgGraph.traversal().V().hasLabel("PGVector")
            .order().by("embedding", PGVectorOrderByComparator.hammingDistance(toSearchFor)) #<b class="conum">(1)</b>
            .limit(5)
            .toList();</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Orders the results using the <code>hammingDistance</code> comparator.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>This will execute the following sql,</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-sql hljs" data-lang="sql">    SELECT
        "public"."V_PGVector"."ID" AS "alias1",
        "public"."V_PGVector"."name" AS "alias2",
        "public"."V_PGVector"."embedding" AS "alias3"
    FROM
        "public"."V_PGVector"
    ORDER BY
         "public"."V_PGVector"."embedding" &lt;~&gt; {floatToSearchForAsLiteral}
    LIMIT 5 OFFSET 0</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="Predicate">16.2.2. Queries using filter predicates</h4>
<div class="paragraph">
<p>Sqlg has <code>PGVectorPredicate</code> with various vector based predicates</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#l2DistancePredicate">Filter by l2Distance</a></p>
</li>
<li>
<p><a href="#l1DistancePredicate">Filter by l1Distance</a></p>
</li>
<li>
<p><a href="#innerProductPredicate">Filter by inner product</a></p>
</li>
<li>
<p><a href="#cosineDistancePredicate">Filter by cosine distance</a></p>
</li>
<li>
<p><a href="#hammingDistancePredicate">Filter by hamming distance</a></p>
</li>
</ul>
</div>
<div id="l2DistancePredicate" class="listingblock">
<div class="title">Filter by l2Distance</div>
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-java hljs" data-lang="java">    List&lt;Vertex&gt; nearestNeighbours = this.sqlgGraph.traversal().V().hasLabel("PGVector")
            .has("embedding", PGVectorPredicate.l2Distance(toSearchFor, 5))
            .toList();</code></pre>
</div>
</div>
<div class="paragraph">
<p>This will execute the following sql,</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-sql hljs" data-lang="sql">    SELECT
        "public"."V_PGVector"."ID" AS "alias1",
        "public"."V_PGVector"."name" AS "alias2",
        "public"."V_PGVector"."embedding" AS "alias3"
    FROM
        "public"."V_PGVector"
    WHERE "public"."V_PGVector"."embedding" &lt;-&gt; %s &lt; 5</code></pre>
</div>
</div>
<div id="l1DistancePredicate" class="listingblock">
<div class="title">Filter by l1Distance</div>
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-java hljs" data-lang="java">    List&lt;Vertex&gt; nearestNeighbours = this.sqlgGraph.traversal().V().hasLabel("PGVector")
            .has("embedding", PGVectorPredicate.l1Distance(toSearchFor, 5))
            .toList();</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-sql hljs" data-lang="sql">    SELECT
        "public"."V_PGVector"."ID" AS "alias1",
        "public"."V_PGVector"."name" AS "alias2",
        "public"."V_PGVector"."embedding" AS "alias3"
    FROM
        "public"."V_PGVector"
    WHERE "public"."V_PGVector"."embedding" &lt;+&gt; %s &lt; 5</code></pre>
</div>
</div>
<div id="innerProductPredicate" class="listingblock">
<div class="title">Filter by inner product</div>
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-java hljs" data-lang="java">            List&lt;Vertex&gt; nearestNeighbours = this.sqlgGraph.traversal().V().hasLabel("PGVector")
                    .has("embedding", PGVectorPredicate.innerProduct(toSearchFor, 5))
                    .toList();</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-sql hljs" data-lang="sql">    SELECT
        "public"."V_PGVector"."ID" AS "alias1",
        "public"."V_PGVector"."name" AS "alias2",
        "public"."V_PGVector"."embedding" AS "alias3"
    FROM
        "public"."V_PGVector"
    WHERE ("public"."V_PGVector"."embedding" &lt;#&gt; %s) * -1 &lt; 5</code></pre>
</div>
</div>
<div id="cosineDistancePredicate" class="listingblock">
<div class="title">Filter by cosine distance</div>
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-java hljs" data-lang="java">            List&lt;Vertex&gt; nearestNeighbours = this.sqlgGraph.traversal().V().hasLabel("PGVector")
                    .has("embedding", PGVectorPredicate.cosineDistance(toSearchFor, 5))
                    .toList();</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-sql hljs" data-lang="sql">    SELECT
        "public"."V_PGVector"."ID" AS "alias1",
        "public"."V_PGVector"."name" AS "alias2",
        "public"."V_PGVector"."embedding" AS "alias3"
    FROM
        "public"."V_PGVector"
    WHERE (1 - ("public"."V_PGVector"."embedding" &lt;=&gt; %s)) &lt; 5</code></pre>
</div>
</div>
<div id="hammingDistancePredicate" class="listingblock">
<div class="title">Filter by hamming distance</div>
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-java hljs" data-lang="java">    List&lt;Vertex&gt; nearestNeighbours = this.sqlgGraph.traversal().V().hasLabel("PGVector")
            .has("embedding", PGVectorPredicate.hammingDistance(vectorToSearchFor, 5))
            .toList();</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-sql hljs" data-lang="sql">    SELECT
        "public"."V_PGVector"."ID" AS "alias1",
        "public"."V_PGVector"."name" AS "alias2",
        "public"."V_PGVector"."embedding" AS "alias3"
    FROM
        "public"."V_PGVector"
    WHERE ("public"."V_PGVector"."embedding" &lt;~&gt; '%s') &lt; 5</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="Distance">16.2.3. Queries using custom <code>distance</code> step</h4>
<div class="paragraph">
<p>The traveral will return the vertex with an additional <code>distance</code> property added which hold the result of the query.</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#l2distanceDistance">Return vertices using l2distance</a></p>
</li>
<li>
<p><a href="#l1distanceDistance">Return vertices using l1distance</a></p>
</li>
<li>
<p><a href="#innerProductDistance">Return vertices using inner product</a></p>
</li>
<li>
<p><a href="#cosineDistanceDistance">Cosine distance</a></p>
</li>
<li>
<p><a href="#hammingDistanceDistance">Hamming distance</a></p>
</li>
<li>
<p><a href="#jaccardDistanceDistance">Return vertices using jaccard distance</a></p>
</li>
</ul>
</div>
<div id="l2distanceDistance" class="listingblock">
<div class="title">Return vertices using l2distance</div>
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-java hljs" data-lang="java">    this.sqlgGraph.getTopology().getPublicSchema()
            .ensureVertexLabelExist("PGVector", new HashMap&lt;&gt;() {{
                put("name", PropertyDefinition.of(PropertyType.STRING));
                put("embedding", PropertyDefinition.of(PropertyType.pgvector(100)));
            }});
    this.sqlgGraph.tx().commit();
    ...
    List&lt;Vertex&gt; vertices = this.sqlgGraph.traversal().V().hasLabel("PGVector")
            .&lt;Vertex&gt;l2distance(
                    "distance",
                    "embedding",
                    vectorToSearchFor
            )
            .toList();
    for (Vertex vertex : vertices) {
        double l2distance = vertex.value("distance"); #<b class="conum">(1)</b>
    }</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>The l2 distance</p>
</li>
</ol>
</div>
<div id="l1distanceDistance" class="listingblock">
<div class="title">Return vertices using l1distance</div>
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-java hljs" data-lang="java">    this.sqlgGraph.getTopology().getPublicSchema()
            .ensureVertexLabelExist("PGVector", new HashMap&lt;&gt;() {{
                put("name", PropertyDefinition.of(PropertyType.STRING));
                put("embedding", PropertyDefinition.of(PropertyType.pgvector(100)));
            }});
    ...
    List&lt;Vertex&gt; vertices = this.sqlgGraph.traversal().V().hasLabel("PGVector")
            .&lt;Vertex&gt;l1distance(
                    "distance",
                    "embedding",
                    vectorToSearchFor
            )
            .toList();
    for (Vertex vertex : vertices) {
        double l1distance = vertex.value("distance"); #<b class="conum">(1)</b>
    }</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>The l1 distance</p>
</li>
</ol>
</div>
<div id="innerProductDistance" class="listingblock">
<div class="title">Return vertices using inner product</div>
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-java hljs" data-lang="java">    this.sqlgGraph.getTopology().getPublicSchema()
            .ensureVertexLabelExist("PGVector", new HashMap&lt;&gt;() {{
                put("name", PropertyDefinition.of(PropertyType.STRING));
                put("embedding", PropertyDefinition.of(PropertyType.pgvector(100)));
            }});
    ...
    List&lt;Vertex&gt; vertices = this.sqlgGraph.traversal().V().hasLabel("PGVector")
            .&lt;Vertex&gt;innerProduct(
                    "distance",
                    "embedding",
                    vectorToSearchFor
            )
            .toList();
    for (Vertex vertex : vertices) {
        double innerProductDistance = vertex.value("distance"); #<b class="conum">(1)</b>
    }</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>The inner product distance</p>
</li>
</ol>
</div>
<div id="cosineDistanceDistance" class="listingblock">
<div class="title">Cosine distance</div>
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-java hljs" data-lang="java">    this.sqlgGraph.getTopology().getPublicSchema()
            .ensureVertexLabelExist("PGVector", new HashMap&lt;&gt;() {{
                put("name", PropertyDefinition.of(PropertyType.STRING));
                put("embedding", PropertyDefinition.of(PropertyType.pgvector(100)));
            }});
    ...
    List&lt;Vertex&gt; vertices = this.sqlgGraph.traversal().V().hasLabel("PGVector")
            .&lt;Vertex&gt;cosineDistance(
                    "distance",
                    "embedding",
                    vectorToSearchFor
            )
            .toList();
    for (Vertex vertex : vertices) {
        double cosineDistance = vertex.value("distance"); #<b class="conum">(1)</b>
    }</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>The cosine distance</p>
</li>
</ol>
</div>
<div id="hammingDistanceDistance" class="listingblock">
<div class="title">Hamming distance</div>
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-java hljs" data-lang="java">    this.sqlgGraph.getTopology().getPublicSchema()
            .ensureVertexLabelExist("PGVector", new HashMap&lt;&gt;() {{
                put("name", PropertyDefinition.of(PropertyType.STRING));
                put("embedding", PropertyDefinition.of(PropertyType.pgbit(dimension)));
            }});
    ...
    List&lt;Vertex&gt; vertices = this.sqlgGraph.traversal().V().hasLabel("PGVector")
            .&lt;Vertex&gt;hammingDistance(
                    "distance",
                    "embedding",
                    vectorToSearchFor
            )
            .toList();
    for (Vertex vertex : vertices) {
        double hammingDistance = vertex.value("distance"); #<b class="conum">(1)</b>
    }</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>The hamming distance</p>
</li>
</ol>
</div>
<div id="jaccardDistanceDistance" class="listingblock">
<div class="title">Return vertices using jaccard distance</div>
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-java hljs" data-lang="java">    this.sqlgGraph.getTopology().getPublicSchema()
            .ensureVertexLabelExist("PGVector", new HashMap&lt;&gt;() {{
                put("name", PropertyDefinition.of(PropertyType.STRING));
                put("embedding", PropertyDefinition.of(PropertyType.pgbit(dimension)));
            }});
    ...
    List&lt;Vertex&gt; vertices = this.sqlgGraph.traversal().V().hasLabel("PGVector")
            .&lt;Vertex&gt;jaccardDistance(
                    "distance",
                    "embedding",
                    vectorToSearchFor
            )
            .toList();
    for (Vertex vertex : vertices) {
        double jaccardDistance = vertex.value("distance"); #<b class="conum">(1)</b>
    }</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>The jaccard distance</p>
</li>
</ol>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_gremlin_server">17. Gremlin server</h2>
<div class="sectionbody">
<div class="paragraph">
<p>As sqlg implements TinkerPop you can access it via gremlin server.</p>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<div class="title">Warning</div>
</td>
<td class="content">
At present non of Sqlg&#8217;s custom features are available via gremlin server.
i.e. No batch mode and no postgresql partitions.
</td>
</tr>
</table>
</div>
<div class="sect2">
<h3 id="_minimal_config">17.1. Minimal config</h3>
<div class="paragraph">
<p>gremlin-server-min.yaml</p>
</div>
<div class="listingblock">
<div class="content">
<pre>host: localhost
port: 8182
graphs: {
  graph: src/test/resources/conf/sqlg.properties}
scriptEngines: {
  gremlin-groovy: {
    plugins: { org.apache.tinkerpop.gremlin.server.jsr223.GremlinServerGremlinPlugin: {},
               org.umlg.sqlg.groovy.plugin.SqlgPostgresGremlinPlugin: {},
               org.apache.tinkerpop.gremlin.jsr223.ScriptFileGremlinPlugin: {files: [src/test/resources/conf/gremlin-server-sqlg-postgres.groovy]} } } }
serializers:
  - { className: org.apache.tinkerpop.gremlin.driver.ser.GraphBinaryMessageSerializerV1, config: { ioRegistries: [org.umlg.sqlg.structure.SqlgIoRegistryV3] } }        # application/vnd.graphbinary-v1.0
  - { className: org.apache.tinkerpop.gremlin.driver.ser.GraphSONMessageSerializerV3d0, config: { ioRegistries: [org.umlg.sqlg.structure.SqlgIoRegistryV3] } }        # application/json</pre>
</div>
</div>
<div class="paragraph">
<p>gremlin-server-postgresql.yaml</p>
</div>
<div class="listingblock">
<div class="content">
<pre>host: gremlin-server
port: 8182
evaluationTimeout: 30000
# channelizer: org.apache.tinkerpop.gremlin.server.channel.HttpChannelizer
graphs: {
  graph: /path/to/gremlin-server-sqlg-postgres.properties
}
scriptEngines: {
  gremlin-groovy: {
    plugins: { org.apache.tinkerpop.gremlin.server.jsr223.GremlinServerGremlinPlugin: {},
               org.umlg.sqlg.groovy.plugin.SqlgPostgresGremlinPlugin: {},
               org.apache.tinkerpop.gremlin.groovy.jsr223.GroovyCompilerGremlinPlugin: {enableThreadInterrupt: true},
               org.apache.tinkerpop.gremlin.jsr223.ImportGremlinPlugin: {classImports: [java.lang.Math], methodImports: [java.lang.Math#*]},
               org.apache.tinkerpop.gremlin.jsr223.ScriptFileGremlinPlugin: {files: [/path/to/gremlin-server-sqlg-postgres.groovy]}
    }
  }
}
serializers:
  - { className: org.apache.tinkerpop.gremlin.driver.ser.GryoMessageSerializerV3d0, config: { ioRegistries: [org.apache.tinkerpop.gremlin.tinkergraph.structure.TinkerIoRegistryV3d0] }}            # application/vnd.gremlin-v3.0+gryo
  - { className: org.apache.tinkerpop.gremlin.driver.ser.GryoMessageSerializerV3d0, config: { serializeResultToString: true }}                                                                      # application/vnd.gremlin-v3.0+gryo-stringd
  - { className: org.apache.tinkerpop.gremlin.driver.ser.GraphSONMessageSerializerV3d0, config: { ioRegistries: [org.apache.tinkerpop.gremlin.tinkergraph.structure.TinkerIoRegistryV3d0] }}        # application/json
  - { className: org.apache.tinkerpop.gremlin.driver.ser.GraphBinaryMessageSerializerV1 }                                                                                                           # application/vnd.graphbinary-v1.0
  - { className: org.apache.tinkerpop.gremlin.driver.ser.GraphBinaryMessageSerializerV1, config: { serializeResultToString: true }}                                                                 # application/vnd.graphbinary-v1.0-stringd
metrics: {
  consoleReporter: {enabled: false, interval: 180000},
  csvReporter: {enabled: false, interval: 180000, fileName: /tmp/gremlin-server-metrics.csv},
  jmxReporter: {enabled: false},
  slf4jReporter: {enabled: true, interval: 180000}
}
strictTransactionManagement: false
idleConnectionTimeout: 0
keepAliveInterval: 0
maxInitialLineLength: 4096
maxHeaderSize: 8192
maxChunkSize: 8192
maxContentLength: 65536
maxAccumulationBufferComponents: 1024
resultIterationBatchSize: 64</pre>
</div>
</div>
<div class="paragraph">
<p>gremlin-server-postgresql.groovy</p>
</div>
<div class="listingblock">
<div class="content">
<pre>def globals = [:]

globals &lt;&lt; [g : graph.traversal()]</pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_test_suite">18. Test Suite</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_postgresql">18.1. Postgresql</h3>
<div class="paragraph">
<p><a href="postgresql/tests/PostgresAllTest.html" target="\"_blank\"">PostgresAllTest</a></p>
</div>
<div class="paragraph">
<p><a href="postgresql/tests/PostgresFeatureTest.html" target="\"_blank\"">PostgresFeatureTest</a></p>
</div>
<div class="paragraph">
<p><a href="postgresql/tests/SqlgPostgresProcessStanadardTest.html" target="\"_blank\"">SqlgPostgresProcessStanadardTest</a></p>
</div>
<div class="paragraph">
<p><a href="postgresql/tests/SqlgPostgresStructureStandardTest.html" target="\"_blank\"">SqlgPostgresStructureStandardTest</a></p>
</div>
</div>
<div class="sect2">
<h3 id="_hsqldb">18.2. Hsqldb</h3>
<div class="paragraph">
<p><a href="hsqldb/tests/HsqldbAllTest.html" target="\"_blank\"">HsqldbAllTest</a></p>
</div>
<div class="paragraph">
<p><a href="hsqldb/tests/SqlgHsqldbProcessStandardTest.html" target="\"_blank\"">SqlgHsqldbProcessStandardTest</a></p>
</div>
<div class="paragraph">
<p><a href="hsqldb/tests/SqlgHsqldbStructureStandardTest.html" target="\"_blank\"">SqlgHsqldbStructureStandardTest</a></p>
</div>
</div>
<div class="sect2">
<h3 id="_h2">18.3. H2</h3>
<div class="paragraph">
<p><a href="h2/tests/H2AllTest.html" target="\"_blank\"">H2AllTest</a></p>
</div>
<div class="paragraph">
<p><a href="h2/tests/H2FeatureTest.html" target="\"_blank\"">H2FeatureTest</a></p>
</div>
<div class="paragraph">
<p><a href="h2/tests/SqlgH2ProcessStandardTest.html" target="\"_blank\"">SqlgH2ProcessStandardTest</a></p>
</div>
<div class="paragraph">
<p><a href="h2/tests/SqlgH2StructureStandardTest.html" target="\"_blank\"">SqlgH2StructureStandardTest</a></p>
</div>
</div>
</div>
</div>
</div>
<div id="footer">
<div id="footer-text">
Version 3.1.2<br>
Last updated 2025-06-22 19:00:08 +0200
</div>
</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.18.3/highlight.min.js"></script>
<script>
if (!hljs.initHighlighting.called) {
  hljs.initHighlighting.called = true
  ;[].slice.call(document.querySelectorAll('pre.highlight > code[data-lang]')).forEach(function (el) { hljs.highlightBlock(el) })
}
</script>
<script src="tocbot.min.js"></script>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/tocbot/4.11.1/tocbot.css">
<script>
    var oldtoc = document.getElementById('toctitle').nextElementSibling;
    var newtoc = document.createElement('div');
    newtoc.setAttribute('id', 'tocbot');
    newtoc.setAttribute('class', 'js-toc');
    oldtoc.parentNode.replaceChild(newtoc, oldtoc);
    tocbot.init({contentSelector: '#content', headingSelector: 'h1, h2, h3, h4, h5', smoothScroll: true});
    var handleTocOnResize = function () {
        var width = window.innerWidth || document.documentElement.clientWidth || document.body.clientWidth;
        if (width < 768) {
            tocbot.refresh({
                contentSelector: '#content',
                headingSelector: 'h1, h2, h3, h4, h5',
                collapseDepth: 6,
                activeLinkClass: 'ignoreactive',
                throttleTimeout: 1000,
                smoothScroll: false
            });
        } else {
            tocbot.refresh({
                contentSelector: '#content',
                headingSelector: 'h1, h2, h3, h4, h5',
                smoothScroll: false
            });
        }
    };
    window.addEventListener('resize', handleTocOnResize);
    handleTocOnResize();
</script>

</body>
</html>