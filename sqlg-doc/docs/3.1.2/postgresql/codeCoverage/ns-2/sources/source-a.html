


<!DOCTYPE html>
<html id="htmlId">
<head>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8"> 
  <title>Coverage Report > TestBatchNormalUpdate</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope:     <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">org.umlg.sqlg.test.batch</a>
</div>

<h1>Coverage Summary for Class: TestBatchNormalUpdate (org.umlg.sqlg.test.batch)</h1>

<table class="coverageStats">

<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Branch, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">TestBatchNormalUpdate</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (4/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    83.3%
  </span>
  <span class="absValue">
    (5/6)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (21/21)
  </span>
</td>
</tr>
  <tr>
    <td class="name">TestBatchNormalUpdate$1</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (1/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
  </tr>
<tr>
  <td class="name"><strong>Total</strong></td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (5/5)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    83.3%
  </span>
  <span class="absValue">
    (5/6)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (23/23)
  </span>
</td>
</tr>
</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode">&nbsp;package org.umlg.sqlg.test.batch;
&nbsp;
&nbsp;import org.apache.tinkerpop.gremlin.process.traversal.P;
&nbsp;import org.apache.tinkerpop.gremlin.structure.T;
&nbsp;import org.apache.tinkerpop.gremlin.structure.Vertex;
&nbsp;import org.junit.*;
&nbsp;import org.umlg.sqlg.structure.Multiplicity;
&nbsp;import org.umlg.sqlg.structure.PropertyDefinition;
&nbsp;import org.umlg.sqlg.structure.PropertyType;
&nbsp;import org.umlg.sqlg.structure.topology.Schema;
&nbsp;import org.umlg.sqlg.test.BaseTest;
&nbsp;
&nbsp;import java.util.HashMap;
&nbsp;import java.util.List;
&nbsp;
&nbsp;/**
&nbsp; * Date: 2015/12/14
&nbsp; * Time: 8:56 PM
&nbsp; */
<b class="fc">&nbsp;public class TestBatchNormalUpdate extends BaseTest {</b>
&nbsp;
&nbsp;    @BeforeClass
&nbsp;    public static void beforeClass() {
<b class="fc">&nbsp;        BaseTest.beforeClass();</b>
<b class="pc">&nbsp;        if (isPostgres()) {</b>
<b class="fc">&nbsp;            configuration.addProperty(&quot;distributed&quot;, true);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    @Before
&nbsp;    public void beforeTest() {
<b class="fc">&nbsp;        Assume.assumeTrue(this.sqlgGraph.getSqlDialect().supportsBatchMode());</b>
&nbsp;    }
&nbsp;
&nbsp;    @Test
&nbsp;    public void testBatchUpdateBooleanAsString() {
<b class="fc">&nbsp;        Assume.assumeTrue(&quot;Postgres uses a different strategy and happens to work as long as the string literal is correct&quot;, isPostgres());</b>
<b class="fc">&nbsp;        Schema publicSchema = this.sqlgGraph.getTopology().getPublicSchema();</b>
<b class="fc">&nbsp;        publicSchema.ensureVertexLabelExist(&quot;A&quot;, new HashMap&lt;&gt;() {{</b>
<b class="fc">&nbsp;            put(&quot;active&quot;, PropertyDefinition.of(PropertyType.BOOLEAN, Multiplicity.of(1, 1)));</b>
&nbsp;        }});
<b class="fc">&nbsp;        this.sqlgGraph.tx().commit();</b>
&nbsp;
<b class="fc">&nbsp;        for (int i = 0; i &lt; 100; i++) {</b>
<b class="fc">&nbsp;            this.sqlgGraph.addVertex(T.label, &quot;A&quot;, &quot;active&quot;, true);</b>
&nbsp;        }
<b class="fc">&nbsp;        this.sqlgGraph.tx().commit();</b>
<b class="fc">&nbsp;        boolean t = this.sqlgGraph.traversal().V().hasLabel(&quot;A&quot;).&lt;Boolean&gt;values(&quot;active&quot;).toList().get(0);</b>
<b class="fc">&nbsp;        Assert.assertTrue(t);</b>
&nbsp;
<b class="fc">&nbsp;        this.sqlgGraph.tx().normalBatchModeOn();</b>
<b class="fc">&nbsp;        List&lt;Vertex&gt; vertices = this.sqlgGraph.traversal().V().hasLabel(&quot;A&quot;).toList();</b>
<b class="fc">&nbsp;        for (Vertex v : vertices) {</b>
<b class="fc">&nbsp;            v.property(&quot;active&quot;, &quot;false&quot;);</b>
&nbsp;        }
<b class="fc">&nbsp;        this.sqlgGraph.tx().commit();</b>
<b class="fc">&nbsp;        vertices = this.sqlgGraph.traversal().V().hasLabel(&quot;A&quot;).has(&quot;active&quot;, P.eq(true)).toList();</b>
<b class="fc">&nbsp;        Assert.assertTrue(vertices.isEmpty());</b>
&nbsp;    }
&nbsp;
&nbsp;//    @Test
&nbsp;//    public void testUpdateWithCommaInValues() {
&nbsp;//        this.sqlgGraph.tx().normalBatchModeOn();
&nbsp;//        Vertex a1 = this.sqlgGraph.addVertex(T.label, &quot;A&quot;, &quot;name1&quot;, &quot;a1&quot;, &quot;name2&quot;, &quot;a11&quot;, &quot;name3&quot;, &quot;a111&quot;);
&nbsp;//        Vertex a2 = this.sqlgGraph.addVertex(T.label, &quot;A&quot;, &quot;name1&quot;, &quot;a2&quot;, &quot;name2&quot;, &quot;a22&quot;, &quot;name3&quot;, &quot;a222&quot;);
&nbsp;//        this.sqlgGraph.addVertex(T.label, &quot;A&quot;, &quot;name1&quot;, &quot;a3&quot;, &quot;name2&quot;, &quot;a33&quot;, &quot;name3&quot;, &quot;a333&quot;);
&nbsp;//        this.sqlgGraph.tx().commit();
&nbsp;//
&nbsp;//        this.sqlgGraph.tx().normalBatchModeOn();
&nbsp;//        a1.property(&quot;name1&quot;, &quot;a1,a2&quot;);
&nbsp;//        a2.property(&quot;name1&quot;, &quot;a1,a2&quot;);
&nbsp;//        this.sqlgGraph.tx().commit();
&nbsp;//    }
&nbsp;//
&nbsp;//    @Test
&nbsp;//    public void testUpdateWithNullStringValuesAlreadyPresent() throws InterruptedException {
&nbsp;//        this.sqlgGraph.tx().normalBatchModeOn();
&nbsp;//        Vertex a1 = this.sqlgGraph.addVertex(T.label, &quot;A&quot;, &quot;name1&quot;, &quot;a1&quot;, &quot;name2&quot;, &quot;a11&quot;, &quot;name3&quot;, &quot;a111&quot;);
&nbsp;//        Vertex a2 = this.sqlgGraph.addVertex(T.label, &quot;A&quot;, &quot;name1&quot;, &quot;a2&quot;, &quot;name2&quot;, &quot;a22&quot;, &quot;name3&quot;, &quot;a222&quot;);
&nbsp;//        Vertex a3 = this.sqlgGraph.addVertex(T.label, &quot;A&quot;, &quot;name1&quot;, &quot;a3&quot;, &quot;name2&quot;, &quot;a33&quot;, &quot;name3&quot;, &quot;a333&quot;);
&nbsp;//        this.sqlgGraph.tx().commit();
&nbsp;//        this.sqlgGraph.tx().normalBatchModeOn();
&nbsp;//        a1.property(&quot;name1&quot;, &quot;aa1&quot;);
&nbsp;//        a2.property(&quot;name2&quot;, &quot;&#39;aa2&#39;&quot;);
&nbsp;//        a3.property(&quot;name3&quot;, &quot;$token$&quot;);
&nbsp;//        this.sqlgGraph.tx().commit();
&nbsp;//        testUpdateWithNullStringValuesAlreadyPresent_assert(this.sqlgGraph, a1, a2, a3);
&nbsp;//        if (this.sqlgGraph1 != null) {
&nbsp;//            Thread.sleep(SLEEP_TIME);
&nbsp;//            testUpdateWithNullStringValuesAlreadyPresent_assert(this.sqlgGraph, a1, a2, a3);
&nbsp;//        }
&nbsp;//    }
&nbsp;//
&nbsp;//    private void testUpdateWithNullStringValuesAlreadyPresent_assert(SqlgGraph sqlgGraph, Vertex a1, Vertex a2, Vertex a3) {
&nbsp;//        a1 = sqlgGraph.traversal().V(a1.id()).next();
&nbsp;//        a2 = sqlgGraph.traversal().V(a2.id()).next();
&nbsp;//        a3 = sqlgGraph.traversal().V(a3.id()).next();
&nbsp;//
&nbsp;//        Assert.assertEquals(&quot;aa1&quot;, a1.value(&quot;name1&quot;));
&nbsp;//        Assert.assertEquals(&quot;a11&quot;, a1.value(&quot;name2&quot;));
&nbsp;//        Assert.assertEquals(&quot;a111&quot;, a1.value(&quot;name3&quot;));
&nbsp;//
&nbsp;//        Assert.assertEquals(&quot;a2&quot;, a2.value(&quot;name1&quot;));
&nbsp;//        Assert.assertEquals(&quot;&#39;aa2&#39;&quot;, a2.value(&quot;name2&quot;));
&nbsp;//        Assert.assertEquals(&quot;a222&quot;, a2.value(&quot;name3&quot;));
&nbsp;//
&nbsp;//        Assert.assertEquals(&quot;a3&quot;, a3.value(&quot;name1&quot;));
&nbsp;//        Assert.assertEquals(&quot;a33&quot;, a3.value(&quot;name2&quot;));
&nbsp;//        Assert.assertEquals(&quot;$token$&quot;, a3.value(&quot;name3&quot;));
&nbsp;//    }
&nbsp;//
&nbsp;//    @Test
&nbsp;//    public void testUpdateWithNullStringValuesNotAlreadyPresent() throws InterruptedException {
&nbsp;//        this.sqlgGraph.tx().normalBatchModeOn();
&nbsp;//        Vertex a1 = this.sqlgGraph.addVertex(T.label, &quot;A&quot;, &quot;name1&quot;, &quot;a1&quot;);
&nbsp;//        Vertex a2 = this.sqlgGraph.addVertex(T.label, &quot;A&quot;, &quot;name2&quot;, &quot;a2&quot;);
&nbsp;//        Vertex a3 = this.sqlgGraph.addVertex(T.label, &quot;A&quot;, &quot;name3&quot;, &quot;a3&quot;);
&nbsp;//        this.sqlgGraph.tx().commit();
&nbsp;//        this.sqlgGraph.tx().normalBatchModeOn();
&nbsp;//        a1.property(&quot;name1&quot;, &quot;aa1&quot;);
&nbsp;//        a2.property(&quot;name2&quot;, &quot;aa2&quot;);
&nbsp;//        a3.property(&quot;name3&quot;, &quot;aa3&quot;);
&nbsp;//        this.sqlgGraph.tx().commit();
&nbsp;//        testUpdateWithNullStringValuesNotAlreadyPresent_assert(this.sqlgGraph, a1, a2, a3);
&nbsp;//        if (this.sqlgGraph1 != null) {
&nbsp;//            Thread.sleep(SLEEP_TIME);
&nbsp;//            testUpdateWithNullStringValuesNotAlreadyPresent_assert(this.sqlgGraph1, a1, a2, a3);
&nbsp;//        }
&nbsp;//    }
&nbsp;//
&nbsp;//    private void testUpdateWithNullStringValuesNotAlreadyPresent_assert(SqlgGraph sqlgGraph, Vertex a1, Vertex a2, Vertex a3) {
&nbsp;//        Assert.assertNull(sqlgGraph.traversal().V(a1.id()).next().property(&quot;name2&quot;).value());
&nbsp;//        Assert.assertNull(sqlgGraph.traversal().V(a1.id()).next().property(&quot;name3&quot;).value());
&nbsp;//        Assert.assertNull(sqlgGraph.traversal().V(a2.id()).next().property(&quot;name1&quot;).value());
&nbsp;//        Assert.assertNull(sqlgGraph.traversal().V(a2.id()).next().property(&quot;name3&quot;).value());
&nbsp;//        Assert.assertNull(sqlgGraph.traversal().V(a3.id()).next().property(&quot;name1&quot;).value());
&nbsp;//        Assert.assertNull(sqlgGraph.traversal().V(a3.id()).next().property(&quot;name2&quot;).value());
&nbsp;//    }
&nbsp;//
&nbsp;//    @Test
&nbsp;//    public void testUpdateWithNullInteger() throws InterruptedException {
&nbsp;//        this.sqlgGraph.tx().normalBatchModeOn();
&nbsp;//        Vertex a1 = this.sqlgGraph.addVertex(T.label, &quot;A&quot;, &quot;name1&quot;, 1);
&nbsp;//        Vertex a2 = this.sqlgGraph.addVertex(T.label, &quot;A&quot;, &quot;name2&quot;, 2);
&nbsp;//        Vertex a3 = this.sqlgGraph.addVertex(T.label, &quot;A&quot;, &quot;name3&quot;, 3);
&nbsp;//        this.sqlgGraph.tx().commit();
&nbsp;//        this.sqlgGraph.tx().normalBatchModeOn();
&nbsp;//        a1.property(&quot;name1&quot;, 11);
&nbsp;//        a2.property(&quot;name2&quot;, 22);
&nbsp;//        a3.property(&quot;name3&quot;, 33);
&nbsp;//        this.sqlgGraph.tx().commit();
&nbsp;//        testUpdateWithNullInteger_assert(this.sqlgGraph, a1, a2, a3);
&nbsp;//        if (this.sqlgGraph1 != null) {
&nbsp;//            Thread.sleep(SLEEP_TIME);
&nbsp;//            testUpdateWithNullInteger_assert(this.sqlgGraph1, a1, a2, a3);
&nbsp;//        }
&nbsp;//    }
&nbsp;//
&nbsp;//    private void testUpdateWithNullInteger_assert(SqlgGraph sqlgGraph, Vertex a1, Vertex a2, Vertex a3) {
&nbsp;//        Assert.assertNull(sqlgGraph.traversal().V(a1.id()).next().property(&quot;name2&quot;).value());
&nbsp;//        Assert.assertNull(sqlgGraph.traversal().V(a1.id()).next().property(&quot;name3&quot;).value());
&nbsp;//        Assert.assertNull(sqlgGraph.traversal().V(a2.id()).next().property(&quot;name1&quot;).value());
&nbsp;//        Assert.assertNull(sqlgGraph.traversal().V(a2.id()).next().property(&quot;name3&quot;).value());
&nbsp;//        Assert.assertNull(sqlgGraph.traversal().V(a3.id()).next().property(&quot;name1&quot;).value());
&nbsp;//        Assert.assertNull(sqlgGraph.traversal().V(a3.id()).next().property(&quot;name2&quot;).value());
&nbsp;//    }
&nbsp;//
&nbsp;//    @Test
&nbsp;//    public void testUpdateWithoutDots() throws InterruptedException {
&nbsp;//        this.sqlgGraph.tx().normalBatchModeOn();
&nbsp;//        for (int i = 0; i &lt; 4; i++) {
&nbsp;//            this.sqlgGraph.addVertex(T.label, &quot;GTRX&quot;, &quot;test1&quot;, &quot;a1&quot;, &quot;test2&quot;, &quot;a2&quot;, &quot;cm_uid&quot;, &quot;cm_uid_&quot; + i);
&nbsp;//        }
&nbsp;//        this.sqlgGraph.tx().commit();
&nbsp;//        this.sqlgGraph.tx().normalBatchModeOn();
&nbsp;//        GraphTraversalSource gts = this.sqlgGraph.traversal();
&nbsp;//        Vertex cmUid0 = gts.V().hasLabel(&quot;GTRX&quot;).has(&quot;cm_uid&quot;, &quot;cm_uid_0&quot;).next();
&nbsp;//        cmUid0.property(&quot;test1&quot;, &quot;b1&quot;);
&nbsp;//
&nbsp;//        Vertex cmUid1 = gts.V().hasLabel(&quot;GTRX&quot;).has(&quot;cm_uid&quot;, &quot;cm_uid_1&quot;).next();
&nbsp;//        cmUid1.property(&quot;test2&quot;, &quot;b1&quot;);
&nbsp;//
&nbsp;//        Vertex cmUid2 = gts.V().hasLabel(&quot;GTRX&quot;).has(&quot;cm_uid&quot;, &quot;cm_uid_2&quot;).next();
&nbsp;//        cmUid2.property(&quot;test1&quot;, &quot;b1&quot;);
&nbsp;//
&nbsp;//        Vertex cmUid3 = gts.V().hasLabel(&quot;GTRX&quot;).has(&quot;cm_uid&quot;, &quot;cm_uid_3&quot;).next();
&nbsp;//        cmUid3.property(&quot;test2&quot;, &quot;b1&quot;);
&nbsp;//        this.sqlgGraph.tx().commit();
&nbsp;//
&nbsp;//        testUpdateWithoutDots_assert(gts);
&nbsp;//        if (this.sqlgGraph1 != null) {
&nbsp;//            Thread.sleep(SLEEP_TIME);
&nbsp;//            gts = this.sqlgGraph1.traversal();
&nbsp;//            testUpdateWithoutDots_assert(gts);
&nbsp;//        }
&nbsp;//    }
&nbsp;//
&nbsp;//    private void testUpdateWithoutDots_assert(GraphTraversalSource gts) {
&nbsp;//        Assert.assertEquals(&quot;b1&quot;, gts.V().hasLabel(&quot;GTRX&quot;).has(&quot;cm_uid&quot;, &quot;cm_uid_0&quot;).next().value(&quot;test1&quot;));
&nbsp;//        Assert.assertEquals(&quot;a2&quot;, gts.V().hasLabel(&quot;GTRX&quot;).has(&quot;cm_uid&quot;, &quot;cm_uid_0&quot;).next().value(&quot;test2&quot;));
&nbsp;//
&nbsp;//        Assert.assertEquals(&quot;a1&quot;, gts.V().hasLabel(&quot;GTRX&quot;).has(&quot;cm_uid&quot;, &quot;cm_uid_1&quot;).next().value(&quot;test1&quot;));
&nbsp;//        Assert.assertEquals(&quot;b1&quot;, gts.V().hasLabel(&quot;GTRX&quot;).has(&quot;cm_uid&quot;, &quot;cm_uid_1&quot;).next().value(&quot;test2&quot;));
&nbsp;//
&nbsp;//        Assert.assertEquals(&quot;b1&quot;, gts.V().hasLabel(&quot;GTRX&quot;).has(&quot;cm_uid&quot;, &quot;cm_uid_2&quot;).next().value(&quot;test1&quot;));
&nbsp;//        Assert.assertEquals(&quot;a2&quot;, gts.V().hasLabel(&quot;GTRX&quot;).has(&quot;cm_uid&quot;, &quot;cm_uid_2&quot;).next().value(&quot;test2&quot;));
&nbsp;//
&nbsp;//        Assert.assertEquals(&quot;a1&quot;, gts.V().hasLabel(&quot;GTRX&quot;).has(&quot;cm_uid&quot;, &quot;cm_uid_3&quot;).next().value(&quot;test1&quot;));
&nbsp;//        Assert.assertEquals(&quot;b1&quot;, gts.V().hasLabel(&quot;GTRX&quot;).has(&quot;cm_uid&quot;, &quot;cm_uid_3&quot;).next().value(&quot;test2&quot;));
&nbsp;//    }
&nbsp;//
&nbsp;//    @Test
&nbsp;//    public void testUpdateWithDots() throws InterruptedException {
&nbsp;//        this.sqlgGraph.tx().normalBatchModeOn();
&nbsp;//        for (int i = 0; i &lt; 4; i++) {
&nbsp;//            this.sqlgGraph.addVertex(T.label, &quot;GTRX&quot;, &quot;test1&quot;, &quot;a1&quot;, &quot;test.2&quot;, &quot;a2&quot;, &quot;cm_uid&quot;, &quot;cm_uid_&quot; + i);
&nbsp;//        }
&nbsp;//        this.sqlgGraph.tx().commit();
&nbsp;//        this.sqlgGraph.tx().normalBatchModeOn();
&nbsp;//        GraphTraversalSource gts = this.sqlgGraph.traversal();
&nbsp;//        Vertex cmUid0 = gts.V().hasLabel(&quot;GTRX&quot;).has(&quot;cm_uid&quot;, &quot;cm_uid_0&quot;).next();
&nbsp;//        cmUid0.property(&quot;test1&quot;, &quot;b1&quot;);
&nbsp;//
&nbsp;//        Vertex cmUid1 = gts.V().hasLabel(&quot;GTRX&quot;).has(&quot;cm_uid&quot;, &quot;cm_uid_1&quot;).next();
&nbsp;//        cmUid1.property(&quot;test.2&quot;, &quot;b1&quot;);
&nbsp;//
&nbsp;//        Vertex cmUid2 = gts.V().hasLabel(&quot;GTRX&quot;).has(&quot;cm_uid&quot;, &quot;cm_uid_2&quot;).next();
&nbsp;//        cmUid2.property(&quot;test1&quot;, &quot;b1&quot;);
&nbsp;//
&nbsp;//        Vertex cmUid3 = gts.V().hasLabel(&quot;GTRX&quot;).has(&quot;cm_uid&quot;, &quot;cm_uid_3&quot;).next();
&nbsp;//        cmUid3.property(&quot;test.2&quot;, &quot;b1&quot;);
&nbsp;//        this.sqlgGraph.tx().commit();
&nbsp;//
&nbsp;//        testUpdateWithDots_assert(gts);
&nbsp;//        if (this.sqlgGraph1 != null) {
&nbsp;//            Thread.sleep(SLEEP_TIME);
&nbsp;//            gts = this.sqlgGraph1.traversal();
&nbsp;//            testUpdateWithDots_assert(gts);
&nbsp;//        }
&nbsp;//    }
&nbsp;//
&nbsp;//    private void testUpdateWithDots_assert(GraphTraversalSource gts) {
&nbsp;//        Assert.assertEquals(&quot;b1&quot;, gts.V().hasLabel(&quot;GTRX&quot;).has(&quot;cm_uid&quot;, &quot;cm_uid_0&quot;).next().value(&quot;test1&quot;));
&nbsp;//        Assert.assertEquals(&quot;a2&quot;, gts.V().hasLabel(&quot;GTRX&quot;).has(&quot;cm_uid&quot;, &quot;cm_uid_0&quot;).next().value(&quot;test.2&quot;));
&nbsp;//
&nbsp;//        Assert.assertEquals(&quot;a1&quot;, gts.V().hasLabel(&quot;GTRX&quot;).has(&quot;cm_uid&quot;, &quot;cm_uid_1&quot;).next().value(&quot;test1&quot;));
&nbsp;//        Assert.assertEquals(&quot;b1&quot;, gts.V().hasLabel(&quot;GTRX&quot;).has(&quot;cm_uid&quot;, &quot;cm_uid_1&quot;).next().value(&quot;test.2&quot;));
&nbsp;//
&nbsp;//        Assert.assertEquals(&quot;b1&quot;, gts.V().hasLabel(&quot;GTRX&quot;).has(&quot;cm_uid&quot;, &quot;cm_uid_2&quot;).next().value(&quot;test1&quot;));
&nbsp;//        Assert.assertEquals(&quot;a2&quot;, gts.V().hasLabel(&quot;GTRX&quot;).has(&quot;cm_uid&quot;, &quot;cm_uid_2&quot;).next().value(&quot;test.2&quot;));
&nbsp;//
&nbsp;//        Assert.assertEquals(&quot;a1&quot;, gts.V().hasLabel(&quot;GTRX&quot;).has(&quot;cm_uid&quot;, &quot;cm_uid_3&quot;).next().value(&quot;test1&quot;));
&nbsp;//        Assert.assertEquals(&quot;b1&quot;, gts.V().hasLabel(&quot;GTRX&quot;).has(&quot;cm_uid&quot;, &quot;cm_uid_3&quot;).next().value(&quot;test.2&quot;));
&nbsp;//    }
&nbsp;//
&nbsp;//    @Test
&nbsp;//    public void testUpdateArrays() throws InterruptedException {
&nbsp;//        Assume.assumeTrue(this.sqlgGraph.getSqlDialect().supportsFloatArrayValues());
&nbsp;//        this.sqlgGraph.tx().normalBatchModeOn();
&nbsp;//        Vertex v = this.sqlgGraph.addVertex(T.label, &quot;Person&quot;,
&nbsp;//                &quot;names&quot;, new String[]{&quot;A&quot;, &quot;B&quot;},
&nbsp;//                &quot;integers&quot;, new int[]{1, 2},
&nbsp;//                &quot;booleans&quot;, new boolean[]{true, true},
&nbsp;//                &quot;doubles&quot;, new double[]{1D, 2D},
&nbsp;//                &quot;longs&quot;, new long[]{1L, 2L},
&nbsp;//                &quot;floats&quot;, new float[]{1F, 2F},
&nbsp;//                &quot;shorts&quot;, new short[]{1, 2},
&nbsp;//                &quot;bytes&quot;, new byte[]{1, 2}
&nbsp;//        );
&nbsp;//        this.sqlgGraph.tx().commit();
&nbsp;//        Assert.assertTrue(this.sqlgGraph.traversal().V().hasLabel(&quot;Person&quot;).hasNext());
&nbsp;//        Assert.assertNotNull(this.sqlgGraph.traversal().V().hasLabel(&quot;Person&quot;).next().property(&quot;names&quot;).value());
&nbsp;//        Assert.assertArrayEquals(new String[]{&quot;A&quot;, &quot;B&quot;}, this.sqlgGraph.traversal().V().hasLabel(&quot;Person&quot;).next().&lt;String[]&gt;value(&quot;names&quot;));
&nbsp;//        Assert.assertArrayEquals(new byte[]{1, 2}, this.sqlgGraph.traversal().V().hasLabel(&quot;Person&quot;).next().value(&quot;bytes&quot;));
&nbsp;//        this.sqlgGraph.tx().normalBatchModeOn();
&nbsp;//        v.property(&quot;names&quot;, new String[]{&quot;C&quot;, &quot;D&quot;});
&nbsp;//        v.property(&quot;integers&quot;, new int[]{3, 4});
&nbsp;//        v.property(&quot;booleans&quot;, new boolean[]{false, false});
&nbsp;//        v.property(&quot;doubles&quot;, new double[]{3D, 4D});
&nbsp;//        v.property(&quot;longs&quot;, new long[]{3L, 4L});
&nbsp;//        v.property(&quot;floats&quot;, new float[]{3F, 4F});
&nbsp;//        v.property(&quot;shorts&quot;, new short[]{3, 4});
&nbsp;//        v.property(&quot;bytes&quot;, new byte[]{3, 4});
&nbsp;//        this.sqlgGraph.tx().commit();
&nbsp;//        testUpdateArrays_assert(this.sqlgGraph);
&nbsp;//        if (this.sqlgGraph1 != null) {
&nbsp;//            Thread.sleep(SLEEP_TIME);
&nbsp;//            testUpdateArrays_assert(this.sqlgGraph1);
&nbsp;//        }
&nbsp;//    }
&nbsp;//
&nbsp;//    private void testUpdateArrays_assert(SqlgGraph sqlgGraph) {
&nbsp;//        Assert.assertArrayEquals(new String[]{&quot;C&quot;, &quot;D&quot;}, sqlgGraph.traversal().V().hasLabel(&quot;Person&quot;).next().&lt;String[]&gt;value(&quot;names&quot;));
&nbsp;//        Assert.assertArrayEquals(new int[]{3, 4}, sqlgGraph.traversal().V().hasLabel(&quot;Person&quot;).next().value(&quot;integers&quot;));
&nbsp;//        Assert.assertArrayEquals(new boolean[]{false, false}, sqlgGraph.traversal().V().hasLabel(&quot;Person&quot;).next().value(&quot;booleans&quot;));
&nbsp;//        Assert.assertArrayEquals(new double[]{3D, 4D}, sqlgGraph.traversal().V().hasLabel(&quot;Person&quot;).next().value(&quot;doubles&quot;), 0d);
&nbsp;//        Assert.assertArrayEquals(new long[]{3L, 4L}, sqlgGraph.traversal().V().hasLabel(&quot;Person&quot;).next().value(&quot;longs&quot;));
&nbsp;//        Assert.assertArrayEquals(new float[]{3F, 4F}, sqlgGraph.traversal().V().hasLabel(&quot;Person&quot;).next().value(&quot;floats&quot;), 0f);
&nbsp;//        Assert.assertArrayEquals(new short[]{3, 4}, sqlgGraph.traversal().V().hasLabel(&quot;Person&quot;).next().value(&quot;shorts&quot;));
&nbsp;//        Assert.assertArrayEquals(new byte[]{3, 4}, sqlgGraph.traversal().V().hasLabel(&quot;Person&quot;).next().value(&quot;bytes&quot;));
&nbsp;//    }
&nbsp;//
&nbsp;//    @Test
&nbsp;//    public void testUpdateArraysNoFloats() throws InterruptedException {
&nbsp;//        Assume.assumeTrue(!this.sqlgGraph.getSqlDialect().isMariaDb() &amp;&amp; !this.sqlgGraph.getSqlDialect().isMssqlServer());
&nbsp;//        this.sqlgGraph.tx().normalBatchModeOn();
&nbsp;//        Vertex v = this.sqlgGraph.addVertex(T.label, &quot;Person&quot;,
&nbsp;//                &quot;names&quot;, new String[]{&quot;A&quot;, &quot;B&quot;},
&nbsp;//                &quot;integers&quot;, new int[]{1, 2},
&nbsp;//                &quot;booleans&quot;, new boolean[]{true, true},
&nbsp;//                &quot;doubles&quot;, new double[]{1D, 2D},
&nbsp;//                &quot;longs&quot;, new long[]{1L, 2L},
&nbsp;//                &quot;shorts&quot;, new short[]{1, 2},
&nbsp;//                &quot;bytes&quot;, new byte[]{1, 2}
&nbsp;//        );
&nbsp;//        this.sqlgGraph.tx().commit();
&nbsp;//        Assert.assertTrue(this.sqlgGraph.traversal().V().hasLabel(&quot;Person&quot;).hasNext());
&nbsp;//        Assert.assertNotNull(this.sqlgGraph.traversal().V().hasLabel(&quot;Person&quot;).next().property(&quot;names&quot;).value());
&nbsp;//        Assert.assertArrayEquals(new String[]{&quot;A&quot;, &quot;B&quot;}, this.sqlgGraph.traversal().V().hasLabel(&quot;Person&quot;).next().&lt;String[]&gt;value(&quot;names&quot;));
&nbsp;//        Assert.assertArrayEquals(new byte[]{1, 2}, this.sqlgGraph.traversal().V().hasLabel(&quot;Person&quot;).next().value(&quot;bytes&quot;));
&nbsp;//        this.sqlgGraph.tx().normalBatchModeOn();
&nbsp;//        v.property(&quot;names&quot;, new String[]{&quot;C&quot;, &quot;D&quot;});
&nbsp;//        v.property(&quot;integers&quot;, new int[]{3, 4});
&nbsp;//        v.property(&quot;booleans&quot;, new boolean[]{false, false});
&nbsp;//        v.property(&quot;doubles&quot;, new double[]{3D, 4D});
&nbsp;//        v.property(&quot;longs&quot;, new long[]{3L, 4L});
&nbsp;//        v.property(&quot;shorts&quot;, new short[]{3, 4});
&nbsp;//        v.property(&quot;bytes&quot;, new byte[]{3, 4});
&nbsp;//        this.sqlgGraph.tx().commit();
&nbsp;//        testUpdateArraysNoFloats_assert(this.sqlgGraph);
&nbsp;//        if (this.sqlgGraph1 != null) {
&nbsp;//            Thread.sleep(SLEEP_TIME);
&nbsp;//            testUpdateArraysNoFloats_assert(this.sqlgGraph1);
&nbsp;//        }
&nbsp;//    }
&nbsp;//
&nbsp;//    private void testUpdateArraysNoFloats_assert(SqlgGraph sqlgGraph) {
&nbsp;//        Assert.assertArrayEquals(new String[]{&quot;C&quot;, &quot;D&quot;}, sqlgGraph.traversal().V().hasLabel(&quot;Person&quot;).next().&lt;String[]&gt;value(&quot;names&quot;));
&nbsp;//        Assert.assertArrayEquals(new int[]{3, 4}, sqlgGraph.traversal().V().hasLabel(&quot;Person&quot;).next().value(&quot;integers&quot;));
&nbsp;//        Assert.assertArrayEquals(new boolean[]{false, false}, sqlgGraph.traversal().V().hasLabel(&quot;Person&quot;).next().value(&quot;booleans&quot;));
&nbsp;//        Assert.assertArrayEquals(new double[]{3D, 4D}, sqlgGraph.traversal().V().hasLabel(&quot;Person&quot;).next().value(&quot;doubles&quot;), 0d);
&nbsp;//        Assert.assertArrayEquals(new long[]{3L, 4L}, sqlgGraph.traversal().V().hasLabel(&quot;Person&quot;).next().value(&quot;longs&quot;));
&nbsp;//        Assert.assertArrayEquals(new short[]{3, 4}, sqlgGraph.traversal().V().hasLabel(&quot;Person&quot;).next().value(&quot;shorts&quot;));
&nbsp;//        Assert.assertArrayEquals(new byte[]{3, 4}, sqlgGraph.traversal().V().hasLabel(&quot;Person&quot;).next().value(&quot;bytes&quot;));
&nbsp;//    }
&nbsp;//
&nbsp;//    @Test
&nbsp;//    public void testStringUpdate() throws InterruptedException {
&nbsp;//        this.sqlgGraph.tx().normalBatchModeOn();
&nbsp;//        Vertex v1 = this.sqlgGraph.addVertex(T.label, &quot;A&quot;, &quot;name&quot;, &quot;halo&quot;);
&nbsp;//        this.sqlgGraph.tx().commit();
&nbsp;//        this.sqlgGraph.tx().normalBatchModeOn();
&nbsp;//        v1 = this.sqlgGraph.traversal().V(v1.id()).next();
&nbsp;//        v1.property(&quot;name&quot;, &quot;halo3&quot;);
&nbsp;//        this.sqlgGraph.tx().commit();
&nbsp;//        testStringUpdate_assert(this.sqlgGraph, v1);
&nbsp;//        if (this.sqlgGraph1 != null) {
&nbsp;//            Thread.sleep(SLEEP_TIME);
&nbsp;//            testStringUpdate_assert(this.sqlgGraph1, v1);
&nbsp;//        }
&nbsp;//    }
&nbsp;//
&nbsp;//    private void testStringUpdate_assert(SqlgGraph sqlgGraph, Vertex v1) {
&nbsp;//        v1 = sqlgGraph.traversal().V(v1.id()).next();
&nbsp;//        Assert.assertEquals(&quot;halo3&quot;, v1.value(&quot;name&quot;));
&nbsp;//    }
&nbsp;//
&nbsp;//    @Test
&nbsp;//    public void testStringUpdateEdge() throws InterruptedException {
&nbsp;//        this.sqlgGraph.tx().normalBatchModeOn();
&nbsp;//        Vertex v1 = this.sqlgGraph.addVertex(T.label, &quot;A&quot;);
&nbsp;//        Vertex v2 = this.sqlgGraph.addVertex(T.label, &quot;A&quot;);
&nbsp;//        Edge e1 = v1.addEdge(&quot;test&quot;, v2, &quot;name&quot;, &quot;halo&quot;);
&nbsp;//        this.sqlgGraph.tx().commit();
&nbsp;//        this.sqlgGraph.tx().normalBatchModeOn();
&nbsp;//        e1 = this.sqlgGraph.traversal().E(e1.id()).next();
&nbsp;//        e1.property(&quot;name&quot;, &quot;halo3&quot;);
&nbsp;//        this.sqlgGraph.tx().commit();
&nbsp;//        testStringUpdateEdge_assert(this.sqlgGraph, e1);
&nbsp;//        if (this.sqlgGraph1 != null) {
&nbsp;//            Thread.sleep(SLEEP_TIME);
&nbsp;//            testStringUpdateEdge_assert(this.sqlgGraph1, e1);
&nbsp;//        }
&nbsp;//    }
&nbsp;//
&nbsp;//    private void testStringUpdateEdge_assert(SqlgGraph sqlgGraph, Edge e1) {
&nbsp;//        e1 = sqlgGraph.traversal().E(e1.id()).next();
&nbsp;//        Assert.assertEquals(&quot;halo3&quot;, e1.value(&quot;name&quot;));
&nbsp;//    }
&nbsp;//
&nbsp;//    @SuppressWarnings(&quot;UnnecessaryBoxing&quot;)
&nbsp;//    @Test
&nbsp;//    public void testBooleanUpdate() throws InterruptedException {
&nbsp;//        this.sqlgGraph.tx().normalBatchModeOn();
&nbsp;//        Vertex v1 = this.sqlgGraph.addVertex(T.label, &quot;A&quot;, &quot;name&quot;, Boolean.valueOf(true));
&nbsp;//        this.sqlgGraph.tx().commit();
&nbsp;//        this.sqlgGraph.tx().normalBatchModeOn();
&nbsp;//        v1 = this.sqlgGraph.traversal().V(v1.id()).next();
&nbsp;//        v1.property(&quot;name&quot;, Boolean.valueOf(false));
&nbsp;//        this.sqlgGraph.tx().commit();
&nbsp;//        testBooleanUpdate_assert(this.sqlgGraph, v1);
&nbsp;//        if (this.sqlgGraph1 != null) {
&nbsp;//            Thread.sleep(SLEEP_TIME);
&nbsp;//            testBooleanUpdate_assert(this.sqlgGraph1, v1);
&nbsp;//        }
&nbsp;//    }
&nbsp;//
&nbsp;//    @SuppressWarnings(&quot;UnnecessaryBoxing&quot;)
&nbsp;//    private void testBooleanUpdate_assert(SqlgGraph sqlgGraph, Vertex v1) {
&nbsp;//        v1 = sqlgGraph.traversal().V(v1.id()).next();
&nbsp;//        Assert.assertEquals(Boolean.valueOf(false), v1.value(&quot;name&quot;));
&nbsp;//    }
&nbsp;//
&nbsp;//    @SuppressWarnings(&quot;UnnecessaryBoxing&quot;)
&nbsp;//    @Test
&nbsp;//    public void testBooleanUpdateEdge() throws InterruptedException {
&nbsp;//        this.sqlgGraph.tx().normalBatchModeOn();
&nbsp;//        Vertex v1 = this.sqlgGraph.addVertex(T.label, &quot;A&quot;);
&nbsp;//        Vertex v2 = this.sqlgGraph.addVertex(T.label, &quot;A&quot;);
&nbsp;//        Edge e1 = v1.addEdge(&quot;test&quot;, v2, &quot;name&quot;, Boolean.valueOf(true));
&nbsp;//        this.sqlgGraph.tx().commit();
&nbsp;//        this.sqlgGraph.tx().normalBatchModeOn();
&nbsp;//        e1 = this.sqlgGraph.traversal().E(e1.id()).next();
&nbsp;//        e1.property(&quot;name&quot;, Boolean.valueOf(false));
&nbsp;//        this.sqlgGraph.tx().commit();
&nbsp;//        testBooleanUpdateEdge_assert(this.sqlgGraph, e1);
&nbsp;//        if (this.sqlgGraph1 != null) {
&nbsp;//            Thread.sleep(SLEEP_TIME);
&nbsp;//            testBooleanUpdateEdge_assert(this.sqlgGraph1, e1);
&nbsp;//        }
&nbsp;//    }
&nbsp;//
&nbsp;//    @SuppressWarnings(&quot;UnnecessaryBoxing&quot;)
&nbsp;//    private void testBooleanUpdateEdge_assert(SqlgGraph sqlgGraph, Edge e1) {
&nbsp;//        e1 = sqlgGraph.traversal().E(e1.id()).next();
&nbsp;//        Assert.assertEquals(Boolean.valueOf(false), e1.value(&quot;name&quot;));
&nbsp;//        Assert.assertEquals(e1.value(&quot;name&quot;).getClass(), Boolean.class);
&nbsp;//    }
&nbsp;//
&nbsp;//    @Test
&nbsp;//    public void testShortUpdate() throws InterruptedException {
&nbsp;//        this.sqlgGraph.tx().normalBatchModeOn();
&nbsp;//        Vertex v1 = this.sqlgGraph.addVertex(T.label, &quot;A&quot;, &quot;name&quot;, Short.valueOf(&quot;1&quot;));
&nbsp;//        this.sqlgGraph.tx().commit();
&nbsp;//        this.sqlgGraph.tx().normalBatchModeOn();
&nbsp;//        v1 = this.sqlgGraph.traversal().V(v1.id()).next();
&nbsp;//        v1.property(&quot;name&quot;, Short.valueOf(&quot;2&quot;));
&nbsp;//        this.sqlgGraph.tx().commit();
&nbsp;//        testShortUpdate_assert(this.sqlgGraph, v1);
&nbsp;//        if (this.sqlgGraph1 != null) {
&nbsp;//            Thread.sleep(SLEEP_TIME);
&nbsp;//            testShortUpdate_assert(this.sqlgGraph1, v1);
&nbsp;//        }
&nbsp;//    }
&nbsp;//
&nbsp;//    private void testShortUpdate_assert(SqlgGraph sqlgGraph, Vertex v1) {
&nbsp;//        v1 = sqlgGraph.traversal().V(v1.id()).next();
&nbsp;//        Assert.assertEquals(Short.valueOf(&quot;2&quot;), v1.value(&quot;name&quot;));
&nbsp;//    }
&nbsp;//
&nbsp;//    @Test
&nbsp;//    public void testShortUpdateEdge() throws InterruptedException {
&nbsp;//        this.sqlgGraph.tx().normalBatchModeOn();
&nbsp;//        Vertex v1 = this.sqlgGraph.addVertex(T.label, &quot;A&quot;);
&nbsp;//        Vertex v2 = this.sqlgGraph.addVertex(T.label, &quot;A&quot;);
&nbsp;//        Edge e1 = v1.addEdge(&quot;test&quot;, v2, &quot;name&quot;, Short.valueOf(&quot;1&quot;));
&nbsp;//        this.sqlgGraph.tx().commit();
&nbsp;//        this.sqlgGraph.tx().normalBatchModeOn();
&nbsp;//        e1 = this.sqlgGraph.traversal().E(e1.id()).next();
&nbsp;//        e1.property(&quot;name&quot;, Short.valueOf(&quot;2&quot;));
&nbsp;//        this.sqlgGraph.tx().commit();
&nbsp;//        testShortUpdateEdge_assert(this.sqlgGraph, e1);
&nbsp;//        if (this.sqlgGraph1 != null) {
&nbsp;//            Thread.sleep(SLEEP_TIME);
&nbsp;//            testShortUpdateEdge_assert(this.sqlgGraph1, e1);
&nbsp;//        }
&nbsp;//    }
&nbsp;//
&nbsp;//    private void testShortUpdateEdge_assert(SqlgGraph sqlgGraph, Edge e1) {
&nbsp;//        e1 = sqlgGraph.traversal().E(e1.id()).next();
&nbsp;//        Assert.assertEquals(Short.valueOf(&quot;2&quot;), e1.value(&quot;name&quot;));
&nbsp;//    }
&nbsp;//
&nbsp;//    @Test
&nbsp;//    public void testIntegerUpdate() throws InterruptedException {
&nbsp;//        this.sqlgGraph.tx().normalBatchModeOn();
&nbsp;//        Vertex v1 = this.sqlgGraph.addVertex(T.label, &quot;A&quot;, &quot;name&quot;, Integer.valueOf(&quot;1&quot;));
&nbsp;//        this.sqlgGraph.tx().commit();
&nbsp;//        this.sqlgGraph.tx().normalBatchModeOn();
&nbsp;//        v1 = this.sqlgGraph.traversal().V(v1.id()).next();
&nbsp;//        v1.property(&quot;name&quot;, Integer.valueOf(&quot;2&quot;));
&nbsp;//        this.sqlgGraph.tx().commit();
&nbsp;//        testIntegerUpdate_assert(this.sqlgGraph, v1);
&nbsp;//        if (this.sqlgGraph1 != null) {
&nbsp;//            Thread.sleep(SLEEP_TIME);
&nbsp;//            testIntegerUpdate_assert(this.sqlgGraph1, v1);
&nbsp;//        }
&nbsp;//    }
&nbsp;//
&nbsp;//    private void testIntegerUpdate_assert(SqlgGraph sqlgGraph, Vertex v1) {
&nbsp;//        v1 = sqlgGraph.traversal().V(v1.id()).next();
&nbsp;//        Assert.assertEquals(Integer.valueOf(&quot;2&quot;), v1.value(&quot;name&quot;));
&nbsp;//    }
&nbsp;//
&nbsp;//    @Test
&nbsp;//    public void testIntegerUpdateEdge() throws InterruptedException {
&nbsp;//        this.sqlgGraph.tx().normalBatchModeOn();
&nbsp;//        Vertex v1 = this.sqlgGraph.addVertex(T.label, &quot;A&quot;);
&nbsp;//        Vertex v2 = this.sqlgGraph.addVertex(T.label, &quot;A&quot;);
&nbsp;//        Edge e1 = v1.addEdge(&quot;test&quot;, v2, &quot;name&quot;, Integer.valueOf(&quot;1&quot;));
&nbsp;//        this.sqlgGraph.tx().commit();
&nbsp;//        this.sqlgGraph.tx().normalBatchModeOn();
&nbsp;//        e1 = this.sqlgGraph.traversal().E(e1.id()).next();
&nbsp;//        e1.property(&quot;name&quot;, Integer.valueOf(&quot;2&quot;));
&nbsp;//        this.sqlgGraph.tx().commit();
&nbsp;//        testIntegerUpdateEdge_assert(this.sqlgGraph, e1);
&nbsp;//        if (this.sqlgGraph1 != null) {
&nbsp;//            Thread.sleep(SLEEP_TIME);
&nbsp;//            testIntegerUpdateEdge_assert(this.sqlgGraph1, e1);
&nbsp;//        }
&nbsp;//    }
&nbsp;//
&nbsp;//    private void testIntegerUpdateEdge_assert(SqlgGraph sqlgGraph, Edge e1) {
&nbsp;//        e1 = sqlgGraph.traversal().E(e1.id()).next();
&nbsp;//        Assert.assertEquals(Integer.valueOf(&quot;2&quot;), e1.value(&quot;name&quot;));
&nbsp;//    }
&nbsp;//
&nbsp;//    @Test
&nbsp;//    public void testLongUpdate() throws InterruptedException {
&nbsp;//        this.sqlgGraph.tx().normalBatchModeOn();
&nbsp;//        Vertex v1 = this.sqlgGraph.addVertex(T.label, &quot;A&quot;, &quot;name&quot;, Long.valueOf(&quot;1&quot;));
&nbsp;//        this.sqlgGraph.tx().commit();
&nbsp;//        this.sqlgGraph.tx().normalBatchModeOn();
&nbsp;//        v1 = this.sqlgGraph.traversal().V(v1.id()).next();
&nbsp;//        v1.property(&quot;name&quot;, Long.valueOf(&quot;2&quot;));
&nbsp;//        this.sqlgGraph.tx().commit();
&nbsp;//        testLongUpdate_assert(this.sqlgGraph, v1);
&nbsp;//        if (this.sqlgGraph1 != null) {
&nbsp;//            Thread.sleep(SLEEP_TIME);
&nbsp;//            testLongUpdate_assert(this.sqlgGraph1, v1);
&nbsp;//        }
&nbsp;//    }
&nbsp;//
&nbsp;//    private void testLongUpdate_assert(SqlgGraph sqlgGraph, Vertex v1) {
&nbsp;//        v1 = sqlgGraph.traversal().V(v1.id()).next();
&nbsp;//        Assert.assertEquals(Long.valueOf(&quot;2&quot;), v1.value(&quot;name&quot;));
&nbsp;//    }
&nbsp;//
&nbsp;//    @Test
&nbsp;//    public void testLongUpdateEdge() throws InterruptedException {
&nbsp;//        this.sqlgGraph.tx().normalBatchModeOn();
&nbsp;//        Vertex v1 = this.sqlgGraph.addVertex(T.label, &quot;A&quot;);
&nbsp;//        Vertex v2 = this.sqlgGraph.addVertex(T.label, &quot;A&quot;);
&nbsp;//        Edge e1 = v1.addEdge(&quot;test&quot;, v2, &quot;name&quot;, Long.valueOf(&quot;1&quot;));
&nbsp;//        this.sqlgGraph.tx().commit();
&nbsp;//        this.sqlgGraph.tx().normalBatchModeOn();
&nbsp;//        e1 = this.sqlgGraph.traversal().E(e1.id()).next();
&nbsp;//        e1.property(&quot;name&quot;, Long.valueOf(&quot;2&quot;));
&nbsp;//        this.sqlgGraph.tx().commit();
&nbsp;//        testLongUpdateEdge_assert(this.sqlgGraph, e1);
&nbsp;//        if (this.sqlgGraph1 != null) {
&nbsp;//            Thread.sleep(SLEEP_TIME);
&nbsp;//            testLongUpdateEdge_assert(this.sqlgGraph1, e1);
&nbsp;//        }
&nbsp;//    }
&nbsp;//
&nbsp;//    private void testLongUpdateEdge_assert(SqlgGraph sqlgGraph, Edge e1) {
&nbsp;//        e1 = sqlgGraph.traversal().E(e1.id()).next();
&nbsp;//        Assert.assertEquals(Long.valueOf(&quot;2&quot;), e1.value(&quot;name&quot;));
&nbsp;//    }
&nbsp;//
&nbsp;//    @Test
&nbsp;//    public void testFloatUpdate() throws InterruptedException {
&nbsp;//        Assume.assumeTrue(this.sqlgGraph.getSqlDialect().supportsFloatValues());
&nbsp;//        this.sqlgGraph.tx().normalBatchModeOn();
&nbsp;//        Vertex v1 = this.sqlgGraph.addVertex(T.label, &quot;A&quot;, &quot;name&quot;, Float.valueOf(&quot;1.1&quot;));
&nbsp;//        this.sqlgGraph.tx().commit();
&nbsp;//        this.sqlgGraph.tx().normalBatchModeOn();
&nbsp;//        v1 = this.sqlgGraph.traversal().V(v1.id()).next();
&nbsp;//        v1.property(&quot;name&quot;, Float.valueOf(&quot;2.2&quot;));
&nbsp;//        this.sqlgGraph.tx().commit();
&nbsp;//        testFloatUpdate_assert(this.sqlgGraph, v1);
&nbsp;//        if (this.sqlgGraph1 != null) {
&nbsp;//            Thread.sleep(SLEEP_TIME);
&nbsp;//            testFloatUpdate_assert(this.sqlgGraph1, v1);
&nbsp;//        }
&nbsp;//    }
&nbsp;//
&nbsp;//    private void testFloatUpdate_assert(SqlgGraph sqlgGraph, Vertex v1) {
&nbsp;//        v1 = sqlgGraph.traversal().V(v1.id()).next();
&nbsp;//        Assert.assertEquals(Float.valueOf(&quot;2.2&quot;), v1.value(&quot;name&quot;));
&nbsp;//    }
&nbsp;//
&nbsp;//    @Test
&nbsp;//    public void testFloatUpdateEdge() throws InterruptedException {
&nbsp;//        Assume.assumeTrue(this.sqlgGraph.getSqlDialect().supportsFloatValues());
&nbsp;//        this.sqlgGraph.tx().normalBatchModeOn();
&nbsp;//        Vertex v1 = this.sqlgGraph.addVertex(T.label, &quot;A&quot;);
&nbsp;//        Vertex v2 = this.sqlgGraph.addVertex(T.label, &quot;A&quot;);
&nbsp;//        Edge e1 = v1.addEdge(&quot;test&quot;, v2, &quot;name&quot;, Float.valueOf(&quot;1.1&quot;));
&nbsp;//        this.sqlgGraph.tx().commit();
&nbsp;//        this.sqlgGraph.tx().normalBatchModeOn();
&nbsp;//        e1 = this.sqlgGraph.traversal().E(e1.id()).next();
&nbsp;//        e1.property(&quot;name&quot;, Float.valueOf(&quot;2.2&quot;));
&nbsp;//        this.sqlgGraph.tx().commit();
&nbsp;//        testFloatUpdateEdge_assert(this.sqlgGraph, e1);
&nbsp;//        if (this.sqlgGraph1 != null) {
&nbsp;//            Thread.sleep(SLEEP_TIME);
&nbsp;//            testFloatUpdateEdge_assert(this.sqlgGraph1, e1);
&nbsp;//        }
&nbsp;//    }
&nbsp;//
&nbsp;//    private void testFloatUpdateEdge_assert(SqlgGraph sqlgGraph, Edge e1) {
&nbsp;//        e1 = sqlgGraph.traversal().E(e1.id()).next();
&nbsp;//        Assert.assertEquals(Float.valueOf(&quot;2.2&quot;), e1.value(&quot;name&quot;));
&nbsp;//    }
&nbsp;//
&nbsp;//    @Test
&nbsp;//    public void testBigDecimalUpdate() throws InterruptedException {
&nbsp;//        this.sqlgGraph.tx().normalBatchModeOn();
&nbsp;//        Vertex v1 = this.sqlgGraph.addVertex(T.label, &quot;A&quot;, &quot;name&quot;, BigDecimal.valueOf(1.1D));
&nbsp;//        this.sqlgGraph.tx().commit();
&nbsp;//        this.sqlgGraph.tx().normalBatchModeOn();
&nbsp;//        v1 = this.sqlgGraph.traversal().V(v1.id()).next();
&nbsp;//        v1.property(&quot;name&quot;, BigDecimal.valueOf(2.2D));
&nbsp;//        this.sqlgGraph.tx().commit();
&nbsp;//        testBigDecimalUpdate_assert(this.sqlgGraph, v1);
&nbsp;//        if (this.sqlgGraph1 != null) {
&nbsp;//            Thread.sleep(SLEEP_TIME);
&nbsp;//            testBigDecimalUpdate_assert(this.sqlgGraph1, v1);
&nbsp;//        }
&nbsp;//    }
&nbsp;//
&nbsp;//    @Test
&nbsp;//    public void testDoubleUpdate() throws InterruptedException {
&nbsp;//        this.sqlgGraph.tx().normalBatchModeOn();
&nbsp;//        Vertex v1 = this.sqlgGraph.addVertex(T.label, &quot;A&quot;, &quot;name&quot;, Double.valueOf(&quot;1.1&quot;));
&nbsp;//        this.sqlgGraph.tx().commit();
&nbsp;//        this.sqlgGraph.tx().normalBatchModeOn();
&nbsp;//        v1 = this.sqlgGraph.traversal().V(v1.id()).next();
&nbsp;//        v1.property(&quot;name&quot;, Double.valueOf(&quot;2.2&quot;));
&nbsp;//        this.sqlgGraph.tx().commit();
&nbsp;//        testDoubleUpdate_assert(this.sqlgGraph, v1);
&nbsp;//        if (this.sqlgGraph1 != null) {
&nbsp;//            Thread.sleep(SLEEP_TIME);
&nbsp;//            testDoubleUpdate_assert(this.sqlgGraph1, v1);
&nbsp;//        }
&nbsp;//    }
&nbsp;//
&nbsp;//    private void testDoubleUpdate_assert(SqlgGraph sqlgGraph, Vertex v1) {
&nbsp;//        v1 = sqlgGraph.traversal().V(v1.id()).next();
&nbsp;//        Assert.assertEquals(Double.valueOf(&quot;2.2&quot;), v1.value(&quot;name&quot;));
&nbsp;//    }
&nbsp;//
&nbsp;//    private void testBigDecimalUpdate_assert(SqlgGraph sqlgGraph, Vertex v1) {
&nbsp;//        v1 = sqlgGraph.traversal().V(v1.id()).next();
&nbsp;//        Assert.assertEquals(BigDecimal.valueOf(2.2D), v1.value(&quot;name&quot;));
&nbsp;//    }
&nbsp;//
&nbsp;//    @Test
&nbsp;//    public void testDoubleUpdateEdge() throws InterruptedException {
&nbsp;//        this.sqlgGraph.tx().normalBatchModeOn();
&nbsp;//        Vertex v1 = this.sqlgGraph.addVertex(T.label, &quot;A&quot;);
&nbsp;//        Vertex v2 = this.sqlgGraph.addVertex(T.label, &quot;A&quot;);
&nbsp;//        Edge e1 = v1.addEdge(&quot;test&quot;, v2, &quot;name&quot;, Double.valueOf(&quot;1.1&quot;));
&nbsp;//        this.sqlgGraph.tx().commit();
&nbsp;//        this.sqlgGraph.tx().normalBatchModeOn();
&nbsp;//        e1 = this.sqlgGraph.traversal().E(e1.id()).next();
&nbsp;//        e1.property(&quot;name&quot;, Double.valueOf(&quot;2.2&quot;));
&nbsp;//        this.sqlgGraph.tx().commit();
&nbsp;//        testDoubleUpdateEdge_assert(this.sqlgGraph, e1);
&nbsp;//        if (this.sqlgGraph1 != null) {
&nbsp;//            Thread.sleep(SLEEP_TIME);
&nbsp;//            testDoubleUpdateEdge_assert(this.sqlgGraph1, e1);
&nbsp;//        }
&nbsp;//    }
&nbsp;//
&nbsp;//    private void testDoubleUpdateEdge_assert(SqlgGraph sqlgGraph, Edge e1) {
&nbsp;//        e1 = sqlgGraph.traversal().E(e1.id()).next();
&nbsp;//        Assert.assertEquals(Double.valueOf(&quot;2.2&quot;), e1.value(&quot;name&quot;));
&nbsp;//    }
&nbsp;
&nbsp;}
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2025-06-23 10:13</div>
</div>
</body>
</html>
