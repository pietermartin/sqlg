


<!DOCTYPE html>
<html id="htmlId">
<head>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8"> 
  <title>Coverage Report > TestIndexOnPartition</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope:     <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">org.umlg.sqlg.test.index</a>
</div>

<h1>Coverage Summary for Class: TestIndexOnPartition (org.umlg.sqlg.test.index)</h1>

<table class="coverageStats">

<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Branch, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">TestIndexOnPartition</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (11/11)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    77.8%
  </span>
  <span class="absValue">
    (14/18)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    97.7%
  </span>
  <span class="absValue">
    (339/347)
  </span>
</td>
</tr>
  <tr>
    <td class="name">TestIndexOnPartition$1</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (1/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TestIndexOnPartition$10</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (1/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (6/6)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TestIndexOnPartition$11</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (1/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (6/6)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TestIndexOnPartition$2</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (1/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TestIndexOnPartition$3</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (1/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TestIndexOnPartition$4</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (1/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TestIndexOnPartition$5</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (1/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TestIndexOnPartition$6</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (1/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TestIndexOnPartition$7</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (1/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (5/5)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TestIndexOnPartition$8</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (1/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (5/5)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TestIndexOnPartition$9</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (1/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (6/6)
  </span>
</td>
  </tr>
<tr>
  <td class="name"><strong>Total</strong></td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (22/22)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    77.8%
  </span>
  <span class="absValue">
    (14/18)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    97.9%
  </span>
  <span class="absValue">
    (379/387)
  </span>
</td>
</tr>
</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode">&nbsp;package org.umlg.sqlg.test.index;
&nbsp;
&nbsp;import org.apache.commons.collections4.set.ListOrderedSet;
&nbsp;import org.apache.tinkerpop.gremlin.structure.T;
&nbsp;import org.apache.tinkerpop.gremlin.structure.Vertex;
&nbsp;import org.junit.Assert;
&nbsp;import org.junit.Assume;
&nbsp;import org.junit.Before;
&nbsp;import org.junit.Test;
&nbsp;import org.umlg.sqlg.structure.PropertyDefinition;
&nbsp;import org.umlg.sqlg.structure.PropertyType;
&nbsp;import org.umlg.sqlg.structure.SqlgGraph;
&nbsp;import org.umlg.sqlg.structure.topology.*;
&nbsp;import org.umlg.sqlg.test.BaseTest;
&nbsp;
&nbsp;import java.sql.Connection;
&nbsp;import java.sql.ResultSet;
&nbsp;import java.sql.SQLException;
&nbsp;import java.sql.Statement;
&nbsp;import java.util.*;
&nbsp;
&nbsp;/**
&nbsp; * @author &lt;a href=&quot;https://github.com/pietermartin&quot;&gt;Pieter Martin&lt;/a&gt;
&nbsp; * Date: 2018/01/28
&nbsp; */
&nbsp;@SuppressWarnings({&quot;DuplicatedCode&quot;, &quot;unused&quot;})
<b class="fc">&nbsp;public class TestIndexOnPartition extends BaseTest {</b>
&nbsp;
&nbsp;    @Before
&nbsp;    public void before() throws Exception {
<b class="fc">&nbsp;        super.before();</b>
<b class="fc">&nbsp;        Assume.assumeTrue(this.sqlgGraph.getSqlDialect().supportsPartitioning());</b>
&nbsp;    }
&nbsp;
&nbsp;    @Test
&nbsp;    public void testCreateIndexOnPartitionedVertexLabelBeforeCreatingPartitions() {
<b class="fc">&nbsp;        Schema schema = this.sqlgGraph.getTopology().ensureSchemaExist(&quot;A&quot;);</b>
<b class="fc">&nbsp;        VertexLabel vertexLabel = schema.ensurePartitionedVertexLabelExist(</b>
&nbsp;                &quot;A&quot;,
<b class="fc">&nbsp;                new HashMap&lt;&gt;() {{</b>
<b class="fc">&nbsp;                    put(&quot;int1&quot;, PropertyDefinition.of(PropertyType.INTEGER));</b>
&nbsp;                }},
<b class="fc">&nbsp;                ListOrderedSet.listOrderedSet(Collections.singletonList(&quot;int1&quot;)),</b>
&nbsp;                PartitionType.RANGE,
&nbsp;                &quot;int1&quot;);
<b class="fc">&nbsp;        PropertyColumn propertyColumn = vertexLabel.getProperty(&quot;int1&quot;).get();</b>
<b class="fc">&nbsp;        Index index = vertexLabel.ensureIndexExists(IndexType.UNIQUE, Collections.singletonList(propertyColumn));</b>
<b class="fc">&nbsp;        vertexLabel.ensureRangePartitionExists(&quot;int1&quot;, &quot;1&quot;, &quot;5&quot;);</b>
&nbsp;
<b class="fc">&nbsp;        schema = this.sqlgGraph.getTopology().ensureSchemaExist(&quot;B&quot;);</b>
<b class="fc">&nbsp;        vertexLabel = schema.ensurePartitionedVertexLabelExist(</b>
&nbsp;                &quot;B&quot;,
<b class="fc">&nbsp;                new HashMap&lt;&gt;() {{</b>
<b class="fc">&nbsp;                    put(&quot;int1&quot;, PropertyDefinition.of(PropertyType.INTEGER));</b>
&nbsp;                }},
<b class="fc">&nbsp;                ListOrderedSet.listOrderedSet(Collections.singletonList(&quot;int1&quot;)),</b>
&nbsp;                PartitionType.RANGE,
&nbsp;                &quot;int1&quot;);
<b class="fc">&nbsp;        propertyColumn = vertexLabel.getProperty(&quot;int1&quot;).get();</b>
<b class="fc">&nbsp;        index = vertexLabel.ensureIndexExists(IndexType.UNIQUE, Collections.singletonList(propertyColumn));</b>
<b class="fc">&nbsp;        vertexLabel.ensureRangePartitionExists(&quot;int1&quot;, &quot;0&quot;, &quot;100&quot;);</b>
<b class="fc">&nbsp;        vertexLabel.ensureRangePartitionExists(&quot;int2&quot;, &quot;100&quot;, &quot;200&quot;);</b>
<b class="fc">&nbsp;        vertexLabel.ensureRangePartitionExists(&quot;int3&quot;, &quot;200&quot;, &quot;300&quot;);</b>
<b class="fc">&nbsp;        vertexLabel.ensureRangePartitionExists(&quot;int4&quot;, &quot;300&quot;, &quot;400&quot;);</b>
<b class="fc">&nbsp;        vertexLabel.ensureRangePartitionExists(&quot;int5&quot;, &quot;400&quot;, &quot;500&quot;);</b>
<b class="fc">&nbsp;        vertexLabel.ensureRangePartitionExists(&quot;int6&quot;, &quot;500&quot;, &quot;600&quot;);</b>
<b class="fc">&nbsp;        vertexLabel.ensureRangePartitionExists(&quot;int7&quot;, &quot;600&quot;, &quot;700&quot;);</b>
<b class="fc">&nbsp;        vertexLabel.ensureRangePartitionExists(&quot;int8&quot;, &quot;700&quot;, &quot;800&quot;);</b>
<b class="fc">&nbsp;        vertexLabel.ensureRangePartitionExists(&quot;int9&quot;, &quot;800&quot;, &quot;900&quot;);</b>
<b class="fc">&nbsp;        vertexLabel.ensureRangePartitionExists(&quot;int10&quot;, &quot;900&quot;, &quot;1000&quot;);</b>
<b class="fc">&nbsp;        this.sqlgGraph.tx().commit();</b>
&nbsp;
<b class="fc">&nbsp;        for (int i = 0; i &lt; 1000; i++) {</b>
<b class="fc">&nbsp;            this.sqlgGraph.addVertex(T.label, &quot;B.B&quot;, &quot;int1&quot;, i);</b>
&nbsp;        }
<b class="fc">&nbsp;        this.sqlgGraph.tx().commit();</b>
&nbsp;
<b class="fc">&nbsp;        Map&lt;String, Index&gt; indexMap = this.sqlgGraph.getTopology().getSchema(&quot;B&quot;).get().getVertexLabel(&quot;B&quot;).get().getIndexes();</b>
<b class="fc">&nbsp;        Assert.assertEquals(1, indexMap.size());</b>
<b class="fc">&nbsp;        try (SqlgGraph sqlgGraph1 = SqlgGraph.open(configuration)) {</b>
<b class="fc">&nbsp;            indexMap = sqlgGraph1.getTopology().getSchema(&quot;B&quot;).get().getVertexLabel(&quot;B&quot;).get().getIndexes();</b>
<b class="fc">&nbsp;            Assert.assertEquals(1, indexMap.size());</b>
&nbsp;        } catch (Exception e) {
<b class="nc">&nbsp;            Assert.fail(e.getMessage());</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    @Test
&nbsp;    public void testCreateIndexOnPartitionedVertexLabelAfterCreatingPartitions() {
<b class="fc">&nbsp;        Schema schema = this.sqlgGraph.getTopology().ensureSchemaExist(&quot;A&quot;);</b>
<b class="fc">&nbsp;        VertexLabel vertexLabel = schema.ensurePartitionedVertexLabelExist(</b>
&nbsp;                &quot;A&quot;,
<b class="fc">&nbsp;                new HashMap&lt;&gt;() {{</b>
<b class="fc">&nbsp;                    put(&quot;int1&quot;, PropertyDefinition.of(PropertyType.INTEGER));</b>
&nbsp;                }},
<b class="fc">&nbsp;                ListOrderedSet.listOrderedSet(Collections.singletonList(&quot;int1&quot;)),</b>
&nbsp;                PartitionType.RANGE,
&nbsp;                &quot;int1&quot;);
<b class="fc">&nbsp;        vertexLabel.ensureRangePartitionExists(&quot;int1&quot;, &quot;1&quot;, &quot;5&quot;);</b>
&nbsp;
<b class="fc">&nbsp;        schema = this.sqlgGraph.getTopology().ensureSchemaExist(&quot;B&quot;);</b>
<b class="fc">&nbsp;        vertexLabel = schema.ensurePartitionedVertexLabelExist(</b>
&nbsp;                &quot;B&quot;,
<b class="fc">&nbsp;                new HashMap&lt;&gt;() {{</b>
<b class="fc">&nbsp;                    put(&quot;int1&quot;, PropertyDefinition.of(PropertyType.INTEGER));</b>
&nbsp;                }},
<b class="fc">&nbsp;                ListOrderedSet.listOrderedSet(Collections.singletonList(&quot;int1&quot;)),</b>
&nbsp;                PartitionType.RANGE,
&nbsp;                &quot;int1&quot;);
<b class="fc">&nbsp;        vertexLabel.ensureRangePartitionExists(&quot;int1&quot;, &quot;0&quot;, &quot;100&quot;);</b>
<b class="fc">&nbsp;        vertexLabel.ensureRangePartitionExists(&quot;int2&quot;, &quot;100&quot;, &quot;200&quot;);</b>
<b class="fc">&nbsp;        vertexLabel.ensureRangePartitionExists(&quot;int3&quot;, &quot;200&quot;, &quot;300&quot;);</b>
<b class="fc">&nbsp;        vertexLabel.ensureRangePartitionExists(&quot;int4&quot;, &quot;300&quot;, &quot;400&quot;);</b>
<b class="fc">&nbsp;        vertexLabel.ensureRangePartitionExists(&quot;int5&quot;, &quot;400&quot;, &quot;500&quot;);</b>
<b class="fc">&nbsp;        vertexLabel.ensureRangePartitionExists(&quot;int6&quot;, &quot;500&quot;, &quot;600&quot;);</b>
<b class="fc">&nbsp;        vertexLabel.ensureRangePartitionExists(&quot;int7&quot;, &quot;600&quot;, &quot;700&quot;);</b>
<b class="fc">&nbsp;        vertexLabel.ensureRangePartitionExists(&quot;int8&quot;, &quot;700&quot;, &quot;800&quot;);</b>
<b class="fc">&nbsp;        vertexLabel.ensureRangePartitionExists(&quot;int9&quot;, &quot;800&quot;, &quot;900&quot;);</b>
<b class="fc">&nbsp;        vertexLabel.ensureRangePartitionExists(&quot;int10&quot;, &quot;900&quot;, &quot;1000&quot;);</b>
<b class="fc">&nbsp;        this.sqlgGraph.tx().commit();</b>
&nbsp;
<b class="fc">&nbsp;        for (int i = 0; i &lt; 1000; i++) {</b>
<b class="fc">&nbsp;            this.sqlgGraph.addVertex(T.label, &quot;B.B&quot;, &quot;int1&quot;, i);</b>
&nbsp;        }
<b class="fc">&nbsp;        this.sqlgGraph.tx().commit();</b>
&nbsp;
<b class="fc">&nbsp;        PropertyColumn propertyColumn = vertexLabel.getProperty(&quot;int1&quot;).get();</b>
<b class="fc">&nbsp;        Index index = vertexLabel.ensureIndexExists(IndexType.UNIQUE, Collections.singletonList(propertyColumn));</b>
<b class="fc">&nbsp;        this.sqlgGraph.tx().commit();</b>
&nbsp;
<b class="fc">&nbsp;        Map&lt;String, Index&gt; indexMap = this.sqlgGraph.getTopology().getSchema(&quot;B&quot;).get().getVertexLabel(&quot;B&quot;).get().getIndexes();</b>
<b class="fc">&nbsp;        Assert.assertEquals(1, indexMap.size());</b>
<b class="fc">&nbsp;        try (SqlgGraph sqlgGraph1 = SqlgGraph.open(configuration)) {</b>
<b class="fc">&nbsp;            indexMap = sqlgGraph1.getTopology().getSchema(&quot;B&quot;).get().getVertexLabel(&quot;B&quot;).get().getIndexes();</b>
<b class="fc">&nbsp;            Assert.assertEquals(1, indexMap.size());</b>
&nbsp;        } catch (Exception e) {
<b class="nc">&nbsp;            Assert.fail(e.getMessage());</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    @Test
&nbsp;    public void testCreateIndexOnPartitionedEdgeLabelBeforeCreatingPartitions() {
&nbsp;
<b class="fc">&nbsp;        Schema aSchema = this.sqlgGraph.getTopology().ensureSchemaExist(&quot;A&quot;);</b>
<b class="fc">&nbsp;        Schema bSchema = this.sqlgGraph.getTopology().ensureSchemaExist(&quot;B&quot;);</b>
<b class="fc">&nbsp;        VertexLabel aVertexLabel = aSchema.ensureVertexLabelExist(&quot;A&quot;);</b>
<b class="fc">&nbsp;        VertexLabel bVertexLabel = bSchema.ensureVertexLabelExist(&quot;B&quot;);</b>
<b class="fc">&nbsp;        EdgeLabel abEdgeLabel = aVertexLabel.ensurePartitionedEdgeLabelExist(</b>
&nbsp;                &quot;ab&quot;,
&nbsp;                bVertexLabel,
<b class="fc">&nbsp;                new HashMap&lt;&gt;() {{</b>
<b class="fc">&nbsp;                    put(&quot;int1&quot;, PropertyDefinition.of(PropertyType.INTEGER));</b>
&nbsp;                }},
<b class="fc">&nbsp;                ListOrderedSet.listOrderedSet(Collections.singletonList(&quot;int1&quot;)),</b>
&nbsp;                PartitionType.RANGE,
&nbsp;                &quot;int1&quot;);
&nbsp;
&nbsp;
<b class="fc">&nbsp;        PropertyColumn propertyColumn = abEdgeLabel.getProperty(&quot;int1&quot;).get();</b>
<b class="fc">&nbsp;        Index index = abEdgeLabel.ensureIndexExists(IndexType.UNIQUE, Collections.singletonList(propertyColumn));</b>
<b class="fc">&nbsp;        abEdgeLabel.ensureRangePartitionExists(&quot;int1&quot;, &quot;0&quot;, &quot;100&quot;);</b>
<b class="fc">&nbsp;        abEdgeLabel.ensureRangePartitionExists(&quot;int2&quot;, &quot;100&quot;, &quot;200&quot;);</b>
<b class="fc">&nbsp;        abEdgeLabel.ensureRangePartitionExists(&quot;int3&quot;, &quot;200&quot;, &quot;300&quot;);</b>
<b class="fc">&nbsp;        abEdgeLabel.ensureRangePartitionExists(&quot;int4&quot;, &quot;300&quot;, &quot;400&quot;);</b>
<b class="fc">&nbsp;        abEdgeLabel.ensureRangePartitionExists(&quot;int5&quot;, &quot;400&quot;, &quot;500&quot;);</b>
<b class="fc">&nbsp;        abEdgeLabel.ensureRangePartitionExists(&quot;int6&quot;, &quot;500&quot;, &quot;600&quot;);</b>
<b class="fc">&nbsp;        abEdgeLabel.ensureRangePartitionExists(&quot;int7&quot;, &quot;600&quot;, &quot;700&quot;);</b>
<b class="fc">&nbsp;        abEdgeLabel.ensureRangePartitionExists(&quot;int8&quot;, &quot;700&quot;, &quot;800&quot;);</b>
<b class="fc">&nbsp;        abEdgeLabel.ensureRangePartitionExists(&quot;int9&quot;, &quot;800&quot;, &quot;900&quot;);</b>
<b class="fc">&nbsp;        abEdgeLabel.ensureRangePartitionExists(&quot;int10&quot;, &quot;900&quot;, &quot;1000&quot;);</b>
<b class="fc">&nbsp;        this.sqlgGraph.tx().commit();</b>
&nbsp;
<b class="fc">&nbsp;        for (int i = 0; i &lt; 1000; i++) {</b>
<b class="fc">&nbsp;            Vertex a = this.sqlgGraph.addVertex(T.label, &quot;A.A&quot;);</b>
<b class="fc">&nbsp;            Vertex b = this.sqlgGraph.addVertex(T.label, &quot;B.B&quot;);</b>
<b class="fc">&nbsp;            a.addEdge(&quot;ab&quot;, b, &quot;int1&quot;, i);</b>
&nbsp;        }
<b class="fc">&nbsp;        this.sqlgGraph.tx().commit();</b>
&nbsp;
<b class="fc">&nbsp;        Map&lt;String, Index&gt; indexMap = this.sqlgGraph.getTopology().getSchema(&quot;A&quot;).get().getEdgeLabel(&quot;ab&quot;).get().getIndexes();</b>
<b class="fc">&nbsp;        Assert.assertEquals(1, indexMap.size());</b>
<b class="fc">&nbsp;        try (SqlgGraph sqlgGraph1 = SqlgGraph.open(configuration)) {</b>
<b class="fc">&nbsp;            indexMap = sqlgGraph1.getTopology().getSchema(&quot;A&quot;).get().getEdgeLabel(&quot;ab&quot;).get().getIndexes();</b>
<b class="fc">&nbsp;            Assert.assertEquals(1, indexMap.size());</b>
&nbsp;        } catch (Exception e) {
<b class="nc">&nbsp;            Assert.fail(e.getMessage());</b>
&nbsp;        }
&nbsp;
<b class="fc">&nbsp;        Assert.assertEquals(1, this.sqlgGraph.traversal().V().hasLabel(&quot;A.A&quot;).outE(&quot;ab&quot;).has(&quot;int1&quot;, 100).otherV().count().next(), 0);</b>
&nbsp;    }
&nbsp;
&nbsp;    @Test
&nbsp;    public void testCreateIndexOnPartitionedEdgeLabelAfterCreatingPartitions() {
&nbsp;
<b class="fc">&nbsp;        Schema aSchema = this.sqlgGraph.getTopology().ensureSchemaExist(&quot;A&quot;);</b>
<b class="fc">&nbsp;        Schema bSchema = this.sqlgGraph.getTopology().ensureSchemaExist(&quot;B&quot;);</b>
<b class="fc">&nbsp;        VertexLabel aVertexLabel = aSchema.ensureVertexLabelExist(&quot;A&quot;);</b>
<b class="fc">&nbsp;        VertexLabel bVertexLabel = bSchema.ensureVertexLabelExist(&quot;B&quot;);</b>
<b class="fc">&nbsp;        EdgeLabel abEdgeLabel = aVertexLabel.ensurePartitionedEdgeLabelExist(</b>
&nbsp;                &quot;ab&quot;,
&nbsp;                bVertexLabel,
<b class="fc">&nbsp;                new HashMap&lt;&gt;() {{</b>
<b class="fc">&nbsp;                    put(&quot;int1&quot;, PropertyDefinition.of(PropertyType.INTEGER));</b>
&nbsp;                }},
<b class="fc">&nbsp;                ListOrderedSet.listOrderedSet(Collections.singletonList(&quot;int1&quot;)),</b>
&nbsp;                PartitionType.RANGE,
&nbsp;                &quot;int1&quot;);
&nbsp;
&nbsp;
<b class="fc">&nbsp;        PropertyColumn propertyColumn = abEdgeLabel.getProperty(&quot;int1&quot;).get();</b>
<b class="fc">&nbsp;        abEdgeLabel.ensureRangePartitionExists(&quot;int1&quot;, &quot;0&quot;, &quot;100&quot;);</b>
<b class="fc">&nbsp;        abEdgeLabel.ensureRangePartitionExists(&quot;int2&quot;, &quot;100&quot;, &quot;200&quot;);</b>
<b class="fc">&nbsp;        abEdgeLabel.ensureRangePartitionExists(&quot;int3&quot;, &quot;200&quot;, &quot;300&quot;);</b>
<b class="fc">&nbsp;        abEdgeLabel.ensureRangePartitionExists(&quot;int4&quot;, &quot;300&quot;, &quot;400&quot;);</b>
<b class="fc">&nbsp;        abEdgeLabel.ensureRangePartitionExists(&quot;int5&quot;, &quot;400&quot;, &quot;500&quot;);</b>
<b class="fc">&nbsp;        abEdgeLabel.ensureRangePartitionExists(&quot;int6&quot;, &quot;500&quot;, &quot;600&quot;);</b>
<b class="fc">&nbsp;        abEdgeLabel.ensureRangePartitionExists(&quot;int7&quot;, &quot;600&quot;, &quot;700&quot;);</b>
<b class="fc">&nbsp;        abEdgeLabel.ensureRangePartitionExists(&quot;int8&quot;, &quot;700&quot;, &quot;800&quot;);</b>
<b class="fc">&nbsp;        abEdgeLabel.ensureRangePartitionExists(&quot;int9&quot;, &quot;800&quot;, &quot;900&quot;);</b>
<b class="fc">&nbsp;        abEdgeLabel.ensureRangePartitionExists(&quot;int10&quot;, &quot;900&quot;, &quot;1000&quot;);</b>
<b class="fc">&nbsp;        this.sqlgGraph.tx().commit();</b>
<b class="fc">&nbsp;        Index index = abEdgeLabel.ensureIndexExists(IndexType.UNIQUE, Collections.singletonList(propertyColumn));</b>
<b class="fc">&nbsp;        this.sqlgGraph.tx().commit();</b>
&nbsp;
<b class="fc">&nbsp;        for (int i = 0; i &lt; 1000; i++) {</b>
<b class="fc">&nbsp;            Vertex a = this.sqlgGraph.addVertex(T.label, &quot;A.A&quot;);</b>
<b class="fc">&nbsp;            Vertex b = this.sqlgGraph.addVertex(T.label, &quot;B.B&quot;);</b>
<b class="fc">&nbsp;            a.addEdge(&quot;ab&quot;, b, &quot;int1&quot;, i);</b>
&nbsp;        }
<b class="fc">&nbsp;        this.sqlgGraph.tx().commit();</b>
&nbsp;
<b class="fc">&nbsp;        Map&lt;String, Index&gt; indexMap = this.sqlgGraph.getTopology().getSchema(&quot;A&quot;).get().getEdgeLabel(&quot;ab&quot;).get().getIndexes();</b>
<b class="fc">&nbsp;        Assert.assertEquals(1, indexMap.size());</b>
<b class="fc">&nbsp;        try (SqlgGraph sqlgGraph1 = SqlgGraph.open(configuration)) {</b>
<b class="fc">&nbsp;            indexMap = sqlgGraph1.getTopology().getSchema(&quot;A&quot;).get().getEdgeLabel(&quot;ab&quot;).get().getIndexes();</b>
<b class="fc">&nbsp;            Assert.assertEquals(1, indexMap.size());</b>
&nbsp;        } catch (Exception e) {
<b class="nc">&nbsp;            Assert.fail(e.getMessage());</b>
&nbsp;        }
&nbsp;
<b class="fc">&nbsp;        Assert.assertEquals(1, this.sqlgGraph.traversal().V().hasLabel(&quot;A.A&quot;).outE(&quot;ab&quot;).has(&quot;int1&quot;, 100).otherV().count().next(), 0);</b>
&nbsp;    }
&nbsp;
&nbsp;    @Test
&nbsp;    public void testCreateIndexOnSubPartitionedVertexLabelBeforeCreatingPartitions() {
<b class="fc">&nbsp;        Schema schema = this.sqlgGraph.getTopology().ensureSchemaExist(&quot;A&quot;);</b>
<b class="fc">&nbsp;        VertexLabel vertexLabel = schema.ensurePartitionedVertexLabelExist(&quot;A&quot;,</b>
<b class="fc">&nbsp;                new HashMap&lt;&gt;() {{</b>
<b class="fc">&nbsp;                    put(&quot;int1&quot;, PropertyDefinition.of(PropertyType.INTEGER));</b>
<b class="fc">&nbsp;                    put(&quot;int2&quot;, PropertyDefinition.of(PropertyType.INTEGER));</b>
<b class="fc">&nbsp;                    put(&quot;int3&quot;, PropertyDefinition.of(PropertyType.INTEGER));</b>
<b class="fc">&nbsp;                    put(&quot;int4&quot;, PropertyDefinition.of(PropertyType.INTEGER));</b>
&nbsp;                }},
<b class="fc">&nbsp;                ListOrderedSet.listOrderedSet(Arrays.asList(&quot;int1&quot;, &quot;int2&quot;, &quot;int3&quot;)),</b>
&nbsp;                PartitionType.RANGE,
&nbsp;                &quot;int1&quot;);
&nbsp;
<b class="fc">&nbsp;        PropertyColumn propertyColumnInt1 = vertexLabel.getProperty(&quot;int1&quot;).orElseThrow();</b>
<b class="fc">&nbsp;        Index index1 = vertexLabel.ensureIndexExists(IndexType.UNIQUE, Collections.singletonList(propertyColumnInt1));</b>
<b class="fc">&nbsp;        PropertyColumn propertyColumnInt2 = vertexLabel.getProperty(&quot;int2&quot;).orElseThrow();</b>
<b class="fc">&nbsp;        Index index2 = vertexLabel.ensureIndexExists(IndexType.UNIQUE, Collections.singletonList(propertyColumnInt2));</b>
<b class="fc">&nbsp;        PropertyColumn propertyColumnInt3 = vertexLabel.getProperty(&quot;int3&quot;).orElseThrow();</b>
<b class="fc">&nbsp;        Index index3 = vertexLabel.ensureIndexExists(IndexType.UNIQUE, Collections.singletonList(propertyColumnInt3));</b>
<b class="fc">&nbsp;        PropertyColumn propertyColumnInt4 = vertexLabel.getProperty(&quot;int4&quot;).orElseThrow();</b>
<b class="fc">&nbsp;        Index index4 = vertexLabel.ensureIndexExists(IndexType.UNIQUE, Collections.singletonList(propertyColumnInt4));</b>
&nbsp;
<b class="fc">&nbsp;        Partition int1_1_5 = vertexLabel.ensureRangePartitionWithSubPartitionExists(&quot;int1_1_5&quot;, &quot;1&quot;, &quot;5&quot;, PartitionType.RANGE, &quot;int2&quot;);</b>
<b class="fc">&nbsp;        Partition int1_5_10 = vertexLabel.ensureRangePartitionWithSubPartitionExists(&quot;int1_5_10&quot;, &quot;5&quot;, &quot;10&quot;, PartitionType.RANGE, &quot;int2&quot;);</b>
&nbsp;
<b class="fc">&nbsp;        Partition int1_int2_1_5 = int1_1_5.ensureRangePartitionWithSubPartitionExists(&quot;int1_int2_1_5&quot;, &quot;1&quot;, &quot;5&quot;, PartitionType.RANGE, &quot;int2&quot;);</b>
<b class="fc">&nbsp;        Partition int1_int2_5_10 = int1_1_5.ensureRangePartitionWithSubPartitionExists(&quot;int1_int2_5_10&quot;, &quot;5&quot;, &quot;10&quot;, PartitionType.RANGE, &quot;int2&quot;);</b>
&nbsp;
<b class="fc">&nbsp;        Partition int1_int2_int3_1_5 = int1_int2_1_5.ensureRangePartitionWithSubPartitionExists(&quot;int1_int2_int3_1_5&quot;, &quot;1&quot;, &quot;5&quot;, PartitionType.RANGE, &quot;int3&quot;);</b>
<b class="fc">&nbsp;        Partition int1_int2_int3_5_10 = int1_int2_1_5.ensureRangePartitionWithSubPartitionExists(&quot;int1_int2_int3_5_10&quot;, &quot;5&quot;, &quot;10&quot;, PartitionType.RANGE, &quot;int3&quot;);</b>
&nbsp;
<b class="fc">&nbsp;        int1_int2_int3_1_5.ensureRangePartitionExists(&quot;int1_int2_int3_int4_1_5&quot;, &quot;1&quot;, &quot;5&quot;);</b>
<b class="fc">&nbsp;        int1_int2_int3_1_5.ensureRangePartitionExists(&quot;int1_int2_int3_int4_5_10&quot;, &quot;5&quot;, &quot;10&quot;);</b>
&nbsp;
<b class="fc">&nbsp;        this.sqlgGraph.tx().commit();</b>
&nbsp;
<b class="fc">&nbsp;        Assert.assertEquals(4, this.sqlgGraph.getTopology().getVertexLabel(&quot;A&quot;, &quot;A&quot;).get().getIndexes().size());</b>
&nbsp;
<b class="fc">&nbsp;        try (SqlgGraph sqlgGraph1 = SqlgGraph.open(configuration)) {</b>
<b class="fc">&nbsp;            Map&lt;String, Partition&gt; partitions = sqlgGraph1.getTopology().getSchema(&quot;A&quot;).get().getVertexLabel(&quot;A&quot;).get().getPartitions();</b>
<b class="fc">&nbsp;            Assert.assertEquals(2, partitions.size());</b>
<b class="fc">&nbsp;            Assert.assertTrue(partitions.containsKey(&quot;int1_1_5&quot;));</b>
<b class="fc">&nbsp;            Assert.assertTrue(partitions.containsKey(&quot;int1_5_10&quot;));</b>
&nbsp;
<b class="fc">&nbsp;            Partition p = partitions.get(&quot;int1_1_5&quot;);</b>
<b class="fc">&nbsp;            Assert.assertEquals(2, p.getPartitions().size());</b>
<b class="fc">&nbsp;            Assert.assertTrue(p.getPartitions().containsKey(&quot;int1_int2_1_5&quot;));</b>
<b class="fc">&nbsp;            Assert.assertTrue(p.getPartitions().containsKey(&quot;int1_int2_5_10&quot;));</b>
&nbsp;
<b class="fc">&nbsp;            p = p.getPartitions().get(&quot;int1_int2_1_5&quot;);</b>
<b class="fc">&nbsp;            Assert.assertEquals(2, p.getPartitions().size());</b>
<b class="fc">&nbsp;            Assert.assertTrue(p.getPartitions().containsKey(&quot;int1_int2_int3_1_5&quot;));</b>
<b class="fc">&nbsp;            Assert.assertTrue(p.getPartitions().containsKey(&quot;int1_int2_int3_5_10&quot;));</b>
&nbsp;
<b class="fc">&nbsp;            p = p.getPartitions().get(&quot;int1_int2_int3_1_5&quot;);</b>
<b class="fc">&nbsp;            Assert.assertEquals(2, p.getPartitions().size());</b>
<b class="fc">&nbsp;            Assert.assertTrue(p.getPartitions().containsKey(&quot;int1_int2_int3_int4_1_5&quot;));</b>
<b class="fc">&nbsp;            Assert.assertTrue(p.getPartitions().containsKey(&quot;int1_int2_int3_int4_5_10&quot;));</b>
&nbsp;
<b class="fc">&nbsp;            Assert.assertEquals(4, sqlgGraph1.getTopology().getSchema(&quot;A&quot;).get().getVertexLabel(&quot;A&quot;).get().getIndexes().size());</b>
&nbsp;        } catch (Exception e) {
<b class="nc">&nbsp;            Assert.fail(e.getMessage());</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    @Test
&nbsp;    public void testCreateIndexOnSubPartitionedVertexLabelAfterCreatingPartitions() {
<b class="fc">&nbsp;        Schema schema = this.sqlgGraph.getTopology().ensureSchemaExist(&quot;A&quot;);</b>
<b class="fc">&nbsp;        VertexLabel vertexLabel = schema.ensurePartitionedVertexLabelExist(&quot;A&quot;,</b>
<b class="fc">&nbsp;                new HashMap&lt;&gt;() {{</b>
<b class="fc">&nbsp;                    put(&quot;int1&quot;, PropertyDefinition.of(PropertyType.INTEGER));</b>
<b class="fc">&nbsp;                    put(&quot;int2&quot;, PropertyDefinition.of(PropertyType.INTEGER));</b>
<b class="fc">&nbsp;                    put(&quot;int3&quot;, PropertyDefinition.of(PropertyType.INTEGER));</b>
<b class="fc">&nbsp;                    put(&quot;int4&quot;, PropertyDefinition.of(PropertyType.INTEGER));</b>
&nbsp;                }},
<b class="fc">&nbsp;                ListOrderedSet.listOrderedSet(Arrays.asList(&quot;int1&quot;, &quot;int2&quot;, &quot;int3&quot;)),</b>
&nbsp;                PartitionType.RANGE,
&nbsp;                &quot;int1&quot;);
&nbsp;
<b class="fc">&nbsp;        Partition int1_1_5 = vertexLabel.ensureRangePartitionWithSubPartitionExists(&quot;int1_1_5&quot;, &quot;1&quot;, &quot;5&quot;, PartitionType.RANGE, &quot;int2&quot;);</b>
<b class="fc">&nbsp;        Partition int1_5_10 = vertexLabel.ensureRangePartitionWithSubPartitionExists(&quot;int1_5_10&quot;, &quot;5&quot;, &quot;10&quot;, PartitionType.RANGE, &quot;int2&quot;);</b>
&nbsp;
<b class="fc">&nbsp;        Partition int1_int2_1_5 = int1_1_5.ensureRangePartitionWithSubPartitionExists(&quot;int1_int2_1_5&quot;, &quot;1&quot;, &quot;5&quot;, PartitionType.RANGE, &quot;int2&quot;);</b>
<b class="fc">&nbsp;        Partition int1_int2_5_10 = int1_1_5.ensureRangePartitionWithSubPartitionExists(&quot;int1_int2_5_10&quot;, &quot;5&quot;, &quot;10&quot;, PartitionType.RANGE, &quot;int2&quot;);</b>
&nbsp;
<b class="fc">&nbsp;        Partition int1_int2_int3_1_5 = int1_int2_1_5.ensureRangePartitionWithSubPartitionExists(&quot;int1_int2_int3_1_5&quot;, &quot;1&quot;, &quot;5&quot;, PartitionType.RANGE, &quot;int3&quot;);</b>
<b class="fc">&nbsp;        Partition int1_int2_int3_5_10 = int1_int2_1_5.ensureRangePartitionWithSubPartitionExists(&quot;int1_int2_int3_5_10&quot;, &quot;5&quot;, &quot;10&quot;, PartitionType.RANGE, &quot;int3&quot;);</b>
&nbsp;
<b class="fc">&nbsp;        int1_int2_int3_1_5.ensureRangePartitionExists(&quot;int1_int2_int3_int4_1_5&quot;, &quot;1&quot;, &quot;5&quot;);</b>
<b class="fc">&nbsp;        int1_int2_int3_1_5.ensureRangePartitionExists(&quot;int1_int2_int3_int4_5_10&quot;, &quot;5&quot;, &quot;10&quot;);</b>
&nbsp;
<b class="fc">&nbsp;        this.sqlgGraph.tx().commit();</b>
&nbsp;
<b class="fc">&nbsp;        PropertyColumn propertyColumnInt1 = vertexLabel.getProperty(&quot;int1&quot;).get();</b>
<b class="fc">&nbsp;        Index index1 = vertexLabel.ensureIndexExists(IndexType.UNIQUE, Collections.singletonList(propertyColumnInt1));</b>
<b class="fc">&nbsp;        PropertyColumn propertyColumnInt2 = vertexLabel.getProperty(&quot;int2&quot;).get();</b>
<b class="fc">&nbsp;        Index index2 = vertexLabel.ensureIndexExists(IndexType.UNIQUE, Collections.singletonList(propertyColumnInt2));</b>
<b class="fc">&nbsp;        PropertyColumn propertyColumnInt3 = vertexLabel.getProperty(&quot;int3&quot;).get();</b>
<b class="fc">&nbsp;        Index index3 = vertexLabel.ensureIndexExists(IndexType.UNIQUE, Collections.singletonList(propertyColumnInt3));</b>
<b class="fc">&nbsp;        PropertyColumn propertyColumnInt4 = vertexLabel.getProperty(&quot;int4&quot;).get();</b>
<b class="fc">&nbsp;        Index index4 = vertexLabel.ensureIndexExists(IndexType.UNIQUE, Collections.singletonList(propertyColumnInt4));</b>
<b class="fc">&nbsp;        Assert.assertEquals(4, this.sqlgGraph.getTopology().getVertexLabel(&quot;A&quot;, &quot;A&quot;).get().getIndexes().size());</b>
<b class="fc">&nbsp;        this.sqlgGraph.tx().commit();</b>
&nbsp;
<b class="fc">&nbsp;        try (SqlgGraph sqlgGraph1 = SqlgGraph.open(configuration)) {</b>
<b class="fc">&nbsp;            Map&lt;String, Partition&gt; partitions = sqlgGraph1.getTopology().getSchema(&quot;A&quot;).get().getVertexLabel(&quot;A&quot;).get().getPartitions();</b>
<b class="fc">&nbsp;            Assert.assertEquals(2, partitions.size());</b>
<b class="fc">&nbsp;            Assert.assertTrue(partitions.containsKey(&quot;int1_1_5&quot;));</b>
<b class="fc">&nbsp;            Assert.assertTrue(partitions.containsKey(&quot;int1_5_10&quot;));</b>
&nbsp;
<b class="fc">&nbsp;            Partition p = partitions.get(&quot;int1_1_5&quot;);</b>
<b class="fc">&nbsp;            Assert.assertEquals(2, p.getPartitions().size());</b>
<b class="fc">&nbsp;            Assert.assertTrue(p.getPartitions().containsKey(&quot;int1_int2_1_5&quot;));</b>
<b class="fc">&nbsp;            Assert.assertTrue(p.getPartitions().containsKey(&quot;int1_int2_5_10&quot;));</b>
&nbsp;
<b class="fc">&nbsp;            p = p.getPartitions().get(&quot;int1_int2_1_5&quot;);</b>
<b class="fc">&nbsp;            Assert.assertEquals(2, p.getPartitions().size());</b>
<b class="fc">&nbsp;            Assert.assertTrue(p.getPartitions().containsKey(&quot;int1_int2_int3_1_5&quot;));</b>
<b class="fc">&nbsp;            Assert.assertTrue(p.getPartitions().containsKey(&quot;int1_int2_int3_5_10&quot;));</b>
&nbsp;
<b class="fc">&nbsp;            p = p.getPartitions().get(&quot;int1_int2_int3_1_5&quot;);</b>
<b class="fc">&nbsp;            Assert.assertEquals(2, p.getPartitions().size());</b>
<b class="fc">&nbsp;            Assert.assertTrue(p.getPartitions().containsKey(&quot;int1_int2_int3_int4_1_5&quot;));</b>
<b class="fc">&nbsp;            Assert.assertTrue(p.getPartitions().containsKey(&quot;int1_int2_int3_int4_5_10&quot;));</b>
&nbsp;
<b class="fc">&nbsp;            Assert.assertEquals(4, sqlgGraph1.getTopology().getSchema(&quot;A&quot;).get().getVertexLabel(&quot;A&quot;).get().getIndexes().size());</b>
&nbsp;        } catch (Exception e) {
<b class="nc">&nbsp;            Assert.fail(e.getMessage());</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    @Test
&nbsp;    public void testCreateIndexOnSubPartitionedVertexLabelAndEdgeBeforeCreatingPartitions() {
&nbsp;
<b class="fc">&nbsp;        Schema aSchema = this.sqlgGraph.getTopology().ensureSchemaExist(&quot;A&quot;);</b>
<b class="fc">&nbsp;        Schema bSchema = this.sqlgGraph.getTopology().ensureSchemaExist(&quot;B&quot;);</b>
<b class="fc">&nbsp;        VertexLabel a = aSchema.ensurePartitionedVertexLabelExist(</b>
&nbsp;                &quot;A&quot;,
<b class="fc">&nbsp;                new HashMap&lt;&gt;() {{</b>
<b class="fc">&nbsp;                    put(&quot;uid&quot;, PropertyDefinition.of(PropertyType.STRING));</b>
<b class="fc">&nbsp;                    put(&quot;int1&quot;, PropertyDefinition.of(PropertyType.INTEGER));</b>
<b class="fc">&nbsp;                    put(&quot;int2&quot;, PropertyDefinition.of(PropertyType.INTEGER));</b>
<b class="fc">&nbsp;                    put(&quot;int3&quot;, PropertyDefinition.of(PropertyType.INTEGER));</b>
<b class="fc">&nbsp;                    put(&quot;int4&quot;, PropertyDefinition.of(PropertyType.INTEGER));</b>
&nbsp;                }},
<b class="fc">&nbsp;                ListOrderedSet.listOrderedSet(Collections.singletonList(&quot;uid&quot;)),</b>
&nbsp;                PartitionType.LIST,
&nbsp;                &quot;int1&quot;, false);
<b class="fc">&nbsp;        VertexLabel b = bSchema.ensurePartitionedVertexLabelExist(</b>
&nbsp;                &quot;B&quot;,
<b class="fc">&nbsp;                new HashMap&lt;&gt;() {{</b>
<b class="fc">&nbsp;                    put(&quot;uid&quot;, PropertyDefinition.of(PropertyType.STRING));</b>
<b class="fc">&nbsp;                    put(&quot;int1&quot;, PropertyDefinition.of(PropertyType.INTEGER));</b>
<b class="fc">&nbsp;                    put(&quot;int2&quot;, PropertyDefinition.of(PropertyType.INTEGER));</b>
<b class="fc">&nbsp;                    put(&quot;int3&quot;, PropertyDefinition.of(PropertyType.INTEGER));</b>
<b class="fc">&nbsp;                    put(&quot;int4&quot;, PropertyDefinition.of(PropertyType.INTEGER));</b>
&nbsp;                }},
<b class="fc">&nbsp;                ListOrderedSet.listOrderedSet(Collections.singletonList(&quot;uid&quot;)),</b>
&nbsp;                PartitionType.LIST,
&nbsp;                &quot;int1&quot;, false);
&nbsp;
<b class="fc">&nbsp;        EdgeLabel ab = a.ensurePartitionedEdgeLabelExist(</b>
&nbsp;                &quot;ab&quot;,
&nbsp;                b,
<b class="fc">&nbsp;                new HashMap&lt;&gt;() {{</b>
<b class="fc">&nbsp;                    put(&quot;uid&quot;, PropertyDefinition.of(PropertyType.STRING));</b>
<b class="fc">&nbsp;                    put(&quot;int1&quot;, PropertyDefinition.of(PropertyType.INTEGER));</b>
<b class="fc">&nbsp;                    put(&quot;int2&quot;, PropertyDefinition.of(PropertyType.INTEGER));</b>
<b class="fc">&nbsp;                    put(&quot;int3&quot;, PropertyDefinition.of(PropertyType.INTEGER));</b>
<b class="fc">&nbsp;                    put(&quot;int4&quot;, PropertyDefinition.of(PropertyType.INTEGER));</b>
&nbsp;                }},
<b class="fc">&nbsp;                ListOrderedSet.listOrderedSet(List.of(&quot;uid&quot;, &quot;int1&quot;, &quot;int2&quot;, &quot;int3&quot;, &quot;int4&quot;)),</b>
&nbsp;                PartitionType.LIST,
&nbsp;                &quot;int1&quot;);
&nbsp;
<b class="fc">&nbsp;        a.ensureIndexExists(IndexType.NON_UNIQUE, Collections.singletonList(a.getProperty(&quot;int1&quot;).orElseThrow()));</b>
<b class="fc">&nbsp;        a.ensureIndexExists(IndexType.NON_UNIQUE, Collections.singletonList(a.getProperty(&quot;int2&quot;).orElseThrow()));</b>
<b class="fc">&nbsp;        a.ensureIndexExists(IndexType.NON_UNIQUE, Collections.singletonList(a.getProperty(&quot;int3&quot;).orElseThrow()));</b>
<b class="fc">&nbsp;        a.ensureIndexExists(IndexType.NON_UNIQUE, Collections.singletonList(a.getProperty(&quot;int4&quot;).orElseThrow()));</b>
&nbsp;
<b class="fc">&nbsp;        Partition aInt1_1 = a.ensureListPartitionWithSubPartitionExists(&quot;aInt1_1&quot;, &quot;1&quot;, PartitionType.LIST, &quot;int2&quot;);</b>
<b class="fc">&nbsp;        Partition aInt1_2 = a.ensureListPartitionWithSubPartitionExists(&quot;aInt1_2&quot;, &quot;2&quot;, PartitionType.LIST, &quot;int2&quot;);</b>
<b class="fc">&nbsp;        Partition bInt1_1 = b.ensureListPartitionWithSubPartitionExists(&quot;bInt1_1&quot;, &quot;1&quot;, PartitionType.LIST, &quot;int2&quot;);</b>
<b class="fc">&nbsp;        Partition bInt1_2 = b.ensureListPartitionWithSubPartitionExists(&quot;bInt1_2&quot;, &quot;2&quot;, PartitionType.LIST, &quot;int2&quot;);</b>
&nbsp;
<b class="fc">&nbsp;        Partition aInt1_1_int2_1 = aInt1_1.ensureListPartitionWithSubPartitionExists(&quot;aInt_1_int2_1&quot;, &quot;1&quot;, PartitionType.LIST, &quot;int3&quot;);</b>
<b class="fc">&nbsp;        Partition aInt1_1_int2_2 = aInt1_1.ensureListPartitionWithSubPartitionExists(&quot;aInt_1_int2_2&quot;, &quot;2&quot;, PartitionType.LIST, &quot;int3&quot;);</b>
&nbsp;
<b class="fc">&nbsp;        Partition aInt1__1_int2_int3_1 = aInt1_1_int2_1.ensureListPartitionWithSubPartitionExists(&quot;aInt1_1_int2_1_int3_1&quot;, &quot;1&quot;, PartitionType.LIST, &quot;int4&quot;);</b>
<b class="fc">&nbsp;        Partition aInt1__1_int2_int3_2 = aInt1_1_int2_1.ensureListPartitionWithSubPartitionExists(&quot;aInt1_1_int2_1_int3_2&quot;, &quot;2&quot;, PartitionType.LIST, &quot;int4&quot;);</b>
&nbsp;
<b class="fc">&nbsp;        aInt1__1_int2_int3_1.ensureListPartitionExists(&quot;aInt1_1_int2_1_int3_1_int4_1&quot;, &quot;1&quot;);</b>
<b class="fc">&nbsp;        aInt1__1_int2_int3_1.ensureListPartitionExists(&quot;aInt1_1_int2_1_int3_1_int4_2&quot;, &quot;2&quot;);</b>
&nbsp;
<b class="fc">&nbsp;        Partition bInt1_int2_1 = bInt1_1.ensureListPartitionWithSubPartitionExists(&quot;bInt1_int2_1&quot;, &quot;1&quot;, PartitionType.LIST, &quot;int3&quot;);</b>
<b class="fc">&nbsp;        Partition bInt1_int2_2 = bInt1_1.ensureListPartitionWithSubPartitionExists(&quot;bInt1_int2_2&quot;, &quot;2&quot;, PartitionType.LIST, &quot;int3&quot;);</b>
&nbsp;
<b class="fc">&nbsp;        Partition bInt1_int2_int3_1 = bInt1_int2_1.ensureListPartitionWithSubPartitionExists(&quot;bInt1_int2_int3_1&quot;, &quot;1&quot;, PartitionType.LIST, &quot;int4&quot;);</b>
<b class="fc">&nbsp;        Partition bInt1_int2_int3_2 = bInt1_int2_1.ensureListPartitionWithSubPartitionExists(&quot;bInt1_int2_int3_2&quot;, &quot;2&quot;, PartitionType.LIST, &quot;int4&quot;);</b>
&nbsp;
<b class="fc">&nbsp;        bInt1_int2_int3_1.ensureListPartitionExists(&quot;bInt1_int2_int3_int4_1&quot;, &quot;1&quot;);</b>
<b class="fc">&nbsp;        bInt1_int2_int3_1.ensureListPartitionExists(&quot;bInt1_int2_int3_int4_2&quot;, &quot;2&quot;);</b>
&nbsp;
<b class="fc">&nbsp;        Partition abInt1_1 = ab.ensureListPartitionWithSubPartitionExists(&quot;abInt1_1&quot;, &quot;1&quot;, PartitionType.LIST, &quot;int2&quot;);</b>
<b class="fc">&nbsp;        Partition abInt1_2 = ab.ensureListPartitionWithSubPartitionExists(&quot;abInt1_2&quot;, &quot;2&quot;, PartitionType.LIST, &quot;int2&quot;);</b>
&nbsp;
<b class="fc">&nbsp;        Partition abInt1_int2_1 = abInt1_1.ensureListPartitionWithSubPartitionExists(&quot;abInt1_int2_1&quot;, &quot;1&quot;, PartitionType.LIST, &quot;int3&quot;);</b>
<b class="fc">&nbsp;        Partition abInt1_int2_2 = abInt1_1.ensureListPartitionWithSubPartitionExists(&quot;abInt1_int2_2&quot;, &quot;2&quot;, PartitionType.LIST, &quot;int3&quot;);</b>
&nbsp;
<b class="fc">&nbsp;        Partition abInt1_int2_int3_1 = abInt1_int2_1.ensureListPartitionWithSubPartitionExists(&quot;abInt1_int2_int3_1&quot;, &quot;1&quot;, PartitionType.LIST, &quot;int4&quot;);</b>
<b class="fc">&nbsp;        Partition abInt1_int2_int3_2 = abInt1_int2_1.ensureListPartitionWithSubPartitionExists(&quot;abInt1_int2_int3_2&quot;, &quot;2&quot;, PartitionType.LIST, &quot;int4&quot;);</b>
&nbsp;
<b class="fc">&nbsp;        abInt1_int2_int3_1.ensureListPartitionExists(&quot;abInt1_int2_int3_int4_1&quot;, &quot;1&quot;);</b>
<b class="fc">&nbsp;        abInt1_int2_int3_1.ensureListPartitionExists(&quot;abInt1_int2_int3_int4_2&quot;, &quot;2&quot;);</b>
&nbsp;
&nbsp;
<b class="fc">&nbsp;        this.sqlgGraph.tx().commit();</b>
&nbsp;
<b class="fc">&nbsp;        for (int i = 0; i &lt; 1_000; i++) {</b>
<b class="fc">&nbsp;            Vertex a1 = this.sqlgGraph.addVertex(T.label, &quot;A.A&quot;, &quot;uid&quot;, UUID.randomUUID().toString(), &quot;int1&quot;, 1, &quot;int2&quot;, 1, &quot;int3&quot;, 1, &quot;int4&quot;, 1);</b>
<b class="fc">&nbsp;            Vertex b1 = this.sqlgGraph.addVertex(T.label, &quot;B.B&quot;, &quot;uid&quot;, UUID.randomUUID().toString(), &quot;int1&quot;, 1, &quot;int2&quot;, 1, &quot;int3&quot;, 1, &quot;int4&quot;, 1);</b>
<b class="fc">&nbsp;            a1.addEdge(&quot;ab&quot;, b1, &quot;uid&quot;, UUID.randomUUID().toString(), &quot;int1&quot;, 1, &quot;int2&quot;, 1, &quot;int3&quot;, 1, &quot;int4&quot;, 1);</b>
<b class="fc">&nbsp;            a1.addEdge(&quot;ab&quot;, b1, &quot;uid&quot;, UUID.randomUUID().toString(), &quot;int1&quot;, 1, &quot;int2&quot;, 1, &quot;int3&quot;, 1, &quot;int4&quot;, 2);</b>
&nbsp;        }
<b class="fc">&nbsp;        Vertex a2 = this.sqlgGraph.addVertex(T.label, &quot;A.A&quot;, &quot;uid&quot;, UUID.randomUUID().toString(), &quot;int1&quot;, 1, &quot;int2&quot;, 1, &quot;int3&quot;, 1, &quot;int4&quot;, 2);</b>
<b class="fc">&nbsp;        Vertex b2 = this.sqlgGraph.addVertex(T.label, &quot;B.B&quot;, &quot;uid&quot;, UUID.randomUUID().toString(), &quot;int1&quot;, 1, &quot;int2&quot;, 1, &quot;int3&quot;, 1, &quot;int4&quot;, 2);</b>
<b class="fc">&nbsp;        a2.addEdge(&quot;ab&quot;, b2, &quot;uid&quot;, UUID.randomUUID().toString(), &quot;int1&quot;, 1, &quot;int2&quot;, 1, &quot;int3&quot;, 1, &quot;int4&quot;, 1);</b>
<b class="fc">&nbsp;        a2.addEdge(&quot;ab&quot;, b2, &quot;uid&quot;, UUID.randomUUID().toString(), &quot;int1&quot;, 1, &quot;int2&quot;, 1, &quot;int3&quot;, 1, &quot;int4&quot;, 2);</b>
<b class="fc">&nbsp;        this.sqlgGraph.tx().commit();</b>
&nbsp;
<b class="fc">&nbsp;        List&lt;Vertex&gt; vertices = this.sqlgGraph.traversal()</b>
<b class="fc">&nbsp;                .V().hasLabel(&quot;A.A&quot;).has(&quot;int1&quot;, 1)</b>
<b class="fc">&nbsp;                .outE(&quot;ab&quot;).has(&quot;int1&quot;, 1)</b>
<b class="fc">&nbsp;                .inV().has(&quot;int4&quot;, 2).toList();</b>
<b class="fc">&nbsp;        Assert.assertEquals(2, vertices.size());</b>
&nbsp;    }
&nbsp;
&nbsp;    @Test
&nbsp;    public void testListPartitiongetsIndex() {
<b class="fc">&nbsp;        String VIRTUAL_GROUP_PARENT_NAME = &quot;virtualGroupParentName&quot;;</b>
<b class="fc">&nbsp;        String VIRTUAL_GROUP_NAME = &quot;virtualGroupName&quot;;</b>
<b class="fc">&nbsp;        String VIRTUAL_GROUP_ID = &quot;virtualGroupId&quot;;</b>
<b class="fc">&nbsp;        String vendorTechnology = &quot;vendorTechnology&quot;;</b>
<b class="fc">&nbsp;        String etlElementName = &quot;etlElementName&quot;;</b>
<b class="fc">&nbsp;        String cmUid = &quot;cmUid&quot;;</b>
<b class="fc">&nbsp;        String internal_cm_name = &quot;internal_cm_name&quot;;</b>
<b class="fc">&nbsp;        String IS_CALCULATED = &quot;isCalculated&quot;;</b>
<b class="fc">&nbsp;        String IS_DELETED = &quot;isDeleted&quot;;</b>
<b class="fc">&nbsp;        String VIRTUAL_GROUP_ROOT_REAL_WORKSPACE_ELEMENT_LABEL = &quot;VGReal&quot;;</b>
&nbsp;
<b class="fc">&nbsp;        LinkedHashMap&lt;String, PropertyDefinition&gt; attributeMap = new LinkedHashMap&lt;&gt;();</b>
<b class="fc">&nbsp;        attributeMap.put(VIRTUAL_GROUP_PARENT_NAME, PropertyDefinition.of(PropertyType.STRING));</b>
<b class="fc">&nbsp;        attributeMap.put(VIRTUAL_GROUP_NAME, PropertyDefinition.of(PropertyType.STRING));</b>
<b class="fc">&nbsp;        attributeMap.put(VIRTUAL_GROUP_ID, PropertyDefinition.of(PropertyType.LONG));</b>
<b class="fc">&nbsp;        attributeMap.put(vendorTechnology, PropertyDefinition.of(PropertyType.STRING));</b>
<b class="fc">&nbsp;        attributeMap.put(etlElementName, PropertyDefinition.of(PropertyType.STRING));</b>
<b class="fc">&nbsp;        attributeMap.put(cmUid, PropertyDefinition.of(PropertyType.STRING));</b>
<b class="fc">&nbsp;        attributeMap.put(internal_cm_name, PropertyDefinition.of(PropertyType.STRING));</b>
<b class="fc">&nbsp;        attributeMap.put(IS_CALCULATED, PropertyDefinition.of(PropertyType.BOOLEAN));</b>
<b class="fc">&nbsp;        attributeMap.put(IS_DELETED, PropertyDefinition.of(PropertyType.BOOLEAN));</b>
&nbsp;
<b class="fc">&nbsp;        VertexLabel virtualGroupRootRealWorkspaceElementVertexLabel = sqlgGraph.getTopology().getPublicSchema().ensurePartitionedVertexLabelExist(</b>
&nbsp;                VIRTUAL_GROUP_ROOT_REAL_WORKSPACE_ELEMENT_LABEL,
&nbsp;                attributeMap,
<b class="fc">&nbsp;                ListOrderedSet.listOrderedSet(List.of(cmUid, VIRTUAL_GROUP_ID)),</b>
&nbsp;                PartitionType.LIST,
&nbsp;                &quot;\&quot;&quot; + VIRTUAL_GROUP_ID + &quot;\&quot;&quot;
&nbsp;        );
&nbsp;
&nbsp;        //Unique index, element can only appear once per virtual group parent
<b class="fc">&nbsp;        PropertyColumn cmUidPropertyColumn = virtualGroupRootRealWorkspaceElementVertexLabel.getProperty(cmUid).orElseThrow();</b>
<b class="fc">&nbsp;        virtualGroupRootRealWorkspaceElementVertexLabel.ensureIndexExists(IndexType.UNIQUE, Collections.singletonList(cmUidPropertyColumn));</b>
&nbsp;
<b class="fc">&nbsp;        this.sqlgGraph.tx().commit();</b>
&nbsp;
<b class="fc">&nbsp;        int virtualGroupId = 1;</b>
<b class="fc">&nbsp;        VertexLabel realVertexLabel = sqlgGraph.getTopology().getPublicSchema().getVertexLabel(VIRTUAL_GROUP_ROOT_REAL_WORKSPACE_ELEMENT_LABEL).orElseThrow();</b>
<b class="fc">&nbsp;        Partition partition = realVertexLabel.ensureListPartitionExists(</b>
&nbsp;                &quot;VirtualGroupRootReal_&quot; + virtualGroupId,
&nbsp;                &quot;&#39;&quot; + virtualGroupId + &quot;&#39;&quot;
&nbsp;        );
&nbsp;
<b class="fc">&nbsp;        this.sqlgGraph.tx().commit();</b>
&nbsp;
<b class="fc">&nbsp;        realVertexLabel = sqlgGraph.getTopology().getPublicSchema().getVertexLabel(VIRTUAL_GROUP_ROOT_REAL_WORKSPACE_ELEMENT_LABEL).orElseThrow();</b>
<b class="fc">&nbsp;        Optional&lt;Partition&gt; partitionOptional = realVertexLabel.getPartition(partition.getName());</b>
<b class="fc">&nbsp;        Assert.assertTrue(partitionOptional.isPresent());</b>
<b class="fc">&nbsp;        Map&lt;String, Index&gt; indexMap = realVertexLabel.getIndexes();</b>
<b class="fc">&nbsp;        Assert.assertEquals(1, indexMap.size());</b>
&nbsp;
&nbsp;        //Check if the index is being used
<b class="fc">&nbsp;        Connection conn = this.sqlgGraph.tx().getConnection();</b>
<b class="fc">&nbsp;        try (Statement statement = conn.createStatement()) {</b>
<b class="pc">&nbsp;            if (this.sqlgGraph.getSqlDialect().getClass().getSimpleName().contains(&quot;Postgres&quot;)) {</b>
<b class="fc">&nbsp;                ResultSet rs = statement.executeQuery(&quot;explain analyze SELECT * FROM \&quot;public\&quot;.\&quot;V_&quot; + VIRTUAL_GROUP_ROOT_REAL_WORKSPACE_ELEMENT_LABEL + &quot;\&quot; a WHERE a.\&quot;&quot; + cmUid + &quot;\&quot; = &#39;john&#39;&quot;);</b>
<b class="fc">&nbsp;                Assert.assertTrue(rs.next());</b>
<b class="fc">&nbsp;                String result = rs.getString(1);</b>
<b class="fc">&nbsp;                System.out.println(result);</b>
<b class="pc">&nbsp;                Assert.assertTrue(result.contains(&quot;Index Scan&quot;) || result.contains(&quot;Bitmap Heap Scan&quot;));</b>
&nbsp;            }
&nbsp;        } catch (SQLException e) {
<b class="nc">&nbsp;            Assert.fail(e.getMessage());</b>
&nbsp;        }
&nbsp;
&nbsp;    }
&nbsp;
&nbsp;    @Test
&nbsp;    public void testRangePartitiongetsIndex() {
<b class="fc">&nbsp;        String VIRTUAL_GROUP_PARENT_NAME = &quot;virtualGroupParentName&quot;;</b>
<b class="fc">&nbsp;        String VIRTUAL_GROUP_NAME = &quot;virtualGroupName&quot;;</b>
<b class="fc">&nbsp;        String VIRTUAL_GROUP_ID = &quot;virtualGroupId&quot;;</b>
<b class="fc">&nbsp;        String vendorTechnology = &quot;vendorTechnology&quot;;</b>
<b class="fc">&nbsp;        String etlElementName = &quot;etlElementName&quot;;</b>
<b class="fc">&nbsp;        String cmUid = &quot;cmUid&quot;;</b>
<b class="fc">&nbsp;        String internal_cm_name = &quot;internal_cm_name&quot;;</b>
<b class="fc">&nbsp;        String IS_CALCULATED = &quot;isCalculated&quot;;</b>
<b class="fc">&nbsp;        String IS_DELETED = &quot;isDeleted&quot;;</b>
<b class="fc">&nbsp;        String VIRTUAL_GROUP_ROOT_REAL_WORKSPACE_ELEMENT_LABEL = &quot;VGReal&quot;;</b>
&nbsp;
<b class="fc">&nbsp;        LinkedHashMap&lt;String, PropertyDefinition&gt; attributeMap = new LinkedHashMap&lt;&gt;();</b>
<b class="fc">&nbsp;        attributeMap.put(VIRTUAL_GROUP_PARENT_NAME, PropertyDefinition.of(PropertyType.STRING));</b>
<b class="fc">&nbsp;        attributeMap.put(VIRTUAL_GROUP_NAME, PropertyDefinition.of(PropertyType.STRING));</b>
<b class="fc">&nbsp;        attributeMap.put(VIRTUAL_GROUP_ID, PropertyDefinition.of(PropertyType.LONG));</b>
<b class="fc">&nbsp;        attributeMap.put(vendorTechnology, PropertyDefinition.of(PropertyType.STRING));</b>
<b class="fc">&nbsp;        attributeMap.put(etlElementName, PropertyDefinition.of(PropertyType.STRING));</b>
<b class="fc">&nbsp;        attributeMap.put(cmUid, PropertyDefinition.of(PropertyType.STRING));</b>
<b class="fc">&nbsp;        attributeMap.put(internal_cm_name, PropertyDefinition.of(PropertyType.STRING));</b>
<b class="fc">&nbsp;        attributeMap.put(IS_CALCULATED, PropertyDefinition.of(PropertyType.BOOLEAN));</b>
<b class="fc">&nbsp;        attributeMap.put(IS_DELETED, PropertyDefinition.of(PropertyType.BOOLEAN));</b>
&nbsp;
<b class="fc">&nbsp;        VertexLabel virtualGroupRootRealWorkspaceElementVertexLabel = sqlgGraph.getTopology().getPublicSchema().ensurePartitionedVertexLabelExist(</b>
&nbsp;                VIRTUAL_GROUP_ROOT_REAL_WORKSPACE_ELEMENT_LABEL,
&nbsp;                attributeMap,
<b class="fc">&nbsp;                ListOrderedSet.listOrderedSet(List.of(cmUid, VIRTUAL_GROUP_ID)),</b>
&nbsp;                PartitionType.RANGE,
&nbsp;                &quot;\&quot;&quot; + VIRTUAL_GROUP_ID + &quot;\&quot;&quot;
&nbsp;        );
&nbsp;
&nbsp;        //Unique index, element can only appear once per virtual group parent
<b class="fc">&nbsp;        PropertyColumn cmUidPropertyColumn = virtualGroupRootRealWorkspaceElementVertexLabel.getProperty(cmUid).orElseThrow();</b>
<b class="fc">&nbsp;        virtualGroupRootRealWorkspaceElementVertexLabel.ensureIndexExists(IndexType.UNIQUE, Collections.singletonList(cmUidPropertyColumn));</b>
&nbsp;
<b class="fc">&nbsp;        this.sqlgGraph.tx().commit();</b>
&nbsp;
<b class="fc">&nbsp;        int virtualGroupId = 1;</b>
<b class="fc">&nbsp;        int virtualGroupIdTo = 2;</b>
<b class="fc">&nbsp;        VertexLabel realVertexLabel = sqlgGraph.getTopology().getPublicSchema().getVertexLabel(VIRTUAL_GROUP_ROOT_REAL_WORKSPACE_ELEMENT_LABEL).orElseThrow();</b>
<b class="fc">&nbsp;        Partition partition = realVertexLabel.ensureRangePartitionExists(</b>
&nbsp;                &quot;VirtualGroupRootReal_&quot; + virtualGroupId,
&nbsp;                &quot;&#39;&quot; + virtualGroupId + &quot;&#39;&quot;,
&nbsp;                &quot;&#39;&quot; + virtualGroupIdTo + &quot;&#39;&quot;
&nbsp;        );
&nbsp;
<b class="fc">&nbsp;        this.sqlgGraph.tx().commit();</b>
&nbsp;
<b class="fc">&nbsp;        realVertexLabel = sqlgGraph.getTopology().getPublicSchema().getVertexLabel(VIRTUAL_GROUP_ROOT_REAL_WORKSPACE_ELEMENT_LABEL).orElseThrow();</b>
<b class="fc">&nbsp;        Optional&lt;Partition&gt; partitionOptional = realVertexLabel.getPartition(partition.getName());</b>
<b class="fc">&nbsp;        Assert.assertTrue(partitionOptional.isPresent());</b>
<b class="fc">&nbsp;        Map&lt;String, Index&gt; indexMap = realVertexLabel.getIndexes();</b>
<b class="fc">&nbsp;        Assert.assertEquals(1, indexMap.size());</b>
&nbsp;
&nbsp;        //Check if the index is being used
<b class="fc">&nbsp;        Connection conn = this.sqlgGraph.tx().getConnection();</b>
<b class="fc">&nbsp;        try (Statement statement = conn.createStatement()) {</b>
<b class="pc">&nbsp;            if (this.sqlgGraph.getSqlDialect().getClass().getSimpleName().contains(&quot;Postgres&quot;)) {</b>
<b class="fc">&nbsp;                ResultSet rs = statement.executeQuery(&quot;explain analyze SELECT * FROM \&quot;public\&quot;.\&quot;V_&quot; + VIRTUAL_GROUP_ROOT_REAL_WORKSPACE_ELEMENT_LABEL + &quot;\&quot; a WHERE a.\&quot;&quot; + cmUid + &quot;\&quot; = &#39;john&#39;&quot;);</b>
<b class="fc">&nbsp;                Assert.assertTrue(rs.next());</b>
<b class="fc">&nbsp;                String result = rs.getString(1);</b>
<b class="fc">&nbsp;                System.out.println(result);</b>
<b class="pc">&nbsp;                Assert.assertTrue(result.contains(&quot;Index Scan&quot;) || result.contains(&quot;Bitmap Heap Scan&quot;));</b>
&nbsp;            }
&nbsp;        } catch (SQLException e) {
<b class="nc">&nbsp;            Assert.fail(e.getMessage());</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;}
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2025-06-23 10:13</div>
</div>
</body>
</html>
