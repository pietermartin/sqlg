


<!DOCTYPE html>
<html id="htmlId">
<head>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8"> 
  <title>Coverage Report > TestUnion</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope:     <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">org.umlg.sqlg.test.union</a>
</div>

<h1>Coverage Summary for Class: TestUnion (org.umlg.sqlg.test.union)</h1>

<table class="coverageStats">
<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Class, %
</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Branch, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">TestUnion</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/19)
  </span>
</td>
</tr>

</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode">&nbsp;package org.umlg.sqlg.test.union;
&nbsp;
&nbsp;import org.apache.tinkerpop.gremlin.process.traversal.Path;
&nbsp;import org.apache.tinkerpop.gremlin.process.traversal.dsl.graph.__;
&nbsp;import org.apache.tinkerpop.gremlin.structure.Vertex;
&nbsp;import org.junit.Test;
&nbsp;import org.umlg.sqlg.structure.DefaultSqlgTraversal;
&nbsp;import org.umlg.sqlg.test.BaseTest;
&nbsp;
&nbsp;import java.util.List;
&nbsp;
&nbsp;/**
&nbsp; * Date: 2016/05/30
&nbsp; * Time: 9:01 PM
&nbsp; */
&nbsp;@SuppressWarnings(&quot;unchecked&quot;)
<b class="nc">&nbsp;public class TestUnion extends BaseTest {</b>
&nbsp;
&nbsp;//    @Test
&nbsp;//    public void g_V_hasXperson_name_markoX_path_asXaX_unionXidentity_identityX_selectXaX_unfold() {
&nbsp;//        loadModern();
&nbsp;//        DefaultSqlgTraversal&lt;Vertex, Vertex&gt; graphTraversal = (DefaultSqlgTraversal&lt;Vertex, Vertex&gt;) this.sqlgGraph.traversal().V().has(&quot;person&quot;, &quot;name&quot;, &quot;marko&quot;)
&nbsp;//                .path().as(&quot;a&quot;)
&nbsp;//                .union(
&nbsp;//                        __.identity(),
&nbsp;//                        __.identity()
&nbsp;//                ).select(&quot;a&quot;)
&nbsp;//                .&lt;Vertex&gt;unfold();
&nbsp;//        printTraversalForm(graphTraversal);
&nbsp;//        List&lt;Vertex&gt; result = graphTraversal.toList();
&nbsp;//        for (Vertex vertex : result) {
&nbsp;//            System.out.println(vertex);
&nbsp;//        }
&nbsp;//    }
&nbsp;
&nbsp;    @Test
&nbsp;    public void g_unionXV_out_out_V_hasLabelXsoftwareXX_path_byXnameX() {
<b class="nc">&nbsp;        loadModern();</b>
<b class="nc">&nbsp;        DefaultSqlgTraversal&lt;Vertex, Path&gt; graphTraversal = (DefaultSqlgTraversal) this.sqlgGraph.traversal().union(</b>
<b class="nc">&nbsp;                        __.V().out().out(),</b>
<b class="nc">&nbsp;                        __.V().hasLabel(&quot;software&quot;)</b>
<b class="nc">&nbsp;        ).path().by(&quot;name&quot;);</b>
<b class="nc">&nbsp;        printTraversalForm(graphTraversal);</b>
<b class="nc">&nbsp;        List&lt;Path&gt; result = graphTraversal.toList();</b>
<b class="nc">&nbsp;        for (Path path : result) {</b>
<b class="nc">&nbsp;            System.out.println(path);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    //    @Test
&nbsp;    public void g_unionXV_out_out_V_hasLabelXsoftwareXX_path() {
<b class="nc">&nbsp;        loadModern();</b>
<b class="nc">&nbsp;        DefaultSqlgTraversal&lt;Vertex, Path&gt; graphTraversal = (DefaultSqlgTraversal&lt;Vertex, Path&gt;) this.sqlgGraph.traversal().union(</b>
<b class="nc">&nbsp;                __.V().out().out(),</b>
<b class="nc">&nbsp;                __.V().hasLabel(&quot;software&quot;)</b>
<b class="nc">&nbsp;        ).path();</b>
&nbsp;
&nbsp;
<b class="nc">&nbsp;        printTraversalForm(graphTraversal);</b>
<b class="nc">&nbsp;        List&lt;Path&gt; result = graphTraversal.toList();</b>
<b class="nc">&nbsp;        for (Path path : result) {</b>
<b class="nc">&nbsp;            System.out.println(path);</b>
&nbsp;        }
&nbsp;
&nbsp;//        DefaultSqlgTraversal&lt;Path, Path&gt; graphTraversal = (DefaultSqlgTraversal&lt;Path, Path&gt;) this.sqlgGraph.traversal().union(
&nbsp;//                __.V().out().out().path(),
&nbsp;//                __.V().hasLabel(&quot;software&quot;).path()
&nbsp;//        );
&nbsp;//        printTraversalForm(graphTraversal);
&nbsp;//        List&lt;Path&gt; result = graphTraversal.toList();
&nbsp;//        for (Path path : result) {
&nbsp;//            System.out.println(path);
&nbsp;//        }
&nbsp;    }
&nbsp;
&nbsp;//    @Test
&nbsp;//    public void g_V_hasXperson_name_aliceX_propertyXsingle_age_unionXage_constantX1XX_sumX() {
&nbsp;////        this.sqlgGraph.addVertex(T.label, &quot;person&quot;, &quot;name&quot;, &quot;alice&quot;, &quot;age&quot;, 50);
&nbsp;//        this.sqlgGraph.addVertex(T.label, &quot;person&quot;, &quot;name&quot;, &quot;alice&quot;, &quot;age&quot;, 50L);
&nbsp;//        this.sqlgGraph.tx().commit();
&nbsp;//
&nbsp;//        List&lt;Vertex&gt; vertices =  this.sqlgGraph.traversal().V().has(&quot;person&quot;,&quot;name&quot;,&quot;alice&quot;)
&nbsp;//                .property(&quot;age&quot;, __.union(__.values(&quot;age&quot;), __.constant(1)).sum())
&nbsp;//                .toList();
&nbsp;//        this.sqlgGraph.tx().commit();
&nbsp;//        Assert.assertFalse(this.sqlgGraph.traversal().V().has(&quot;person&quot;,&quot;age&quot;,50L).hasNext());
&nbsp;//        Assert.assertEquals(1L, this.sqlgGraph.traversal().V().has(&quot;person&quot;,&quot;age&quot;,51L).count().next(), 0);
&nbsp;//    }
&nbsp;//
&nbsp;//    @Test
&nbsp;//    public void g_unionXconstantX1X_constantX2X_constantX3XX() {
&nbsp;//        loadModern();
&nbsp;//        GraphTraversalSource g = sqlgGraph.traversal();
&nbsp;//        DefaultSqlgTraversal&lt;String, String&gt; graphTraversal = (DefaultSqlgTraversal&lt;String, String&gt;) g.union(
&nbsp;//                __.constant(&quot;d[1].i&quot;),
&nbsp;//                __.constant(&quot;d[2].i&quot;),
&nbsp;//                __.constant(&quot;d[3].i&quot;)
&nbsp;//        );
&nbsp;//        printTraversalForm(graphTraversal);
&nbsp;//        List&lt;String&gt; result = graphTraversal.toList();
&nbsp;//        Assert.assertTrue(result.contains(&quot;d[1].i&quot;));
&nbsp;//        Assert.assertTrue(result.contains(&quot;d[2].i&quot;));
&nbsp;//        Assert.assertTrue(result.contains(&quot;d[3].i&quot;));
&nbsp;//    }
&nbsp;//
&nbsp;//    @Test
&nbsp;//    public void g_V_unionXrepeatXunionXoutXcreatedX__inXcreatedXX_timesX2X__repeatXunionXinXcreatedX__outXcreatedXX_timesX2XX_label_groupCount() {
&nbsp;//        loadModern();
&nbsp;//        final Traversal&lt;Vertex, Map&lt;String, Long&gt;&gt; traversal = (Traversal) this.sqlgGraph.traversal().V().union(
&nbsp;//                        __.repeat(__.union(
&nbsp;//                                __.out(&quot;created&quot;),
&nbsp;//                                __.in(&quot;created&quot;))).times(2),
&nbsp;//                        __.repeat(__.union(
&nbsp;//                                __.in(&quot;created&quot;),
&nbsp;//                                __.out(&quot;created&quot;))).times(2))
&nbsp;//                .label().groupCount();
&nbsp;//        final Map&lt;String, Long&gt; groupCount = traversal.next();
&nbsp;//        Assert.assertFalse(traversal.hasNext());
&nbsp;//        Assert.assertEquals(2, groupCount.size());
&nbsp;//        Assert.assertEquals(12L, groupCount.get(&quot;software&quot;).longValue());
&nbsp;//        Assert.assertEquals(20L, groupCount.get(&quot;person&quot;).longValue());
&nbsp;//    }
&nbsp;//
&nbsp;//    /**
&nbsp;//     * https://github.com/pietermartin/sqlg/issues/416
&nbsp;//     */
&nbsp;//    @Test
&nbsp;//    public void testAliasesWithinUnion() {
&nbsp;//        Vertex a = this.sqlgGraph.addVertex(T.label, &quot;A&quot;, &quot;name&quot;, &quot;A&quot;);
&nbsp;//        Vertex b = this.sqlgGraph.addVertex(T.label, &quot;B&quot;, &quot;name&quot;, &quot;B&quot;);
&nbsp;//
&nbsp;//        a.addEdge(&quot;edge&quot;, b);
&nbsp;//
&nbsp;//        // First, confirm that a simple traversal using an alias works properly.  This works as
&nbsp;//        // expected (the failure is below with the union where the exact traversal is used inside the union).
&nbsp;//        List&lt;Vertex&gt; noUnionItems = this.sqlgGraph.traversal()
&nbsp;//                .V()
&nbsp;//                .hasLabel(&quot;A&quot;)
&nbsp;//                .as(&quot;alias1&quot;)
&nbsp;//                .out()
&nbsp;//                .&lt;Vertex&gt;select(&quot;alias1&quot;)
&nbsp;//                .toList();
&nbsp;//
&nbsp;//        Assert.assertEquals(1, noUnionItems.size());
&nbsp;//        Assert.assertEquals(a, noUnionItems.get(0));
&nbsp;//
&nbsp;//        // This one doesn&#39;t work even though the exact same traversal is used inside the union.  Debugging
&nbsp;//        // the code shows that it cannot find the &quot;alias1&quot; label in the SelectOneStep (in the map method).
&nbsp;//        List&lt;Vertex&gt; unionItems = this.sqlgGraph.traversal()
&nbsp;//                .inject(&quot;ignore&quot;)       // Normally an inject would be used here, but see #415
&nbsp;//                .&lt;Vertex&gt;union(
&nbsp;//                        __.V().hasLabel(&quot;A&quot;).as(&quot;alias1&quot;).out().select(&quot;alias1&quot;)
&nbsp;//                )
&nbsp;//                .toList();
&nbsp;//
&nbsp;//        // This fails because unionItems contains 0 results.
&nbsp;//        Assert.assertEquals(1, unionItems.size());
&nbsp;//    }
&nbsp;//
&nbsp;//    @Test
&nbsp;//    public void testdkarthikeyan88_bug359() {
&nbsp;//        Graph g = this.sqlgGraph;
&nbsp;//        Vertex cluster = g.addVertex(T.label, &quot;Cluster&quot;, &quot;name&quot;, &quot;Test Cluster&quot;);
&nbsp;//        Vertex service = g.addVertex(T.label, &quot;Service&quot;, &quot;name&quot;, &quot;Test Service&quot;);
&nbsp;//        Vertex database = g.addVertex(T.label, &quot;Database&quot;, &quot;name&quot;, &quot;Test DB&quot;);
&nbsp;//        Vertex schema1 = g.addVertex(T.label, &quot;Schema&quot;, &quot;name&quot;, &quot;Test Schema1&quot;);
&nbsp;//        Vertex schema2 = g.addVertex(T.label, &quot;Schema&quot;, &quot;name&quot;, &quot;Test Schema2&quot;);
&nbsp;//        Vertex table1 = g.addVertex(T.label, &quot;Table&quot;, &quot;name&quot;, &quot;Table1&quot;);
&nbsp;//        Vertex table2 = g.addVertex(T.label, &quot;Table&quot;, &quot;name&quot;, &quot;Table2&quot;);
&nbsp;//        Vertex table3 = g.addVertex(T.label, &quot;Table&quot;, &quot;name&quot;, &quot;Table3&quot;);
&nbsp;//        Vertex table4 = g.addVertex(T.label, &quot;Table&quot;, &quot;name&quot;, &quot;Table4&quot;);
&nbsp;//        Vertex column1 = g.addVertex(T.label, &quot;Column&quot;, &quot;name&quot;, &quot;Column1&quot;);
&nbsp;//        Vertex column2 = g.addVertex(T.label, &quot;Column&quot;, &quot;name&quot;, &quot;Column2&quot;);
&nbsp;//        Vertex column3 = g.addVertex(T.label, &quot;Column&quot;, &quot;name&quot;, &quot;Column3&quot;);
&nbsp;//        Vertex column4 = g.addVertex(T.label, &quot;Column&quot;, &quot;name&quot;, &quot;Column4&quot;);
&nbsp;//        Vertex column5 = g.addVertex(T.label, &quot;Column&quot;, &quot;name&quot;, &quot;Column5&quot;);
&nbsp;//        Vertex column6 = g.addVertex(T.label, &quot;Column&quot;, &quot;name&quot;, &quot;Column6&quot;);
&nbsp;//        Vertex column7 = g.addVertex(T.label, &quot;Column&quot;, &quot;name&quot;, &quot;Column7&quot;);
&nbsp;//        Vertex column8 = g.addVertex(T.label, &quot;Column&quot;, &quot;name&quot;, &quot;Column8&quot;);
&nbsp;//
&nbsp;//        cluster.addEdge(&quot;has_Service&quot;, service);
&nbsp;//        service.addEdge(&quot;has_Database&quot;, database);
&nbsp;//        database.addEdge(&quot;has_Schema&quot;, schema1);
&nbsp;//        database.addEdge(&quot;has_Schema&quot;, schema2);
&nbsp;//        schema1.addEdge(&quot;has_Table&quot;, table1);
&nbsp;//        schema1.addEdge(&quot;has_Table&quot;, table2);
&nbsp;//        schema2.addEdge(&quot;has_Table&quot;, table3);
&nbsp;//        schema2.addEdge(&quot;has_Table&quot;, table4);
&nbsp;//        table1.addEdge(&quot;has_Column&quot;, column1);
&nbsp;//        table1.addEdge(&quot;has_Column&quot;, column2);
&nbsp;//        table2.addEdge(&quot;has_Column&quot;, column3);
&nbsp;//        table2.addEdge(&quot;has_Column&quot;, column4);
&nbsp;//        table3.addEdge(&quot;has_Column&quot;, column5);
&nbsp;//        table3.addEdge(&quot;has_Column&quot;, column6);
&nbsp;//        table4.addEdge(&quot;has_Column&quot;, column7);
&nbsp;//        table4.addEdge(&quot;has_Column&quot;, column8);
&nbsp;//
&nbsp;//        g.tx().commit();
&nbsp;//
&nbsp;////        String expected = &quot;&quot; +
&nbsp;////                &quot;{&quot; +
&nbsp;////                &quot;   Test Cluster={&quot; +
&nbsp;////                &quot;       Test Service={&quot; +
&nbsp;////                &quot;           Test DB={&quot; +
&nbsp;////                &quot;               Test Schema1={&quot; +
&nbsp;////                &quot;                   Table1={&quot; +
&nbsp;////                &quot;                       Column1={}, Column2={}&quot; +
&nbsp;////                &quot;                   }&quot; +
&nbsp;////                &quot;               }, &quot; +
&nbsp;////                &quot;               Test Schema2={&quot; +
&nbsp;////                &quot;                   Table3={&quot; +
&nbsp;////                &quot;                       Column5={}, Column6={}&quot; +
&nbsp;////                &quot;                   }&quot; +
&nbsp;////                &quot;               }&quot; +
&nbsp;////                &quot;           }&quot; +
&nbsp;////                &quot;       }&quot; +
&nbsp;////                &quot;   }&quot; +
&nbsp;////                &quot;}&quot;;
&nbsp;//
&nbsp;//        GraphTraversal&lt;Vertex, Tree&gt; traversal = g.traversal().V()
&nbsp;//                .hasLabel(&quot;public.Cluster&quot;)
&nbsp;//                .has(&quot;name&quot;, &quot;Test Cluster&quot;)
&nbsp;//                .out(&quot;has_Service&quot;).has(&quot;name&quot;, &quot;Test Service&quot;)
&nbsp;//                .out(&quot;has_Database&quot;).has(&quot;name&quot;, &quot;Test DB&quot;)
&nbsp;//                .union(
&nbsp;//                        __.out(&quot;has_Schema&quot;).has(&quot;name&quot;, P.eq(&quot;Test Schema1&quot;)).out(&quot;has_Table&quot;).has(&quot;name&quot;, P.without(&quot;Table2&quot;)),
&nbsp;//                        __.out(&quot;has_Schema&quot;).has(&quot;name&quot;, P.eq(&quot;Test Schema1&quot;)).out(&quot;has_Table&quot;).has(&quot;name&quot;, P.within(&quot;Table1&quot;)),
&nbsp;//                        __.out(&quot;has_Schema&quot;).has(&quot;name&quot;, P.eq(&quot;Test Schema2&quot;)).out(&quot;has_Table&quot;).has(&quot;name&quot;, P.neq(&quot;Table4&quot;)))
&nbsp;//                .out(&quot;has_Column&quot;)
&nbsp;//                .range(0, 100).tree();
&nbsp;//
&nbsp;//        Tree&lt;Vertex&gt; tree = traversal.next();
&nbsp;//
&nbsp;//        List&lt;Vertex&gt; clusters = tree.getObjectsAtDepth(1);
&nbsp;//        Assert.assertEquals(1, clusters.size());
&nbsp;//        List&lt;Vertex&gt; services = tree.getObjectsAtDepth(2);
&nbsp;//        Assert.assertEquals(1, services.size());
&nbsp;//        List&lt;Vertex&gt; databases = tree.getObjectsAtDepth(3);
&nbsp;//        Assert.assertEquals(1, databases.size());
&nbsp;//        List&lt;Vertex&gt; schemas = tree.getObjectsAtDepth(4);
&nbsp;//        Assert.assertEquals(2, schemas.size());
&nbsp;//        List&lt;Vertex&gt; tables = tree.getObjectsAtDepth(5);
&nbsp;//        Assert.assertEquals(2, tables.size());
&nbsp;//        List&lt;Vertex&gt; columns = tree.getObjectsAtDepth(6);
&nbsp;//        Assert.assertEquals(4, columns.size());
&nbsp;//        columns = tree.getLeafObjects();
&nbsp;//        Assert.assertEquals(4, columns.size());
&nbsp;//
&nbsp;//        Assert.assertTrue(tree.containsKey(cluster));
&nbsp;//        Assert.assertTrue(tree.get(cluster).containsKey(service));
&nbsp;//        Assert.assertTrue(tree.get(cluster).get(service).containsKey(database));
&nbsp;//        Assert.assertTrue(tree.get(cluster).get(service).get(database).containsKey(schema1));
&nbsp;//        Assert.assertTrue(tree.get(cluster).get(service).get(database).get(schema1).containsKey(table1));
&nbsp;//        Assert.assertTrue(tree.get(cluster).get(service).get(database).get(schema1).get(table1).containsKey(column1));
&nbsp;//        Assert.assertTrue(tree.get(cluster).get(service).get(database).get(schema1).get(table1).containsKey(column2));
&nbsp;//
&nbsp;//        Assert.assertTrue(tree.get(cluster).get(service).get(database).containsKey(schema2));
&nbsp;//        Assert.assertTrue(tree.get(cluster).get(service).get(database).get(schema2).containsKey(table3));
&nbsp;//        Assert.assertTrue(tree.get(cluster).get(service).get(database).get(schema2).get(table3).containsKey(column5));
&nbsp;//        Assert.assertTrue(tree.get(cluster).get(service).get(database).get(schema2).get(table3).containsKey(column6));
&nbsp;//    }
&nbsp;//
&nbsp;//    @Test
&nbsp;//    public void testUnionHasPath() {
&nbsp;//        Vertex a1 = this.sqlgGraph.addVertex(T.label, &quot;A&quot;, &quot;name&quot;, &quot;A1&quot;);
&nbsp;//        Vertex a2 = this.sqlgGraph.addVertex(T.label, &quot;A&quot;, &quot;name&quot;, &quot;A2&quot;);
&nbsp;//        Vertex a3 = this.sqlgGraph.addVertex(T.label, &quot;A&quot;, &quot;name&quot;, &quot;A3&quot;);
&nbsp;//        Vertex a4 = this.sqlgGraph.addVertex(T.label, &quot;A&quot;, &quot;name&quot;, &quot;A4&quot;);
&nbsp;//        Vertex b1 = this.sqlgGraph.addVertex(T.label, &quot;B&quot;, &quot;name&quot;, &quot;B1&quot;);
&nbsp;//        Vertex b2 = this.sqlgGraph.addVertex(T.label, &quot;B&quot;, &quot;name&quot;, &quot;B2&quot;);
&nbsp;//        Vertex b3 = this.sqlgGraph.addVertex(T.label, &quot;B&quot;, &quot;name&quot;, &quot;B3&quot;);
&nbsp;//        Vertex c1 = this.sqlgGraph.addVertex(T.label, &quot;C&quot;, &quot;name&quot;, &quot;C1&quot;);
&nbsp;//        Vertex c2 = this.sqlgGraph.addVertex(T.label, &quot;C&quot;, &quot;name&quot;, &quot;C2&quot;);
&nbsp;//        Vertex c3 = this.sqlgGraph.addVertex(T.label, &quot;C&quot;, &quot;name&quot;, &quot;C3&quot;);
&nbsp;//        a1.addEdge(&quot;toB&quot;, b1);
&nbsp;//        a1.addEdge(&quot;toB&quot;, b2);
&nbsp;//        a1.addEdge(&quot;toB&quot;, b3);
&nbsp;//        b1.addEdge(&quot;toC&quot;, c1);
&nbsp;//        b2.addEdge(&quot;toC&quot;, c2);
&nbsp;//        b3.addEdge(&quot;toC&quot;, c3);
&nbsp;//
&nbsp;//        GraphTraversal&lt;Vertex, Path&gt; traversal = this.sqlgGraph.traversal().V().has(&quot;A&quot;, &quot;name&quot;, &quot;A1&quot;)
&nbsp;//                .union(
&nbsp;//                        __.out(&quot;toB&quot;).has(&quot;name&quot;, P.eq(&quot;B1&quot;)).out(&quot;toC&quot;),
&nbsp;//                        __.out(&quot;toB&quot;).has(&quot;name&quot;, P.eq(&quot;B2&quot;)).out(&quot;toC&quot;))
&nbsp;//                .path();
&nbsp;//        printTraversalForm(traversal);
&nbsp;//
&nbsp;//        Set&lt;Object&gt; objs = new HashSet&lt;&gt;();
&nbsp;//        while (traversal.hasNext()) {
&nbsp;//            Path p = traversal.next();
&nbsp;//            Assert.assertEquals(3, p.size());
&nbsp;//            Object root0 = p.get(0);
&nbsp;//            Assert.assertEquals(a1, root0);
&nbsp;//            Object child0 = p.get(1);
&nbsp;//            Assert.assertEquals(&quot;B&quot;, ((Vertex) child0).label());
&nbsp;//            Object child1 = p.get(2);
&nbsp;//            Assert.assertEquals(&quot;C&quot;, ((Vertex) child1).label());
&nbsp;//            objs.add(child0);
&nbsp;//            objs.add(child1);
&nbsp;//        }
&nbsp;//        Assert.assertEquals(4, objs.size());
&nbsp;//        Assert.assertTrue(objs.contains(b1));
&nbsp;//        Assert.assertTrue(objs.contains(b2));
&nbsp;//        Assert.assertTrue(objs.contains(c1));
&nbsp;//        Assert.assertTrue(objs.contains(c2));
&nbsp;//
&nbsp;//        traversal = this.sqlgGraph.traversal().V().hasLabel(&quot;A&quot;)
&nbsp;//                .union(
&nbsp;//                        __.optional(__.out(&quot;toB&quot;).has(&quot;name&quot;, P.eq(&quot;B1&quot;)).optional(__.out(&quot;toC&quot;))),
&nbsp;//                        __.optional(__.out(&quot;toB&quot;).has(&quot;name&quot;, P.eq(&quot;B2&quot;)).optional(__.out(&quot;toC&quot;))))
&nbsp;//                .path();
&nbsp;//        printTraversalForm(traversal);
&nbsp;//        List&lt;Path&gt; paths = traversal.toList();
&nbsp;//        Assert.assertEquals(8, paths.size());
&nbsp;//        Assert.assertEquals(2, paths.stream().filter(p -&gt; p.size() == 3).count());
&nbsp;//    }
&nbsp;//
&nbsp;//    @Test
&nbsp;//    public void testUnionAsPerUMLG() {
&nbsp;//        Vertex a1 = this.sqlgGraph.addVertex(T.label, &quot;A&quot;);
&nbsp;//        Vertex b1 = this.sqlgGraph.addVertex(T.label, &quot;B&quot;);
&nbsp;//        Vertex b2 = this.sqlgGraph.addVertex(T.label, &quot;B&quot;);
&nbsp;//        Vertex bb1 = this.sqlgGraph.addVertex(T.label, &quot;BB&quot;);
&nbsp;//        Vertex bb2 = this.sqlgGraph.addVertex(T.label, &quot;BB&quot;);
&nbsp;//        a1.addEdge(&quot;ab&quot;, b1);
&nbsp;//        a1.addEdge(&quot;ab&quot;, b2);
&nbsp;//        bb1.addEdge(&quot;ab&quot;, a1);
&nbsp;//        bb2.addEdge(&quot;ab&quot;, a1);
&nbsp;//        this.sqlgGraph.tx().commit();
&nbsp;//        List&lt;Vertex&gt; vertices = this.sqlgGraph.traversal().V(a1).in(&quot;ab&quot;).toList();
&nbsp;//        Assert.assertEquals(2, vertices.size());
&nbsp;//        vertices = this.sqlgGraph.traversal().V(a1).union(__.optional(__.out(&quot;ab&quot;)), __.optional(__.in(&quot;ab&quot;))).toList();
&nbsp;//        Assert.assertEquals(4, vertices.size());
&nbsp;//        vertices = this.sqlgGraph.traversal().V(a1).union(__.out(&quot;ab&quot;), __.in(&quot;ab&quot;)).toList();
&nbsp;//        Assert.assertEquals(4, vertices.size());
&nbsp;//        vertices = this.sqlgGraph.traversal().V(a1).union(__.out(&quot;ab&quot;), __.in(&quot;ab&quot;)).toList();
&nbsp;//        Assert.assertEquals(4, vertices.size());
&nbsp;//    }
&nbsp;//
&nbsp;//    @Test
&nbsp;//    public void testUnionFailure() {
&nbsp;//        loadModern();
&nbsp;//        Traversal&lt;Vertex, Map&lt;String, Long&gt;&gt; traversal = this.sqlgGraph.traversal().V().union(
&nbsp;//                        __.repeat(__.union(
&nbsp;//                                __.out(&quot;created&quot;),
&nbsp;//                                __.in(&quot;created&quot;))).times(2),
&nbsp;//                        __.repeat(__.union(
&nbsp;//                                __.in(&quot;created&quot;),
&nbsp;//                                __.out(&quot;created&quot;))).times(2))
&nbsp;//                .label().groupCount();
&nbsp;//        printTraversalForm(traversal);
&nbsp;//        final Map&lt;String, Long&gt; groupCount = traversal.next();
&nbsp;//        Assert.assertFalse(traversal.hasNext());
&nbsp;//        Assert.assertEquals(12l, groupCount.get(&quot;software&quot;).longValue());
&nbsp;//        Assert.assertEquals(20l, groupCount.get(&quot;person&quot;).longValue());
&nbsp;//        Assert.assertEquals(2, groupCount.size());
&nbsp;//    }
&nbsp;//
&nbsp;//    @Test
&nbsp;//    public void g_VX1_2X_unionXoutE_count__inE_count__outE_weight_sumX() {
&nbsp;//        loadModern();
&nbsp;//        Object marko = convertToVertexId(&quot;marko&quot;);
&nbsp;//        Object vadas = convertToVertexId(&quot;vadas&quot;);
&nbsp;//        final Traversal&lt;Vertex, Number&gt; traversal = this.sqlgGraph.traversal().V(marko, vadas)
&nbsp;//                .union(
&nbsp;//                        __.outE().count(),
&nbsp;//                        __.inE().count(),
&nbsp;//                        (Traversal) __.outE().values(&quot;weight&quot;).sum()
&nbsp;//                );
&nbsp;//        printTraversalForm(traversal);
&nbsp;//        checkResults(Arrays.asList(3l, 1.9d, 1l), traversal);
&nbsp;//    }
&nbsp;//
&nbsp;//    @Test
&nbsp;//    public void g_V_outXcreatedX_unionXasXprojectX_inXcreatedX_hasXname_markoX_selectXprojectX__asXprojectX_inXcreatedX_inXknowsX_hasXname_markoX_selectXprojectXX_groupCount_byXnameX() {
&nbsp;//        loadModern();
&nbsp;//        List&lt;Vertex&gt; vertices = this.sqlgGraph.traversal().V().out(&quot;created&quot;)
&nbsp;//                .&lt;Vertex&gt;union(
&nbsp;//                        __.as(&quot;project&quot;).in(&quot;created&quot;).has(&quot;name&quot;, &quot;marko&quot;).select(&quot;project&quot;),
&nbsp;//                        __.as(&quot;project&quot;).in(&quot;created&quot;).in(&quot;knows&quot;).has(&quot;name&quot;, &quot;marko&quot;).select(&quot;project&quot;)
&nbsp;//                ).toList();
&nbsp;//        Assert.assertEquals(7, vertices.size());
&nbsp;//        Assert.assertEquals(6, vertices.stream().filter(v -&gt; v.value(&quot;name&quot;).equals(&quot;lop&quot;)).count());
&nbsp;//        Assert.assertEquals(1, vertices.stream().filter(v -&gt; v.value(&quot;name&quot;).equals(&quot;ripple&quot;)).count());
&nbsp;//
&nbsp;//        Traversal&lt;Vertex, Map&lt;String, Long&gt;&gt; traversal = (Traversal) this.sqlgGraph.traversal().V().out(&quot;created&quot;)
&nbsp;//                .union(
&nbsp;//                        __.as(&quot;project&quot;).in(&quot;created&quot;).has(&quot;name&quot;, &quot;marko&quot;).select(&quot;project&quot;),
&nbsp;//                        __.as(&quot;project&quot;).in(&quot;created&quot;).in(&quot;knows&quot;).has(&quot;name&quot;, &quot;marko&quot;).select(&quot;project&quot;)
&nbsp;//                ).groupCount().by(&quot;name&quot;);
&nbsp;//
&nbsp;//        printTraversalForm(traversal);
&nbsp;//        Assert.assertTrue(traversal.hasNext());
&nbsp;//        final Map&lt;String, Long&gt; map = traversal.next();
&nbsp;//        Assert.assertFalse(traversal.hasNext());
&nbsp;//        Assert.assertEquals(2, map.size());
&nbsp;//        Assert.assertEquals(1l, map.get(&quot;ripple&quot;).longValue());
&nbsp;//        Assert.assertEquals(6l, map.get(&quot;lop&quot;).longValue());
&nbsp;//    }
&nbsp;
&nbsp;}
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2025-06-23 10:13</div>
</div>
</body>
</html>
