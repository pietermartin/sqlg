


<!DOCTYPE html>
<html id="htmlId">
<head>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8"> 
  <title>Coverage Report > TestPartitioning</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope:     <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">org.umlg.sqlg.test.topology</a>
</div>

<h1>Coverage Summary for Class: TestPartitioning (org.umlg.sqlg.test.topology)</h1>

<table class="coverageStats">

<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Branch, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">TestPartitioning</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (31/31)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    89.7%
  </span>
  <span class="absValue">
    (52/58)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    98.5%
  </span>
  <span class="absValue">
    (880/893)
  </span>
</td>
</tr>
  <tr>
    <td class="name">TestPartitioning$1</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (1/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (13/13)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TestPartitioning$10</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (1/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TestPartitioning$11</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (1/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TestPartitioning$12</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (1/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TestPartitioning$13</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (1/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TestPartitioning$14</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (1/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TestPartitioning$15</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (1/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TestPartitioning$16</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (1/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TestPartitioning$17</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (1/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TestPartitioning$18</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (1/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (4/4)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TestPartitioning$19</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (1/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (4/4)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TestPartitioning$2</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (1/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (4/4)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TestPartitioning$20</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (1/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (4/4)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TestPartitioning$21</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (1/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (4/4)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TestPartitioning$22</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (1/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (4/4)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TestPartitioning$23</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (1/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (4/4)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TestPartitioning$24</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (1/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TestPartitioning$25</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (1/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TestPartitioning$26</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (1/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (4/4)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TestPartitioning$27</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (1/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TestPartitioning$28</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (1/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TestPartitioning$29</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (1/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TestPartitioning$3</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (1/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (4/4)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TestPartitioning$30</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (1/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (5/5)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TestPartitioning$31</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (1/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (5/5)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TestPartitioning$32</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (1/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TestPartitioning$33</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (1/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (4/4)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TestPartitioning$4</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (1/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TestPartitioning$5</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (1/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TestPartitioning$6</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (1/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (4/4)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TestPartitioning$7</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (1/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (4/4)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TestPartitioning$8</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (1/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (4/4)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TestPartitioning$9</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (1/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TestPartitioning$TEST</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (4/4)
  </span>
</td>
  </tr>
<tr>
  <td class="name"><strong>Total</strong></td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (66/66)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    89.7%
  </span>
  <span class="absValue">
    (52/58)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    98.7%
  </span>
  <span class="absValue">
    (1001/1014)
  </span>
</td>
</tr>
</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode">&nbsp;package org.umlg.sqlg.test.topology;
&nbsp;
&nbsp;import org.apache.commons.collections4.set.ListOrderedSet;
&nbsp;import org.apache.commons.lang3.tuple.Pair;
&nbsp;import org.apache.tinkerpop.gremlin.structure.Edge;
&nbsp;import org.apache.tinkerpop.gremlin.structure.T;
&nbsp;import org.apache.tinkerpop.gremlin.structure.Vertex;
&nbsp;import org.junit.Assert;
&nbsp;import org.junit.Assume;
&nbsp;import org.junit.Before;
&nbsp;import org.junit.Test;
&nbsp;import org.umlg.sqlg.structure.*;
&nbsp;import org.umlg.sqlg.structure.topology.*;
&nbsp;import org.umlg.sqlg.test.BaseTest;
&nbsp;
&nbsp;import java.sql.Connection;
&nbsp;import java.sql.ResultSet;
&nbsp;import java.sql.SQLException;
&nbsp;import java.sql.Statement;
&nbsp;import java.time.LocalDate;
&nbsp;import java.time.LocalDateTime;
&nbsp;import java.time.YearMonth;
&nbsp;import java.time.ZoneId;
&nbsp;import java.time.format.DateTimeFormatter;
&nbsp;import java.util.*;
&nbsp;
&nbsp;/**
&nbsp; * @author &lt;a href=&quot;https://github.com/pietermartin&quot;&gt;Pieter Martin&lt;/a&gt;
&nbsp; * Date: 2018/01/13
&nbsp; */
&nbsp;@SuppressWarnings({&quot;UnusedAssignment&quot;, &quot;unused&quot;, &quot;DuplicatedCode&quot;})
<b class="fc">&nbsp;public class TestPartitioning extends BaseTest {</b>
&nbsp;
&nbsp;    @Before
&nbsp;    public void before() throws Exception {
<b class="fc">&nbsp;        super.before();</b>
<b class="fc">&nbsp;        Assume.assumeTrue(this.sqlgGraph.getSqlDialect().supportsPartitioning());</b>
&nbsp;    }
&nbsp;
<b class="fc">&nbsp;    private enum TEST {</b>
<b class="fc">&nbsp;        TEST1,</b>
<b class="fc">&nbsp;        TEST2,</b>
<b class="fc">&nbsp;        TEST3</b>
&nbsp;    }
&nbsp;
&nbsp;    @Test
&nbsp;    public void testPartitionOnLocalDate() {
<b class="fc">&nbsp;        final String label = &quot;log4j2&quot;;</b>
<b class="fc">&nbsp;        final String fullName = &quot;log.log4j2&quot;;</b>
<b class="fc">&nbsp;        final String MILLIS = &quot;millis&quot;;</b>
<b class="fc">&nbsp;        final String NANO = &quot;nano&quot;;</b>
<b class="fc">&nbsp;        final String LEVEL = &quot;level&quot;;</b>
<b class="fc">&nbsp;        final String MARKER = &quot;marker&quot;;</b>
<b class="fc">&nbsp;        final String THREAD_NAME = &quot;threadName&quot;;</b>
<b class="fc">&nbsp;        final String LOGGER_NAME = &quot;loggerName&quot;;</b>
<b class="fc">&nbsp;        final String DATE = &quot;date&quot;;</b>
<b class="fc">&nbsp;        final String SERVER = &quot;server&quot;;</b>
<b class="fc">&nbsp;        final String DATE_TIME = &quot;dateTime&quot;;</b>
<b class="fc">&nbsp;        final String INDEX = &quot;index&quot;;</b>
<b class="fc">&nbsp;        final String MESSAGE = &quot;message&quot;;</b>
<b class="fc">&nbsp;        final String STACK_TRACE = &quot;stackTrace&quot;;</b>
<b class="fc">&nbsp;        SqlgGraph logSqlgGraph = this.sqlgGraph;</b>
&nbsp;
<b class="fc">&nbsp;        LocalDate now = LocalDate.now();</b>
<b class="fc">&nbsp;        LocalDate past = now.minusMonths(3);</b>
&nbsp;
<b class="fc">&nbsp;        VertexLabel partitionedLogVertexLabel = logSqlgGraph.getTopology()</b>
<b class="fc">&nbsp;                .ensureSchemaExist(&quot;log&quot;)</b>
<b class="fc">&nbsp;                .ensurePartitionedVertexLabelExist(</b>
&nbsp;                        &quot;log4j2&quot;,
<b class="fc">&nbsp;                        new LinkedHashMap&lt;&gt;() {{</b>
<b class="fc">&nbsp;                            put(SERVER, PropertyDefinition.of(PropertyType.STRING, Multiplicity.of(1, 1)));</b>
<b class="fc">&nbsp;                            put(DATE, PropertyDefinition.of(PropertyType.LOCALDATE, Multiplicity.of(1, 1)));</b>
<b class="fc">&nbsp;                            put(MILLIS, PropertyDefinition.of(PropertyType.LONG, Multiplicity.of(1, 1)));</b>
<b class="fc">&nbsp;                            put(NANO, PropertyDefinition.of(PropertyType.LONG, Multiplicity.of(1, 1)));</b>
<b class="fc">&nbsp;                            put(LEVEL, PropertyDefinition.of(PropertyType.INTEGER, Multiplicity.of(1, 1)));</b>
<b class="fc">&nbsp;                            put(MARKER, PropertyDefinition.of(PropertyType.STRING, Multiplicity.of(1, 1)));</b>
<b class="fc">&nbsp;                            put(THREAD_NAME, PropertyDefinition.of(PropertyType.STRING, Multiplicity.of(1, 1)));</b>
<b class="fc">&nbsp;                            put(LOGGER_NAME, PropertyDefinition.of(PropertyType.STRING, Multiplicity.of(1, 1)));</b>
<b class="fc">&nbsp;                            put(INDEX, PropertyDefinition.of(PropertyType.INTEGER, Multiplicity.of(1, 1)));</b>
<b class="fc">&nbsp;                            put(DATE_TIME, PropertyDefinition.of(PropertyType.LOCALDATETIME, Multiplicity.of(1, 1)));</b>
<b class="fc">&nbsp;                            put(MESSAGE, PropertyDefinition.of(PropertyType.STRING, Multiplicity.of(1, 1)));</b>
<b class="fc">&nbsp;                            put(STACK_TRACE, PropertyDefinition.of(PropertyType.STRING, Multiplicity.of(0, 1)));</b>
&nbsp;                        }},
<b class="fc">&nbsp;                        ListOrderedSet.listOrderedSet(List.of(SERVER, DATE, MILLIS, NANO, LEVEL, MARKER, INDEX)),</b>
&nbsp;                        PartitionType.RANGE,
&nbsp;                        &quot;date&quot;
&nbsp;                );
<b class="fc">&nbsp;        LocalDate start = now.withDayOfMonth(1);</b>
<b class="fc">&nbsp;        LocalDate end = start.plusMonths(1);</b>
<b class="fc">&nbsp;        String partitionName = start.format(DateTimeFormatter.ofPattern(&quot;yyyy-MM&quot;));</b>
<b class="pc">&nbsp;        if (partitionedLogVertexLabel.getPartition(partitionName).isEmpty()) {</b>
<b class="fc">&nbsp;            Partition monthPartition = partitionedLogVertexLabel.ensureRangePartitionWithSubPartitionExists(</b>
&nbsp;                    partitionName,
<b class="fc">&nbsp;                    logSqlgGraph.getSqlDialect().toRDBSStringLiteral(start),</b>
<b class="fc">&nbsp;                    logSqlgGraph.getSqlDialect().toRDBSStringLiteral(end),</b>
&nbsp;                    PartitionType.RANGE,
&nbsp;                    &quot;date&quot;
&nbsp;            );
<b class="fc">&nbsp;            YearMonth yearMonth = YearMonth.of(start.getYear(), start.getMonth());</b>
<b class="fc">&nbsp;            for (int i = 1; i &lt;= yearMonth.lengthOfMonth(); i++) {</b>
<b class="fc">&nbsp;                String dayPartitionName = start.format(DateTimeFormatter.ofPattern(&quot;yyyy-MM-dd&quot;));</b>
<b class="pc">&nbsp;                if (monthPartition.getPartition(dayPartitionName).isEmpty()) {</b>
<b class="fc">&nbsp;                    monthPartition.ensureRangePartitionExists(</b>
&nbsp;                            dayPartitionName,
<b class="fc">&nbsp;                            logSqlgGraph.getSqlDialect().toRDBSStringLiteral(start.atStartOfDay()),</b>
<b class="fc">&nbsp;                            logSqlgGraph.getSqlDialect().toRDBSStringLiteral(start.plusDays(1).atStartOfDay())</b>
&nbsp;                    );
&nbsp;                }
<b class="fc">&nbsp;                start = start.plusDays(1);</b>
&nbsp;            }
&nbsp;        }
<b class="fc">&nbsp;        for (int i = 0; i &lt; 2; i++) {</b>
<b class="fc">&nbsp;            start = end;</b>
<b class="fc">&nbsp;            end = end.plusMonths(1);</b>
<b class="fc">&nbsp;            partitionName = start.format(DateTimeFormatter.ofPattern(&quot;yyyy-MM&quot;));</b>
<b class="pc">&nbsp;            if (partitionedLogVertexLabel.getPartition(partitionName).isEmpty()) {</b>
&nbsp;
<b class="fc">&nbsp;                Partition monthPartition = partitionedLogVertexLabel.ensureRangePartitionWithSubPartitionExists(</b>
&nbsp;                        partitionName,
<b class="fc">&nbsp;                        logSqlgGraph.getSqlDialect().toRDBSStringLiteral(start),</b>
<b class="fc">&nbsp;                        logSqlgGraph.getSqlDialect().toRDBSStringLiteral(end),</b>
&nbsp;                        PartitionType.RANGE,
&nbsp;                        &quot;date&quot;
&nbsp;                );
<b class="fc">&nbsp;                YearMonth yearMonth = YearMonth.of(start.getYear(), start.getMonth());</b>
<b class="fc">&nbsp;                for (int j = 1; j &lt;= yearMonth.lengthOfMonth(); j++) {</b>
<b class="fc">&nbsp;                    String dayPartitionName = start.format(DateTimeFormatter.ofPattern(&quot;yyyy-MM-dd&quot;));</b>
<b class="pc">&nbsp;                    if (monthPartition.getPartition(dayPartitionName).isEmpty()) {</b>
<b class="fc">&nbsp;                        monthPartition.ensureRangePartitionExists(</b>
&nbsp;                                dayPartitionName,
<b class="fc">&nbsp;                                logSqlgGraph.getSqlDialect().toRDBSStringLiteral(start.atStartOfDay()),</b>
<b class="fc">&nbsp;                                logSqlgGraph.getSqlDialect().toRDBSStringLiteral(start.plusDays(1).atStartOfDay())</b>
&nbsp;                        );
&nbsp;                    }
<b class="fc">&nbsp;                    start = start.plusDays(1);</b>
&nbsp;                }
&nbsp;
&nbsp;            }
&nbsp;        }
&nbsp;
<b class="fc">&nbsp;        logSqlgGraph.tx().commit();</b>
<b class="fc">&nbsp;        logSqlgGraph.tx().streamingBatchModeOn();</b>
<b class="fc">&nbsp;        LocalDateTime dateTime = LocalDateTime.now();</b>
<b class="fc">&nbsp;        for (int i = 0; i &lt; 1000; i++) {</b>
<b class="fc">&nbsp;            LocalDate date = dateTime.toLocalDate();</b>
<b class="fc">&nbsp;            logSqlgGraph.streamVertex(</b>
&nbsp;                    T.label, fullName,
&nbsp;                    SERVER, &quot;-&quot;,
&nbsp;                    DATE, date,
<b class="fc">&nbsp;                    MILLIS, dateTime.atZone(ZoneId.systemDefault()).toInstant().toEpochMilli(),</b>
<b class="fc">&nbsp;                    NANO, i,</b>
<b class="fc">&nbsp;                    LEVEL, 0,</b>
&nbsp;                    MARKER, &quot;MARKER&quot;,
&nbsp;                    THREAD_NAME, &quot;thread&quot;,
&nbsp;                    LOGGER_NAME, &quot;logger&quot;,
&nbsp;                    DATE_TIME, dateTime,
&nbsp;                    MESSAGE, &quot;message&quot;,
&nbsp;                    STACK_TRACE, null,
<b class="fc">&nbsp;                    INDEX, i</b>
&nbsp;            );
&nbsp;        }
&nbsp;
<b class="fc">&nbsp;        logSqlgGraph.tx().commit();</b>
&nbsp;
<b class="fc">&nbsp;        List&lt;Vertex&gt; vertices = logSqlgGraph.traversal().V().hasLabel(&quot;log.log4j2&quot;).toList();</b>
<b class="fc">&nbsp;        Assert.assertEquals(1000, vertices.size());</b>
&nbsp;
<b class="fc">&nbsp;        Vertex v = vertices.get(100);</b>
<b class="fc">&nbsp;        RecordId recordId = (RecordId) v.id();</b>
&nbsp;
<b class="fc">&nbsp;        System.out.println(recordId.toString());</b>
<b class="fc">&nbsp;        RecordId recordId1 = RecordId.from(logSqlgGraph, recordId.toString());</b>
&nbsp;
<b class="fc">&nbsp;        Optional&lt;Vertex&gt; vertexOptional = logSqlgGraph.traversal().V().hasId(recordId1).tryNext();</b>
<b class="fc">&nbsp;        Assert.assertTrue(vertexOptional.isPresent());</b>
&nbsp;
&nbsp;    }
&nbsp;
&nbsp;    @Test
&nbsp;    public void testPartitionWithRangePartitionNameToLong() {
<b class="fc">&nbsp;        Schema publicSchema = this.sqlgGraph.getTopology().getPublicSchema();</b>
<b class="fc">&nbsp;        VertexLabel a = publicSchema.ensurePartitionedVertexLabelExist(</b>
&nbsp;                &quot;A&quot;,
<b class="fc">&nbsp;                new LinkedHashMap&lt;&gt;() {{</b>
<b class="fc">&nbsp;                    put(&quot;int1&quot;, PropertyDefinition.of(PropertyType.INTEGER));</b>
<b class="fc">&nbsp;                    put(&quot;int2&quot;, PropertyDefinition.of(PropertyType.INTEGER));</b>
<b class="fc">&nbsp;                    put(&quot;int3&quot;, PropertyDefinition.of(PropertyType.INTEGER));</b>
&nbsp;                }},
<b class="fc">&nbsp;                ListOrderedSet.listOrderedSet(List.of(&quot;int1&quot;, &quot;int2&quot;)),</b>
&nbsp;                PartitionType.RANGE,
&nbsp;                &quot;int1,int2&quot;);
&nbsp;        try {
<b class="fc">&nbsp;            a.ensureRangePartitionExists(&quot;01234567890123456789012345678901234567890123456789012345678901234&quot;, &quot;1,1&quot;, &quot;5,5&quot;);</b>
<b class="nc">&nbsp;            Assert.fail(&quot;suppose to fail with InvalidTableException&quot;);</b>
&nbsp;        } catch (SqlgExceptions.InvalidTableException ignore) {
&nbsp;            //swallow
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    @Test
&nbsp;    public void testPartitionWithListPartitionNameToLong() {
<b class="fc">&nbsp;        VertexLabel vertexLabel = this.sqlgGraph.getTopology().getPublicSchema().ensurePartitionedVertexLabelExist(</b>
&nbsp;                &quot;A&quot;,
<b class="fc">&nbsp;                new LinkedHashMap&lt;&gt;() {{</b>
<b class="fc">&nbsp;                    put(&quot;uid1&quot;, PropertyDefinition.of(PropertyType.INTEGER));</b>
<b class="fc">&nbsp;                    put(&quot;uid2&quot;, PropertyDefinition.of(PropertyType.LONG));</b>
<b class="fc">&nbsp;                    put(&quot;uid3&quot;, PropertyDefinition.of(PropertyType.STRING));</b>
&nbsp;                }},
<b class="fc">&nbsp;                ListOrderedSet.listOrderedSet(List.of(&quot;uid1&quot;, &quot;uid2&quot;, &quot;uid3&quot;)),</b>
&nbsp;                PartitionType.LIST,
&nbsp;                &quot;\&quot;uid1\&quot;&quot;
&nbsp;        );
&nbsp;        try {
<b class="fc">&nbsp;            vertexLabel.ensureListPartitionExists(&quot;01234567890123456789012345678901234567890123456789012345678901234&quot;, &quot;&#39;1&#39;&quot;);</b>
<b class="nc">&nbsp;            Assert.fail(&quot;suppose to fail with InvalidTableException&quot;);</b>
&nbsp;        } catch (SqlgExceptions.InvalidTableException ignore) {
&nbsp;            //swallow
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    @Test
&nbsp;    public void testPartitionReloadDifferentSchemaSamePartitionName() {
<b class="fc">&nbsp;        Schema aSchema = this.sqlgGraph.getTopology().ensureSchemaExist(&quot;A&quot;);</b>
<b class="fc">&nbsp;        Schema bSchema = this.sqlgGraph.getTopology().ensureSchemaExist(&quot;B&quot;);</b>
<b class="fc">&nbsp;        VertexLabel a = aSchema.ensurePartitionedVertexLabelExist(&quot;A&quot;,</b>
<b class="fc">&nbsp;                new HashMap&lt;&gt;() {{</b>
<b class="fc">&nbsp;                    put(&quot;name&quot;, PropertyDefinition.of(PropertyType.STRING));</b>
<b class="fc">&nbsp;                    put(&quot;part&quot;, PropertyDefinition.of(PropertyType.INTEGER));</b>
&nbsp;                }},
<b class="fc">&nbsp;                ListOrderedSet.listOrderedSet(Set.of(&quot;name&quot;, &quot;part&quot;)),</b>
&nbsp;                PartitionType.LIST,
&nbsp;                &quot;\&quot;part\&quot;&quot;
&nbsp;        );
<b class="fc">&nbsp;        a.ensureListPartitionExists(&quot;part&quot;, &quot;&#39;1&#39;&quot;);</b>
<b class="fc">&nbsp;        VertexLabel b = bSchema.ensurePartitionedVertexLabelExist(&quot;A&quot;,</b>
<b class="fc">&nbsp;                new HashMap&lt;&gt;() {{</b>
<b class="fc">&nbsp;                    put(&quot;name&quot;, PropertyDefinition.of(PropertyType.STRING));</b>
<b class="fc">&nbsp;                    put(&quot;part&quot;, PropertyDefinition.of(PropertyType.INTEGER));</b>
&nbsp;                }},
<b class="fc">&nbsp;                ListOrderedSet.listOrderedSet(Set.of(&quot;name&quot;, &quot;part&quot;)),</b>
&nbsp;                PartitionType.LIST,
&nbsp;                &quot;\&quot;part\&quot;&quot;
&nbsp;        );
<b class="fc">&nbsp;        b.ensureListPartitionExists(&quot;part&quot;, &quot;&#39;1&#39;&quot;);</b>
<b class="fc">&nbsp;        this.sqlgGraph.tx().commit();</b>
<b class="fc">&nbsp;        VertexLabel aVertexLabel = this.sqlgGraph.getTopology().getSchema(&quot;A&quot;).orElseThrow().getVertexLabel(&quot;A&quot;).orElseThrow();</b>
<b class="fc">&nbsp;        Map&lt;String, Partition&gt; aPartitions = aVertexLabel.getPartitions();</b>
<b class="fc">&nbsp;        Assert.assertEquals(1, aPartitions.size());</b>
&nbsp;
<b class="fc">&nbsp;        VertexLabel bVertexLabel = this.sqlgGraph.getTopology().getSchema(&quot;B&quot;).orElseThrow().getVertexLabel(&quot;A&quot;).orElseThrow();</b>
<b class="fc">&nbsp;        Map&lt;String, Partition&gt; bPartitions = bVertexLabel.getPartitions();</b>
<b class="fc">&nbsp;        Assert.assertEquals(1, bPartitions.size());</b>
<b class="fc">&nbsp;        this.sqlgGraph.tx().commit();</b>
<b class="fc">&nbsp;        this.sqlgGraph.close();</b>
&nbsp;
<b class="fc">&nbsp;        try (SqlgGraph sqlgGraph1 = SqlgGraph.open(configuration)) {</b>
<b class="fc">&nbsp;            aVertexLabel = sqlgGraph1.getTopology().getSchema(&quot;A&quot;).orElseThrow().getVertexLabel(&quot;A&quot;).orElseThrow();</b>
<b class="fc">&nbsp;            aPartitions = aVertexLabel.getPartitions();</b>
<b class="fc">&nbsp;            Assert.assertEquals(1, aPartitions.size());</b>
&nbsp;
<b class="fc">&nbsp;            bVertexLabel = sqlgGraph1.getTopology().getSchema(&quot;B&quot;).orElseThrow().getVertexLabel(&quot;A&quot;).orElseThrow();</b>
<b class="fc">&nbsp;            bPartitions = bVertexLabel.getPartitions();</b>
<b class="fc">&nbsp;            Assert.assertEquals(1, bPartitions.size());</b>
&nbsp;        }
&nbsp;
&nbsp;    }
&nbsp;
&nbsp;    @Test
&nbsp;    public void testReloadVertexLabelWithPartitions2() {
<b class="fc">&nbsp;        Schema publicSchema = this.sqlgGraph.getTopology().getPublicSchema();</b>
<b class="fc">&nbsp;        VertexLabel a = publicSchema.ensurePartitionedVertexLabelExist(</b>
&nbsp;                &quot;A&quot;,
<b class="fc">&nbsp;                new LinkedHashMap&lt;&gt;() {{</b>
<b class="fc">&nbsp;                    put(&quot;int1&quot;, PropertyDefinition.of(PropertyType.INTEGER));</b>
<b class="fc">&nbsp;                    put(&quot;int2&quot;, PropertyDefinition.of(PropertyType.INTEGER));</b>
<b class="fc">&nbsp;                    put(&quot;int3&quot;, PropertyDefinition.of(PropertyType.INTEGER));</b>
&nbsp;                }},
<b class="fc">&nbsp;                ListOrderedSet.listOrderedSet(List.of(&quot;int1&quot;, &quot;int2&quot;)),</b>
&nbsp;                PartitionType.RANGE,
&nbsp;                &quot;int1,int2&quot;);
<b class="fc">&nbsp;        a.ensureRangePartitionExists(&quot;part1&quot;, &quot;1,1&quot;, &quot;5,5&quot;);</b>
<b class="fc">&nbsp;        a.ensureRangePartitionExists(&quot;part2&quot;, &quot;5,5&quot;, &quot;10,10&quot;);</b>
<b class="fc">&nbsp;        this.sqlgGraph.tx().commit();</b>
&nbsp;
<b class="fc">&nbsp;        String checkPrimaryKey = &quot;SELECT a.attname, format_type(a.atttypid, a.atttypmod) AS data_type\n&quot; +</b>
&nbsp;                &quot;FROM   pg_index i\n&quot; +
&nbsp;                &quot;JOIN   pg_attribute a ON a.attrelid = i.indrelid\n&quot; +
&nbsp;                &quot;                     AND a.attnum = ANY(i.indkey)\n&quot; +
&nbsp;                &quot;WHERE  i.indrelid = &#39;\&quot;V_A\&quot;&#39;::regclass\n&quot; +
&nbsp;                &quot;AND    i.indisprimary;&quot;;
<b class="fc">&nbsp;        Connection connection = this.sqlgGraph.tx().getConnection();</b>
<b class="fc">&nbsp;        try (Statement statement = connection.createStatement()) {</b>
<b class="fc">&nbsp;            ResultSet rs = statement.executeQuery(checkPrimaryKey);</b>
<b class="fc">&nbsp;            List&lt;Pair&lt;String, String&gt;&gt; keys = new ArrayList&lt;&gt;();</b>
<b class="fc">&nbsp;            while (rs.next()) {</b>
<b class="fc">&nbsp;                String key = rs.getString(&quot;attname&quot;);</b>
<b class="fc">&nbsp;                String dataType = rs.getString(&quot;data_type&quot;);</b>
<b class="fc">&nbsp;                keys.add(Pair.of(key, dataType));</b>
&nbsp;            }
<b class="fc">&nbsp;            Assert.assertEquals(2, keys.size());</b>
<b class="fc">&nbsp;            Assert.assertEquals(&quot;int1&quot;, keys.get(0).getLeft());</b>
<b class="fc">&nbsp;            Assert.assertEquals(&quot;int2&quot;, keys.get(1).getLeft());</b>
&nbsp;        } catch (SQLException throwables) {
<b class="nc">&nbsp;            Assert.fail(throwables.getMessage());</b>
&nbsp;        }
&nbsp;
&nbsp;        //Delete the topology
<b class="fc">&nbsp;        dropSqlgSchema(this.sqlgGraph);</b>
&nbsp;
<b class="fc">&nbsp;        this.sqlgGraph.tx().commit();</b>
<b class="fc">&nbsp;        this.sqlgGraph.close();</b>
&nbsp;
<b class="fc">&nbsp;        try (SqlgGraph sqlgGraph1 = SqlgGraph.open(configuration)) {</b>
<b class="fc">&nbsp;            a = sqlgGraph1.getTopology().getPublicSchema().getVertexLabel(&quot;A&quot;).orElseThrow();</b>
<b class="fc">&nbsp;            Assert.assertEquals(&quot;int1,int2&quot;, a.getPartitionExpression());</b>
<b class="fc">&nbsp;            Assert.assertEquals(PartitionType.RANGE, a.getPartitionType());</b>
&nbsp;
<b class="fc">&nbsp;            Optional&lt;Partition&gt; part1 = a.getPartition(&quot;part1&quot;);</b>
<b class="fc">&nbsp;            Assert.assertTrue(part1.isPresent());</b>
<b class="fc">&nbsp;            Assert.assertNull(part1.get().getPartitionExpression());</b>
<b class="fc">&nbsp;            Assert.assertEquals(&quot;1, 1&quot;, part1.get().getFrom());</b>
<b class="fc">&nbsp;            Assert.assertEquals(&quot;5, 5&quot;, part1.get().getTo());</b>
<b class="fc">&nbsp;            Optional&lt;Partition&gt; part2 = a.getPartition(&quot;part2&quot;);</b>
<b class="fc">&nbsp;            Assert.assertTrue(part2.isPresent());</b>
<b class="fc">&nbsp;            Assert.assertNull(part2.get().getPartitionExpression());</b>
<b class="fc">&nbsp;            Assert.assertEquals(&quot;5, 5&quot;, part2.get().getFrom());</b>
<b class="fc">&nbsp;            Assert.assertEquals(&quot;10, 10&quot;, part2.get().getTo());</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    @Test
&nbsp;    public void testPartitionWithCompositeKeys() {
<b class="fc">&nbsp;        VertexLabel vertexLabel = this.sqlgGraph.getTopology().getPublicSchema().ensurePartitionedVertexLabelExist(</b>
&nbsp;                &quot;A&quot;,
<b class="fc">&nbsp;                new LinkedHashMap&lt;&gt;() {{</b>
<b class="fc">&nbsp;                    put(&quot;uid1&quot;, PropertyDefinition.of(PropertyType.INTEGER));</b>
<b class="fc">&nbsp;                    put(&quot;uid2&quot;, PropertyDefinition.of(PropertyType.LONG));</b>
<b class="fc">&nbsp;                    put(&quot;uid3&quot;, PropertyDefinition.of(PropertyType.STRING));</b>
&nbsp;                }},
<b class="fc">&nbsp;                ListOrderedSet.listOrderedSet(List.of(&quot;uid1&quot;, &quot;uid2&quot;, &quot;uid3&quot;)),</b>
&nbsp;                PartitionType.LIST,
&nbsp;                &quot;\&quot;uid1\&quot;&quot;
&nbsp;        );
<b class="fc">&nbsp;        vertexLabel.ensureListPartitionExists(&quot;listPartition1&quot;, &quot;&#39;1&#39;&quot;);</b>
<b class="fc">&nbsp;        this.sqlgGraph.tx().commit();</b>
<b class="fc">&nbsp;        this.sqlgGraph.addVertex(T.label, &quot;A&quot;, &quot;uid1&quot;, 1, &quot;uid2&quot;, 1L, &quot;uid3&quot;, &quot;halo1&quot;);</b>
<b class="fc">&nbsp;        this.sqlgGraph.addVertex(T.label, &quot;A&quot;, &quot;uid1&quot;, 1, &quot;uid2&quot;, 2L, &quot;uid3&quot;, &quot;halo1&quot;);</b>
<b class="fc">&nbsp;        this.sqlgGraph.tx().commit();</b>
&nbsp;
<b class="fc">&nbsp;        String checkPrimaryKey = &quot;SELECT a.attname, format_type(a.atttypid, a.atttypmod) AS data_type\n&quot; +</b>
&nbsp;                &quot;FROM   pg_index i\n&quot; +
&nbsp;                &quot;JOIN   pg_attribute a ON a.attrelid = i.indrelid\n&quot; +
&nbsp;                &quot;                     AND a.attnum = ANY(i.indkey)\n&quot; +
&nbsp;                &quot;WHERE  i.indrelid = &#39;\&quot;V_A\&quot;&#39;::regclass\n&quot; +
&nbsp;                &quot;AND    i.indisprimary;&quot;;
<b class="fc">&nbsp;        Connection connection = this.sqlgGraph.tx().getConnection();</b>
<b class="fc">&nbsp;        try (Statement statement = connection.createStatement()) {</b>
<b class="fc">&nbsp;            ResultSet rs = statement.executeQuery(checkPrimaryKey);</b>
<b class="fc">&nbsp;            List&lt;Pair&lt;String, String&gt;&gt; keys = new ArrayList&lt;&gt;();</b>
<b class="fc">&nbsp;            while (rs.next()) {</b>
<b class="fc">&nbsp;                String key = rs.getString(&quot;attname&quot;);</b>
<b class="fc">&nbsp;                String dataType = rs.getString(&quot;data_type&quot;);</b>
<b class="fc">&nbsp;                keys.add(Pair.of(key, dataType));</b>
&nbsp;            }
<b class="fc">&nbsp;            Assert.assertEquals(3, keys.size());</b>
<b class="fc">&nbsp;            Assert.assertEquals(&quot;uid1&quot;, keys.get(0).getLeft());</b>
<b class="fc">&nbsp;            Assert.assertEquals(&quot;uid2&quot;, keys.get(1).getLeft());</b>
<b class="fc">&nbsp;            Assert.assertEquals(&quot;uid3&quot;, keys.get(2).getLeft());</b>
&nbsp;        } catch (SQLException throwables) {
<b class="nc">&nbsp;            Assert.fail(throwables.getMessage());</b>
&nbsp;        }
&nbsp;
<b class="fc">&nbsp;        this.sqlgGraph.close();</b>
<b class="fc">&nbsp;        try (SqlgGraph sqlgGraph1 = SqlgGraph.open(configuration)) {</b>
<b class="fc">&nbsp;            ListOrderedSet&lt;String&gt; identifiers = sqlgGraph1.getTopology().getPublicSchema().getVertexLabel(&quot;A&quot;).orElseThrow().getIdentifiers();</b>
<b class="fc">&nbsp;            Assert.assertEquals(&quot;uid1&quot;, identifiers.get(0));</b>
<b class="fc">&nbsp;            Assert.assertEquals(&quot;uid2&quot;, identifiers.get(1));</b>
<b class="fc">&nbsp;            Assert.assertEquals(&quot;uid3&quot;, identifiers.get(2));</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * This test had a bug, making it pass. It is not possible to define a LIST partition on multiple keys.
&nbsp;     * As such this test name is incorrect but this comment should clarify the history.
&nbsp;     */
&nbsp;    @Test
&nbsp;    public void testPartitionEdgeOnMultipleUserDefinedForeignKey() {
<b class="fc">&nbsp;        LinkedHashMap&lt;String, PropertyDefinition&gt; attributeMap = new LinkedHashMap&lt;&gt;();</b>
<b class="fc">&nbsp;        attributeMap.put(&quot;name&quot;, PropertyDefinition.of(PropertyType.STRING));</b>
<b class="fc">&nbsp;        attributeMap.put(&quot;cmUid&quot;, PropertyDefinition.of(PropertyType.STRING));</b>
<b class="fc">&nbsp;        attributeMap.put(&quot;vendorTechnology&quot;, PropertyDefinition.of(PropertyType.STRING));</b>
&nbsp;
<b class="fc">&nbsp;        VertexLabel realWorkspaceElementVertexLabel = sqlgGraph.getTopology().getPublicSchema().ensurePartitionedVertexLabelExist(</b>
&nbsp;                &quot;RealWorkspaceElement&quot;,
&nbsp;                attributeMap,
<b class="fc">&nbsp;                ListOrderedSet.listOrderedSet(List.of(&quot;cmUid&quot;, &quot;vendorTechnology&quot;)),</b>
&nbsp;                PartitionType.LIST,
&nbsp;                &quot;\&quot;vendorTechnology\&quot;&quot;
&nbsp;        );
<b class="fc">&nbsp;        for (TEST test : TEST.values()) {</b>
<b class="fc">&nbsp;            Partition partition = realWorkspaceElementVertexLabel.ensureListPartitionExists(</b>
<b class="fc">&nbsp;                    test.name(),</b>
<b class="fc">&nbsp;                    &quot;&#39;&quot; + test.name() + &quot;&#39;&quot;</b>
&nbsp;            );
&nbsp;        }
<b class="fc">&nbsp;        PropertyColumn propertyColumn = realWorkspaceElementVertexLabel.getProperty(&quot;cmUid&quot;).orElseThrow(IllegalStateException::new);</b>
<b class="fc">&nbsp;        realWorkspaceElementVertexLabel.ensureIndexExists(IndexType.UNIQUE, Collections.singletonList(propertyColumn));</b>
&nbsp;
<b class="fc">&nbsp;        VertexLabel virtualGroupVertexLabel = sqlgGraph.getTopology().getPublicSchema().ensureVertexLabelExist(</b>
&nbsp;                &quot;VirtualGroup&quot;,
<b class="fc">&nbsp;                new LinkedHashMap&lt;&gt;() {{</b>
<b class="fc">&nbsp;                    put(&quot;uid1&quot;, PropertyDefinition.of(PropertyType.STRING));</b>
<b class="fc">&nbsp;                    put(&quot;uid2&quot;, PropertyDefinition.of(PropertyType.STRING));</b>
<b class="fc">&nbsp;                    put(&quot;name&quot;, PropertyDefinition.of(PropertyType.STRING));</b>
&nbsp;                }},
<b class="fc">&nbsp;                ListOrderedSet.listOrderedSet(List.of(&quot;uid1&quot;))</b>
&nbsp;        );
&nbsp;
<b class="fc">&nbsp;        EdgeLabel edgeLabel = this.sqlgGraph.getTopology().getPublicSchema().ensurePartitionedEdgeLabelExistOnInOrOutVertexLabel(</b>
&nbsp;                &quot;virtualGroup_RealWorkspaceElement&quot;,
&nbsp;                virtualGroupVertexLabel,
&nbsp;                realWorkspaceElementVertexLabel,
<b class="fc">&nbsp;                new LinkedHashMap&lt;&gt;() {{</b>
<b class="fc">&nbsp;                    put(&quot;uid&quot;, PropertyDefinition.of(PropertyType.STRING));</b>
&nbsp;                }},
<b class="fc">&nbsp;                ListOrderedSet.listOrderedSet(Collections.singletonList(&quot;uid&quot;)),</b>
&nbsp;                PartitionType.LIST,
&nbsp;                virtualGroupVertexLabel
&nbsp;        );
&nbsp;
&nbsp;
<b class="fc">&nbsp;        this.sqlgGraph.tx().commit();</b>
&nbsp;
<b class="fc">&nbsp;        Vertex v1 = this.sqlgGraph.addVertex(T.label, &quot;RealWorkspaceElement&quot;, &quot;cmUid&quot;, &quot;a&quot;, &quot;vendorTechnology&quot;, TEST.TEST1.name());</b>
<b class="fc">&nbsp;        Vertex v2 = this.sqlgGraph.addVertex(T.label, &quot;RealWorkspaceElement&quot;, &quot;cmUid&quot;, &quot;b&quot;, &quot;vendorTechnology&quot;, TEST.TEST2.name());</b>
<b class="fc">&nbsp;        Vertex v3 = this.sqlgGraph.addVertex(T.label, &quot;RealWorkspaceElement&quot;, &quot;cmUid&quot;, &quot;c&quot;, &quot;vendorTechnology&quot;, TEST.TEST3.name());</b>
<b class="fc">&nbsp;        this.sqlgGraph.tx().commit();</b>
&nbsp;
<b class="fc">&nbsp;        Vertex northern = this.sqlgGraph.addVertex(T.label, &quot;VirtualGroup&quot;, &quot;uid1&quot;, UUID.randomUUID().toString(), &quot;uid2&quot;, UUID.randomUUID().toString(), &quot;name&quot;, &quot;Northern&quot;);</b>
<b class="fc">&nbsp;        Partition partition = edgeLabel.ensureListPartitionExists(</b>
&nbsp;                &quot;Northern&quot;,
<b class="fc">&nbsp;                &quot;&#39;&quot; + ((RecordId) northern.id()).getID().getIdentifiers().get(0).toString() + &quot;&#39;&quot;</b>
&nbsp;        );
<b class="fc">&nbsp;        Vertex western = this.sqlgGraph.addVertex(T.label, &quot;VirtualGroup&quot;, &quot;uid1&quot;, UUID.randomUUID().toString(), &quot;uid2&quot;, UUID.randomUUID().toString(), &quot;name&quot;, &quot;Western&quot;);</b>
<b class="fc">&nbsp;        partition = edgeLabel.ensureListPartitionExists(</b>
&nbsp;                &quot;Western&quot;,
<b class="fc">&nbsp;                &quot;&#39;&quot; + ((RecordId) western.id()).getID().getIdentifiers().get(0).toString() + &quot;&#39;&quot;</b>
&nbsp;        );
<b class="fc">&nbsp;        Edge e = northern.addEdge(&quot;virtualGroup_RealWorkspaceElement&quot;, v1, &quot;uid&quot;, UUID.randomUUID().toString());</b>
<b class="fc">&nbsp;        e.properties(&quot;what&quot;, &quot;this&quot;);</b>
<b class="fc">&nbsp;        e = western.addEdge(&quot;virtualGroup_RealWorkspaceElement&quot;, v1, &quot;uid&quot;, UUID.randomUUID().toString());</b>
<b class="fc">&nbsp;        e.properties(&quot;what&quot;, &quot;this&quot;);</b>
<b class="fc">&nbsp;        this.sqlgGraph.tx().commit();</b>
&nbsp;
<b class="fc">&nbsp;        Assert.assertEquals(1, this.sqlgGraph.traversal().V().hasLabel(&quot;RealWorkspaceElement&quot;).has(&quot;vendorTechnology&quot;, TEST.TEST1.name()).count().next(), 0);</b>
<b class="fc">&nbsp;        Assert.assertEquals(1, this.sqlgGraph.traversal().V().hasLabel(&quot;RealWorkspaceElement&quot;).has(&quot;vendorTechnology&quot;, TEST.TEST2.name()).count().next(), 0);</b>
<b class="fc">&nbsp;        Assert.assertEquals(1, this.sqlgGraph.traversal().V().hasLabel(&quot;RealWorkspaceElement&quot;).has(&quot;vendorTechnology&quot;, TEST.TEST3.name()).count().next(), 0);</b>
<b class="fc">&nbsp;        Assert.assertEquals(3, this.sqlgGraph.traversal().V().hasLabel(&quot;RealWorkspaceElement&quot;).count().next(), 0);</b>
&nbsp;
<b class="fc">&nbsp;        List&lt;Vertex&gt; vertices = this.sqlgGraph.traversal().V(v1).in(&quot;virtualGroup_RealWorkspaceElement&quot;).toList();</b>
<b class="fc">&nbsp;        Assert.assertEquals(2, vertices.size());</b>
<b class="fc">&nbsp;        Assert.assertTrue(vertices.contains(northern));</b>
<b class="fc">&nbsp;        Assert.assertTrue(vertices.contains(western));</b>
&nbsp;    }
&nbsp;
&nbsp;    @Test
&nbsp;    public void testPartitionEdge() {
<b class="fc">&nbsp;        LinkedHashMap&lt;String, PropertyDefinition&gt; attributeMap = new LinkedHashMap&lt;&gt;();</b>
<b class="fc">&nbsp;        attributeMap.put(&quot;name&quot;, PropertyDefinition.of(PropertyType.STRING));</b>
<b class="fc">&nbsp;        attributeMap.put(&quot;cmUid&quot;, PropertyDefinition.of(PropertyType.STRING));</b>
<b class="fc">&nbsp;        attributeMap.put(&quot;vendorTechnology&quot;, PropertyDefinition.of(PropertyType.STRING));</b>
&nbsp;
<b class="fc">&nbsp;        VertexLabel realWorkspaceElementVertexLabel = sqlgGraph.getTopology().getPublicSchema().ensurePartitionedVertexLabelExist(</b>
&nbsp;                &quot;RealWorkspaceElement&quot;,
&nbsp;                attributeMap,
<b class="fc">&nbsp;                ListOrderedSet.listOrderedSet(List.of(&quot;cmUid&quot;, &quot;vendorTechnology&quot;)),</b>
&nbsp;                PartitionType.LIST,
&nbsp;                &quot;\&quot;vendorTechnology\&quot;&quot;
&nbsp;        );
<b class="fc">&nbsp;        for (TEST test : TEST.values()) {</b>
<b class="fc">&nbsp;            Partition partition = realWorkspaceElementVertexLabel.ensureListPartitionExists(</b>
<b class="fc">&nbsp;                    test.name(),</b>
<b class="fc">&nbsp;                    &quot;&#39;&quot; + test.name() + &quot;&#39;&quot;</b>
&nbsp;            );
&nbsp;        }
&nbsp;
<b class="fc">&nbsp;        VertexLabel virtualGroupVertexLabel = sqlgGraph.getTopology().getPublicSchema().ensureVertexLabelExist(</b>
&nbsp;                &quot;VirtualGroup&quot;,
<b class="fc">&nbsp;                new LinkedHashMap&lt;&gt;() {{</b>
<b class="fc">&nbsp;                    put(&quot;name&quot;, PropertyDefinition.of(PropertyType.STRING));</b>
&nbsp;                }}
&nbsp;        );
&nbsp;
<b class="fc">&nbsp;        EdgeLabel edgeLabel = this.sqlgGraph.getTopology().getPublicSchema().ensurePartitionedEdgeLabelExist(</b>
&nbsp;                &quot;virtualGroup_RealWorkspaceElement&quot;,
&nbsp;                virtualGroupVertexLabel,
&nbsp;                realWorkspaceElementVertexLabel,
<b class="fc">&nbsp;                new LinkedHashMap&lt;&gt;() {{</b>
<b class="fc">&nbsp;                    put(&quot;uid&quot;, PropertyDefinition.of(PropertyType.STRING));</b>
<b class="fc">&nbsp;                    put(&quot;name&quot;, PropertyDefinition.of(PropertyType.STRING));</b>
&nbsp;                }},
<b class="fc">&nbsp;                ListOrderedSet.listOrderedSet(List.of(&quot;uid&quot;, &quot;name&quot;)),</b>
&nbsp;                PartitionType.LIST,
&nbsp;                &quot;name&quot;
&nbsp;        );
<b class="fc">&nbsp;        Partition partition = edgeLabel.ensureListPartitionExists(</b>
&nbsp;                &quot;Northern&quot;,
&nbsp;                &quot;&#39;Northern&#39;&quot;
&nbsp;        );
<b class="fc">&nbsp;        partition = edgeLabel.ensureListPartitionExists(</b>
&nbsp;                &quot;Western&quot;,
&nbsp;                &quot;&#39;Western&#39;&quot;
&nbsp;        );
&nbsp;
&nbsp;
<b class="fc">&nbsp;        this.sqlgGraph.tx().commit();</b>
<b class="fc">&nbsp;        String checkPrimaryKey = &quot;SELECT a.attname, format_type(a.atttypid, a.atttypmod) AS data_type\n&quot; +</b>
&nbsp;                &quot;FROM   pg_index i\n&quot; +
&nbsp;                &quot;JOIN   pg_attribute a ON a.attrelid = i.indrelid\n&quot; +
&nbsp;                &quot;                     AND a.attnum = ANY(i.indkey)\n&quot; +
&nbsp;                &quot;WHERE  i.indrelid = &#39;\&quot;E_virtualGroup_RealWorkspaceElement\&quot;&#39;::regclass\n&quot; +
&nbsp;                &quot;AND    i.indisprimary;&quot;;
<b class="fc">&nbsp;        Connection connection = this.sqlgGraph.tx().getConnection();</b>
<b class="fc">&nbsp;        try (Statement statement = connection.createStatement()) {</b>
<b class="fc">&nbsp;            ResultSet rs = statement.executeQuery(checkPrimaryKey);</b>
<b class="fc">&nbsp;            List&lt;Pair&lt;String, String&gt;&gt; keys = new ArrayList&lt;&gt;();</b>
<b class="fc">&nbsp;            while (rs.next()) {</b>
<b class="fc">&nbsp;                String key = rs.getString(&quot;attname&quot;);</b>
<b class="fc">&nbsp;                String dataType = rs.getString(&quot;data_type&quot;);</b>
<b class="fc">&nbsp;                keys.add(Pair.of(key, dataType));</b>
&nbsp;            }
<b class="fc">&nbsp;            Assert.assertEquals(2, keys.size());</b>
<b class="fc">&nbsp;            Assert.assertEquals(&quot;uid&quot;, keys.get(0).getLeft());</b>
<b class="fc">&nbsp;            Assert.assertEquals(&quot;name&quot;, keys.get(1).getLeft());</b>
&nbsp;        } catch (SQLException throwables) {
<b class="nc">&nbsp;            Assert.fail(throwables.getMessage());</b>
&nbsp;        }
&nbsp;
<b class="fc">&nbsp;        Vertex v1 = this.sqlgGraph.addVertex(T.label, &quot;RealWorkspaceElement&quot;, &quot;cmUid&quot;, &quot;a1&quot;, &quot;vendorTechnology&quot;, TEST.TEST1.name());</b>
<b class="fc">&nbsp;        Vertex v11 = this.sqlgGraph.addVertex(T.label, &quot;RealWorkspaceElement&quot;, &quot;cmUid&quot;, &quot;a2&quot;, &quot;vendorTechnology&quot;, TEST.TEST1.name());</b>
<b class="fc">&nbsp;        Vertex v2 = this.sqlgGraph.addVertex(T.label, &quot;RealWorkspaceElement&quot;, &quot;cmUid&quot;, &quot;b1&quot;, &quot;vendorTechnology&quot;, TEST.TEST2.name());</b>
<b class="fc">&nbsp;        Vertex v3 = this.sqlgGraph.addVertex(T.label, &quot;RealWorkspaceElement&quot;, &quot;cmUid&quot;, &quot;c1&quot;, &quot;vendorTechnology&quot;, TEST.TEST3.name());</b>
<b class="fc">&nbsp;        this.sqlgGraph.tx().commit();</b>
&nbsp;
<b class="fc">&nbsp;        Vertex northern = this.sqlgGraph.addVertex(T.label, &quot;VirtualGroup&quot;, &quot;name&quot;, &quot;Northern&quot;);</b>
<b class="fc">&nbsp;        Vertex western = this.sqlgGraph.addVertex(T.label, &quot;VirtualGroup&quot;, &quot;name&quot;, &quot;Western&quot;);</b>
<b class="fc">&nbsp;        Edge e = northern.addEdge(&quot;virtualGroup_RealWorkspaceElement&quot;, v1, &quot;name&quot;, &quot;Northern&quot;, &quot;uid&quot;, UUID.randomUUID().toString());</b>
<b class="fc">&nbsp;        e = northern.addEdge(&quot;virtualGroup_RealWorkspaceElement&quot;, v11, &quot;name&quot;, &quot;Northern&quot;, &quot;uid&quot;, UUID.randomUUID().toString());</b>
<b class="fc">&nbsp;        e = western.addEdge(&quot;virtualGroup_RealWorkspaceElement&quot;, v1, &quot;name&quot;, &quot;Western&quot;, &quot;uid&quot;, UUID.randomUUID().toString());</b>
<b class="fc">&nbsp;        this.sqlgGraph.tx().commit();</b>
&nbsp;
<b class="fc">&nbsp;        Assert.assertEquals(2, this.sqlgGraph.traversal().V().hasLabel(&quot;RealWorkspaceElement&quot;).has(&quot;vendorTechnology&quot;, TEST.TEST1.name()).count().next(), 0);</b>
<b class="fc">&nbsp;        Assert.assertEquals(1, this.sqlgGraph.traversal().V().hasLabel(&quot;RealWorkspaceElement&quot;).has(&quot;vendorTechnology&quot;, TEST.TEST2.name()).count().next(), 0);</b>
<b class="fc">&nbsp;        Assert.assertEquals(1, this.sqlgGraph.traversal().V().hasLabel(&quot;RealWorkspaceElement&quot;).has(&quot;vendorTechnology&quot;, TEST.TEST3.name()).count().next(), 0);</b>
<b class="fc">&nbsp;        Assert.assertEquals(4, this.sqlgGraph.traversal().V().hasLabel(&quot;RealWorkspaceElement&quot;).count().next(), 0);</b>
&nbsp;
<b class="fc">&nbsp;        List&lt;Vertex&gt; vertices = this.sqlgGraph.traversal().V(v1).in(&quot;virtualGroup_RealWorkspaceElement&quot;).toList();</b>
<b class="fc">&nbsp;        Assert.assertEquals(2, vertices.size());</b>
<b class="fc">&nbsp;        Assert.assertEquals(northern, vertices.get(0));</b>
<b class="fc">&nbsp;        Assert.assertEquals(western, vertices.get(1));</b>
&nbsp;    }
&nbsp;
&nbsp;    @Test
&nbsp;    public void testPartitionEdgeNoIdentifiers() {
<b class="fc">&nbsp;        LinkedHashMap&lt;String, PropertyDefinition&gt; attributeMap = new LinkedHashMap&lt;&gt;();</b>
<b class="fc">&nbsp;        attributeMap.put(&quot;name&quot;, PropertyDefinition.of(PropertyType.STRING));</b>
<b class="fc">&nbsp;        attributeMap.put(&quot;cmUid&quot;, PropertyDefinition.of(PropertyType.STRING));</b>
<b class="fc">&nbsp;        attributeMap.put(&quot;vendorTechnology&quot;, PropertyDefinition.of(PropertyType.STRING));</b>
&nbsp;
<b class="fc">&nbsp;        VertexLabel realWorkspaceElementVertexLabel = sqlgGraph.getTopology().getPublicSchema().ensurePartitionedVertexLabelExist(</b>
&nbsp;                &quot;RealWorkspaceElement&quot;,
&nbsp;                attributeMap,
<b class="fc">&nbsp;                ListOrderedSet.listOrderedSet(List.of(&quot;cmUid&quot;, &quot;vendorTechnology&quot;)),</b>
&nbsp;                PartitionType.LIST,
&nbsp;                &quot;\&quot;vendorTechnology\&quot;&quot;
&nbsp;        );
<b class="fc">&nbsp;        for (TEST test : TEST.values()) {</b>
<b class="fc">&nbsp;            Partition partition = realWorkspaceElementVertexLabel.ensureListPartitionExists(</b>
<b class="fc">&nbsp;                    test.name(),</b>
<b class="fc">&nbsp;                    &quot;&#39;&quot; + test.name() + &quot;&#39;&quot;</b>
&nbsp;            );
&nbsp;        }
&nbsp;
<b class="fc">&nbsp;        VertexLabel virtualGroupVertexLabel = sqlgGraph.getTopology().getPublicSchema().ensureVertexLabelExist(</b>
&nbsp;                &quot;VirtualGroup&quot;,
<b class="fc">&nbsp;                new LinkedHashMap&lt;&gt;() {{</b>
<b class="fc">&nbsp;                    put(&quot;name&quot;, PropertyDefinition.of(PropertyType.STRING));</b>
&nbsp;                }}
&nbsp;        );
&nbsp;
<b class="fc">&nbsp;        EdgeLabel edgeLabel = this.sqlgGraph.getTopology().getPublicSchema().ensurePartitionedEdgeLabelExist(</b>
&nbsp;                &quot;virtualGroup_RealWorkspaceElement&quot;,
&nbsp;                virtualGroupVertexLabel,
&nbsp;                realWorkspaceElementVertexLabel,
<b class="fc">&nbsp;                new LinkedHashMap&lt;&gt;() {{</b>
<b class="fc">&nbsp;                    put(&quot;name&quot;, PropertyDefinition.of(PropertyType.STRING));</b>
&nbsp;                }},
<b class="fc">&nbsp;                ListOrderedSet.listOrderedSet(List.of()),</b>
&nbsp;                PartitionType.LIST,
&nbsp;                &quot;name&quot;
&nbsp;        );
<b class="fc">&nbsp;        Partition partition = edgeLabel.ensureListPartitionExists(</b>
&nbsp;                &quot;Northern&quot;,
&nbsp;                &quot;&#39;Northern&#39;&quot;
&nbsp;        );
<b class="fc">&nbsp;        partition = edgeLabel.ensureListPartitionExists(</b>
&nbsp;                &quot;Western&quot;,
&nbsp;                &quot;&#39;Western&#39;&quot;
&nbsp;        );
&nbsp;
&nbsp;
<b class="fc">&nbsp;        this.sqlgGraph.tx().commit();</b>
&nbsp;
<b class="fc">&nbsp;        Vertex v1 = this.sqlgGraph.addVertex(T.label, &quot;RealWorkspaceElement&quot;, &quot;cmUid&quot;, &quot;a1&quot;, &quot;vendorTechnology&quot;, TEST.TEST1.name());</b>
<b class="fc">&nbsp;        Vertex v11 = this.sqlgGraph.addVertex(T.label, &quot;RealWorkspaceElement&quot;, &quot;cmUid&quot;, &quot;a2&quot;, &quot;vendorTechnology&quot;, TEST.TEST1.name());</b>
<b class="fc">&nbsp;        Vertex v2 = this.sqlgGraph.addVertex(T.label, &quot;RealWorkspaceElement&quot;, &quot;cmUid&quot;, &quot;b1&quot;, &quot;vendorTechnology&quot;, TEST.TEST2.name());</b>
<b class="fc">&nbsp;        Vertex v3 = this.sqlgGraph.addVertex(T.label, &quot;RealWorkspaceElement&quot;, &quot;cmUid&quot;, &quot;c1&quot;, &quot;vendorTechnology&quot;, TEST.TEST3.name());</b>
<b class="fc">&nbsp;        this.sqlgGraph.tx().commit();</b>
&nbsp;
<b class="fc">&nbsp;        Vertex northern = this.sqlgGraph.addVertex(T.label, &quot;VirtualGroup&quot;, &quot;name&quot;, &quot;Northern&quot;);</b>
<b class="fc">&nbsp;        Vertex western = this.sqlgGraph.addVertex(T.label, &quot;VirtualGroup&quot;, &quot;name&quot;, &quot;Western&quot;);</b>
<b class="fc">&nbsp;        Edge e = northern.addEdge(&quot;virtualGroup_RealWorkspaceElement&quot;, v1, &quot;name&quot;, &quot;Northern&quot;);</b>
<b class="fc">&nbsp;        e = northern.addEdge(&quot;virtualGroup_RealWorkspaceElement&quot;, v11, &quot;name&quot;, &quot;Northern&quot;);</b>
<b class="fc">&nbsp;        e = western.addEdge(&quot;virtualGroup_RealWorkspaceElement&quot;, v1, &quot;name&quot;, &quot;Western&quot;);</b>
<b class="fc">&nbsp;        this.sqlgGraph.tx().commit();</b>
&nbsp;
<b class="fc">&nbsp;        Assert.assertEquals(2, this.sqlgGraph.traversal().V().hasLabel(&quot;RealWorkspaceElement&quot;).has(&quot;vendorTechnology&quot;, TEST.TEST1.name()).count().next(), 0);</b>
<b class="fc">&nbsp;        Assert.assertEquals(1, this.sqlgGraph.traversal().V().hasLabel(&quot;RealWorkspaceElement&quot;).has(&quot;vendorTechnology&quot;, TEST.TEST2.name()).count().next(), 0);</b>
<b class="fc">&nbsp;        Assert.assertEquals(1, this.sqlgGraph.traversal().V().hasLabel(&quot;RealWorkspaceElement&quot;).has(&quot;vendorTechnology&quot;, TEST.TEST3.name()).count().next(), 0);</b>
<b class="fc">&nbsp;        Assert.assertEquals(4, this.sqlgGraph.traversal().V().hasLabel(&quot;RealWorkspaceElement&quot;).count().next(), 0);</b>
&nbsp;
<b class="fc">&nbsp;        List&lt;Vertex&gt; vertices = this.sqlgGraph.traversal().V(v1).in(&quot;virtualGroup_RealWorkspaceElement&quot;).toList();</b>
<b class="fc">&nbsp;        Assert.assertEquals(2, vertices.size());</b>
<b class="fc">&nbsp;        Assert.assertEquals(northern, vertices.get(0));</b>
<b class="fc">&nbsp;        Assert.assertEquals(western, vertices.get(1));</b>
&nbsp;
&nbsp;        //Check if the partitions are being used
<b class="fc">&nbsp;        Connection conn = this.sqlgGraph.tx().getConnection();</b>
<b class="fc">&nbsp;        try (Statement statement = conn.createStatement()) {</b>
<b class="fc">&nbsp;            boolean scanRealWorkspaceElementPartition = false;</b>
<b class="pc">&nbsp;            if (this.sqlgGraph.getSqlDialect().getClass().getSimpleName().contains(&quot;Postgres&quot;)) {</b>
<b class="fc">&nbsp;                ResultSet rs = statement.executeQuery(&quot;explain SELECT\n&quot; +</b>
&nbsp;                        &quot;\t\&quot;public\&quot;.\&quot;V_VirtualGroup\&quot;.\&quot;ID\&quot; AS \&quot;alias1\&quot;,\n&quot; +
&nbsp;                        &quot;\t\&quot;public\&quot;.\&quot;V_VirtualGroup\&quot;.\&quot;name\&quot; AS \&quot;alias2\&quot;\n&quot; +
&nbsp;                        &quot;FROM\n&quot; +
&nbsp;                        &quot;\t\&quot;public\&quot;.\&quot;V_RealWorkspaceElement\&quot; INNER JOIN\n&quot; +
&nbsp;                        &quot;\t\&quot;public\&quot;.\&quot;E_virtualGroup_RealWorkspaceElement\&quot; ON \&quot;public\&quot;.\&quot;V_RealWorkspaceElement\&quot;.\&quot;cmUid\&quot; = \&quot;public\&quot;.\&quot;E_virtualGroup_RealWorkspaceElement\&quot;.\&quot;public.RealWorkspaceElement.cmUid__I\&quot; AND \&quot;public\&quot;.\&quot;V_RealWorkspaceElement\&quot;.\&quot;vendorTechnology\&quot; = \&quot;public\&quot;.\&quot;E_virtualGroup_RealWorkspaceElement\&quot;.\&quot;public.RealWorkspaceElement.vendorTechnology__I\&quot; INNER JOIN\n&quot; +
&nbsp;                        &quot;\t\&quot;public\&quot;.\&quot;V_VirtualGroup\&quot; ON \&quot;public\&quot;.\&quot;E_virtualGroup_RealWorkspaceElement\&quot;.\&quot;public.VirtualGroup__O\&quot; = \&quot;public\&quot;.\&quot;V_VirtualGroup\&quot;.\&quot;ID\&quot;\n&quot; +
&nbsp;                        &quot;WHERE\n&quot; +
&nbsp;                        &quot;\t( \&quot;public\&quot;.\&quot;V_RealWorkspaceElement\&quot;.\&quot;cmUid\&quot; = &#39;a1&#39; AND \&quot;public\&quot;.\&quot;V_RealWorkspaceElement\&quot;.\&quot;vendorTechnology\&quot; = &#39;TEST1&#39;)&quot;);
<b class="fc">&nbsp;                while (rs.next()) {</b>
<b class="fc">&nbsp;                    String result = rs.getString(1);</b>
<b class="fc">&nbsp;                    scanRealWorkspaceElementPartition = scanRealWorkspaceElementPartition || result.contains(&quot;Index Only Scan using \&quot;TEST1_pkey\&quot;&quot;);</b>
&nbsp;                }
&nbsp;            }
<b class="fc">&nbsp;            Assert.assertTrue(scanRealWorkspaceElementPartition);</b>
&nbsp;        } catch (SQLException ee) {
<b class="nc">&nbsp;            Assert.fail(ee.getMessage());</b>
&nbsp;        }
&nbsp;
<b class="fc">&nbsp;        vertices = this.sqlgGraph.traversal().V(v1).inE(&quot;virtualGroup_RealWorkspaceElement&quot;).has(&quot;name&quot;, &quot;Northern&quot;).otherV().toList();</b>
<b class="fc">&nbsp;        Assert.assertEquals(1, vertices.size());</b>
<b class="fc">&nbsp;        Assert.assertEquals(northern, vertices.get(0));</b>
<b class="fc">&nbsp;        try (Statement statement = conn.createStatement()) {</b>
<b class="fc">&nbsp;            boolean scanRealWorkspaceElementPartition = false;</b>
<b class="fc">&nbsp;            boolean scanEdgePartition = false;</b>
<b class="pc">&nbsp;            if (this.sqlgGraph.getSqlDialect().getClass().getSimpleName().contains(&quot;Postgres&quot;)) {</b>
<b class="fc">&nbsp;                ResultSet rs = statement.executeQuery(&quot;explain SELECT\n&quot; +</b>
&nbsp;                        &quot;\t\&quot;public\&quot;.\&quot;V_RealWorkspaceElement\&quot;.\&quot;cmUid\&quot; AS \&quot;alias1\&quot;,\n&quot; +
&nbsp;                        &quot;\t\&quot;public\&quot;.\&quot;V_RealWorkspaceElement\&quot;.\&quot;vendorTechnology\&quot; AS \&quot;alias2\&quot;,\n&quot; +
&nbsp;                        &quot;\t\&quot;public\&quot;.\&quot;V_RealWorkspaceElement\&quot;.\&quot;name\&quot; AS \&quot;alias3\&quot;,\n&quot; +
&nbsp;                        &quot;\t\&quot;public\&quot;.\&quot;E_virtualGroup_RealWorkspaceElement\&quot;.\&quot;ID\&quot; AS \&quot;alias4\&quot;,\n&quot; +
&nbsp;                        &quot;\t\&quot;public\&quot;.\&quot;E_virtualGroup_RealWorkspaceElement\&quot;.\&quot;name\&quot; AS \&quot;alias5\&quot;,\n&quot; +
&nbsp;                        &quot;\t\&quot;public\&quot;.\&quot;E_virtualGroup_RealWorkspaceElement\&quot;.\&quot;public.VirtualGroup__O\&quot; AS \&quot;alias6\&quot;,\n&quot; +
&nbsp;                        &quot;\t\&quot;public\&quot;.\&quot;E_virtualGroup_RealWorkspaceElement\&quot;.\&quot;public.RealWorkspaceElement.cmUid__I\&quot; AS \&quot;alias7\&quot;,\n&quot; +
&nbsp;                        &quot;\t\&quot;public\&quot;.\&quot;E_virtualGroup_RealWorkspaceElement\&quot;.\&quot;public.RealWorkspaceElement.vendorTechnology__I\&quot; AS \&quot;alias8\&quot;,\n&quot; +
&nbsp;                        &quot;\t\&quot;public\&quot;.\&quot;V_VirtualGroup\&quot;.\&quot;ID\&quot; AS \&quot;alias9\&quot;,\n&quot; +
&nbsp;                        &quot;\t\&quot;public\&quot;.\&quot;V_VirtualGroup\&quot;.\&quot;name\&quot; AS \&quot;alias10\&quot;\n&quot; +
&nbsp;                        &quot;FROM\n&quot; +
&nbsp;                        &quot;\t\&quot;public\&quot;.\&quot;V_RealWorkspaceElement\&quot; INNER JOIN\n&quot; +
&nbsp;                        &quot;\t\&quot;public\&quot;.\&quot;E_virtualGroup_RealWorkspaceElement\&quot; ON \&quot;public\&quot;.\&quot;V_RealWorkspaceElement\&quot;.\&quot;cmUid\&quot; = \&quot;public\&quot;.\&quot;E_virtualGroup_RealWorkspaceElement\&quot;.\&quot;public.RealWorkspaceElement.cmUid__I\&quot; AND \&quot;public\&quot;.\&quot;V_RealWorkspaceElement\&quot;.\&quot;vendorTechnology\&quot; = \&quot;public\&quot;.\&quot;E_virtualGroup_RealWorkspaceElement\&quot;.\&quot;public.RealWorkspaceElement.vendorTechnology__I\&quot; INNER JOIN\n&quot; +
&nbsp;                        &quot;\t\&quot;public\&quot;.\&quot;V_VirtualGroup\&quot; ON \&quot;public\&quot;.\&quot;E_virtualGroup_RealWorkspaceElement\&quot;.\&quot;public.VirtualGroup__O\&quot; = \&quot;public\&quot;.\&quot;V_VirtualGroup\&quot;.\&quot;ID\&quot;\n&quot; +
&nbsp;                        &quot;WHERE\n&quot; +
&nbsp;                        &quot;\t( \&quot;public\&quot;.\&quot;V_RealWorkspaceElement\&quot;.\&quot;cmUid\&quot; = &#39;a1&#39; AND \&quot;public\&quot;.\&quot;V_RealWorkspaceElement\&quot;.\&quot;vendorTechnology\&quot; = &#39;TEST1&#39;) AND ( \&quot;public\&quot;.\&quot;E_virtualGroup_RealWorkspaceElement\&quot;.\&quot;name\&quot; = &#39;Northern&#39;)\n&quot;);
<b class="fc">&nbsp;                while (rs.next()) {</b>
<b class="fc">&nbsp;                    String result = rs.getString(1);</b>
<b class="fc">&nbsp;                    scanRealWorkspaceElementPartition = scanRealWorkspaceElementPartition || result.contains(&quot;Index Scan using \&quot;TEST1_pkey\&quot;&quot;);</b>
<b class="fc">&nbsp;                    scanEdgePartition = scanEdgePartition || result.contains(&quot;Index Scan using \&quot;Northern_public.RealWorkspaceElement.cmUid__I_public.RealWo_idx\&quot; on \&quot;Northern\&quot;&quot;);</b>
&nbsp;                }
&nbsp;            }
<b class="fc">&nbsp;            Assert.assertTrue(scanRealWorkspaceElementPartition);</b>
<b class="fc">&nbsp;            Assert.assertTrue(scanEdgePartition);</b>
&nbsp;        } catch (SQLException ee) {
<b class="nc">&nbsp;            Assert.fail(ee.getMessage());</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    @Test
&nbsp;    public void testPartitionEdgeOnUserDefinedForeignKey() {
<b class="fc">&nbsp;        LinkedHashMap&lt;String, PropertyDefinition&gt; attributeMap = new LinkedHashMap&lt;&gt;();</b>
<b class="fc">&nbsp;        attributeMap.put(&quot;name&quot;, PropertyDefinition.of(PropertyType.STRING));</b>
<b class="fc">&nbsp;        attributeMap.put(&quot;cmUid&quot;, PropertyDefinition.of(PropertyType.STRING));</b>
<b class="fc">&nbsp;        attributeMap.put(&quot;vendorTechnology&quot;, PropertyDefinition.of(PropertyType.STRING));</b>
&nbsp;
<b class="fc">&nbsp;        VertexLabel realWorkspaceElementVertexLabel = sqlgGraph.getTopology().getPublicSchema().ensurePartitionedVertexLabelExist(</b>
&nbsp;                &quot;RealWorkspaceElement&quot;,
&nbsp;                attributeMap,
<b class="fc">&nbsp;                ListOrderedSet.listOrderedSet(List.of(&quot;vendorTechnology&quot;, &quot;cmUid&quot;)),</b>
&nbsp;                PartitionType.LIST,
&nbsp;                &quot;\&quot;vendorTechnology\&quot;&quot;
&nbsp;        );
<b class="fc">&nbsp;        for (TEST test : TEST.values()) {</b>
<b class="fc">&nbsp;            Partition partition = realWorkspaceElementVertexLabel.ensureListPartitionExists(</b>
<b class="fc">&nbsp;                    test.name(),</b>
<b class="fc">&nbsp;                    &quot;&#39;&quot; + test.name() + &quot;&#39;&quot;</b>
&nbsp;            );
&nbsp;        }
&nbsp;
<b class="fc">&nbsp;        VertexLabel virtualGroupVertexLabel = sqlgGraph.getTopology().getPublicSchema().ensureVertexLabelExist(</b>
&nbsp;                &quot;VirtualGroup&quot;,
<b class="fc">&nbsp;                new LinkedHashMap&lt;&gt;() {{</b>
<b class="fc">&nbsp;                    put(&quot;uid&quot;, PropertyDefinition.of(PropertyType.STRING));</b>
<b class="fc">&nbsp;                    put(&quot;name&quot;, PropertyDefinition.of(PropertyType.STRING));</b>
&nbsp;                }},
<b class="fc">&nbsp;                ListOrderedSet.listOrderedSet(Collections.singletonList(&quot;uid&quot;))</b>
&nbsp;        );
&nbsp;
<b class="fc">&nbsp;        EdgeLabel edgeLabel = this.sqlgGraph.getTopology().getPublicSchema().ensurePartitionedEdgeLabelExistOnInOrOutVertexLabel(</b>
&nbsp;                &quot;virtualGroup_RealWorkspaceElement&quot;,
&nbsp;                virtualGroupVertexLabel,
&nbsp;                realWorkspaceElementVertexLabel,
<b class="fc">&nbsp;                new LinkedHashMap&lt;&gt;() {{</b>
<b class="fc">&nbsp;                    put(&quot;uid&quot;, PropertyDefinition.of(PropertyType.STRING));</b>
&nbsp;                }},
<b class="fc">&nbsp;                ListOrderedSet.listOrderedSet(Collections.singletonList(&quot;uid&quot;)),</b>
&nbsp;                PartitionType.LIST,
&nbsp;                virtualGroupVertexLabel
&nbsp;        );
&nbsp;
&nbsp;
<b class="fc">&nbsp;        this.sqlgGraph.tx().commit();</b>
&nbsp;
<b class="fc">&nbsp;        Vertex v1 = this.sqlgGraph.addVertex(T.label, &quot;RealWorkspaceElement&quot;, &quot;cmUid&quot;, &quot;a&quot;, &quot;vendorTechnology&quot;, TEST.TEST1.name());</b>
<b class="fc">&nbsp;        Vertex v2 = this.sqlgGraph.addVertex(T.label, &quot;RealWorkspaceElement&quot;, &quot;cmUid&quot;, &quot;b&quot;, &quot;vendorTechnology&quot;, TEST.TEST2.name());</b>
<b class="fc">&nbsp;        Vertex v3 = this.sqlgGraph.addVertex(T.label, &quot;RealWorkspaceElement&quot;, &quot;cmUid&quot;, &quot;c&quot;, &quot;vendorTechnology&quot;, TEST.TEST3.name());</b>
<b class="fc">&nbsp;        Vertex v4 = this.sqlgGraph.addVertex(T.label, &quot;RealWorkspaceElement&quot;, &quot;cmUid&quot;, &quot;d&quot;, &quot;vendorTechnology&quot;, TEST.TEST1.name());</b>
<b class="fc">&nbsp;        this.sqlgGraph.tx().commit();</b>
&nbsp;
<b class="fc">&nbsp;        Vertex northern = this.sqlgGraph.addVertex(T.label, &quot;VirtualGroup&quot;, &quot;uid&quot;, UUID.randomUUID().toString(), &quot;name&quot;, &quot;Northern&quot;);</b>
<b class="fc">&nbsp;        Partition partition = edgeLabel.ensureListPartitionExists(</b>
&nbsp;                &quot;Northern&quot;,
<b class="fc">&nbsp;                &quot;&#39;&quot; + ((RecordId) northern.id()).getID().getIdentifiers().get(0).toString() + &quot;&#39;&quot;</b>
&nbsp;        );
<b class="fc">&nbsp;        Vertex western = this.sqlgGraph.addVertex(T.label, &quot;VirtualGroup&quot;, &quot;uid&quot;, UUID.randomUUID().toString(), &quot;name&quot;, &quot;Western&quot;);</b>
<b class="fc">&nbsp;        partition = edgeLabel.ensureListPartitionExists(</b>
&nbsp;                &quot;Western&quot;,
<b class="fc">&nbsp;                &quot;&#39;&quot; + ((RecordId) western.id()).getID().getIdentifiers().get(0).toString() + &quot;&#39;&quot;</b>
&nbsp;        );
<b class="fc">&nbsp;        Edge edgeFromNorthernToV1 = northern.addEdge(&quot;virtualGroup_RealWorkspaceElement&quot;, v1, &quot;uid&quot;, UUID.randomUUID().toString());</b>
<b class="fc">&nbsp;        Edge edgeFromWesternToV1 = western.addEdge(&quot;virtualGroup_RealWorkspaceElement&quot;, v1, &quot;uid&quot;, UUID.randomUUID().toString());</b>
<b class="fc">&nbsp;        Edge edgeFromNorthernToV4 = northern.addEdge(&quot;virtualGroup_RealWorkspaceElement&quot;, v4, &quot;uid&quot;, UUID.randomUUID().toString());</b>
<b class="fc">&nbsp;        this.sqlgGraph.tx().commit();</b>
&nbsp;
<b class="fc">&nbsp;        Assert.assertEquals(2, this.sqlgGraph.traversal().V().hasLabel(&quot;RealWorkspaceElement&quot;).has(&quot;vendorTechnology&quot;, TEST.TEST1.name()).count().next(), 0);</b>
<b class="fc">&nbsp;        Assert.assertEquals(1, this.sqlgGraph.traversal().V().hasLabel(&quot;RealWorkspaceElement&quot;).has(&quot;vendorTechnology&quot;, TEST.TEST2.name()).count().next(), 0);</b>
<b class="fc">&nbsp;        Assert.assertEquals(1, this.sqlgGraph.traversal().V().hasLabel(&quot;RealWorkspaceElement&quot;).has(&quot;vendorTechnology&quot;, TEST.TEST3.name()).count().next(), 0);</b>
<b class="fc">&nbsp;        Assert.assertEquals(4, this.sqlgGraph.traversal().V().hasLabel(&quot;RealWorkspaceElement&quot;).count().next(), 0);</b>
&nbsp;
<b class="fc">&nbsp;        List&lt;Vertex&gt; vertices = this.sqlgGraph.traversal().V(v4).in(&quot;virtualGroup_RealWorkspaceElement&quot;).toList();</b>
<b class="fc">&nbsp;        Assert.assertEquals(1, vertices.size());</b>
<b class="fc">&nbsp;        Assert.assertTrue(vertices.contains(northern));</b>
&nbsp;
<b class="fc">&nbsp;        vertices = this.sqlgGraph.traversal().V(v1).in(&quot;virtualGroup_RealWorkspaceElement&quot;).toList();</b>
<b class="fc">&nbsp;        Assert.assertEquals(2, vertices.size());</b>
<b class="fc">&nbsp;        Assert.assertTrue(vertices.contains(northern));</b>
<b class="fc">&nbsp;        Assert.assertTrue(vertices.contains(western));</b>
&nbsp;    }
&nbsp;
&nbsp;    @Test
&nbsp;    public void testPartitionEdgeOnForeignKey() {
<b class="fc">&nbsp;        LinkedHashMap&lt;String, PropertyDefinition&gt; attributeMap = new LinkedHashMap&lt;&gt;();</b>
<b class="fc">&nbsp;        attributeMap.put(&quot;name&quot;, PropertyDefinition.of(PropertyType.STRING));</b>
<b class="fc">&nbsp;        attributeMap.put(&quot;cmUid&quot;, PropertyDefinition.of(PropertyType.STRING));</b>
<b class="fc">&nbsp;        attributeMap.put(&quot;vendorTechnology&quot;, PropertyDefinition.of(PropertyType.STRING));</b>
&nbsp;
<b class="fc">&nbsp;        VertexLabel realWorkspaceElementVertexLabel = sqlgGraph.getTopology().getPublicSchema().ensurePartitionedVertexLabelExist(</b>
&nbsp;                &quot;RealWorkspaceElement&quot;,
&nbsp;                attributeMap,
<b class="fc">&nbsp;                ListOrderedSet.listOrderedSet(List.of(&quot;vendorTechnology&quot;, &quot;cmUid&quot;)),</b>
&nbsp;                PartitionType.LIST,
&nbsp;                &quot;\&quot;vendorTechnology\&quot;&quot;
&nbsp;        );
<b class="fc">&nbsp;        for (TEST test : TEST.values()) {</b>
<b class="fc">&nbsp;            Partition partition = realWorkspaceElementVertexLabel.ensureListPartitionExists(</b>
<b class="fc">&nbsp;                    test.name(),</b>
<b class="fc">&nbsp;                    &quot;&#39;&quot; + test.name() + &quot;&#39;&quot;</b>
&nbsp;            );
&nbsp;        }
<b class="fc">&nbsp;        PropertyColumn propertyColumn = realWorkspaceElementVertexLabel.getProperty(&quot;cmUid&quot;).orElseThrow(IllegalStateException::new);</b>
<b class="fc">&nbsp;        realWorkspaceElementVertexLabel.ensureIndexExists(IndexType.UNIQUE, Collections.singletonList(propertyColumn));</b>
&nbsp;
<b class="fc">&nbsp;        VertexLabel virtualGroupVertexLabel = sqlgGraph.getTopology().getPublicSchema().ensureVertexLabelExist(</b>
&nbsp;                &quot;VirtualGroup&quot;,
<b class="fc">&nbsp;                new LinkedHashMap&lt;&gt;() {{</b>
<b class="fc">&nbsp;                    put(&quot;name&quot;, PropertyDefinition.of(PropertyType.STRING));</b>
&nbsp;                }}
&nbsp;        );
&nbsp;
<b class="fc">&nbsp;        EdgeLabel edgeLabel = this.sqlgGraph.getTopology().getPublicSchema().ensurePartitionedEdgeLabelExistOnInOrOutVertexLabel(</b>
&nbsp;                &quot;virtualGroup_RealWorkspaceElement&quot;,
&nbsp;                virtualGroupVertexLabel,
&nbsp;                realWorkspaceElementVertexLabel,
<b class="fc">&nbsp;                new LinkedHashMap&lt;&gt;() {{</b>
<b class="fc">&nbsp;                    put(&quot;uid&quot;, PropertyDefinition.of(PropertyType.STRING));</b>
&nbsp;                }},
<b class="fc">&nbsp;                ListOrderedSet.listOrderedSet(Collections.singletonList(&quot;uid&quot;)),</b>
&nbsp;                PartitionType.LIST,
&nbsp;                virtualGroupVertexLabel
&nbsp;        );
&nbsp;
&nbsp;
<b class="fc">&nbsp;        this.sqlgGraph.tx().commit();</b>
&nbsp;
<b class="fc">&nbsp;        Vertex v1 = this.sqlgGraph.addVertex(T.label, &quot;RealWorkspaceElement&quot;, &quot;cmUid&quot;, &quot;a&quot;, &quot;vendorTechnology&quot;, TEST.TEST1.name());</b>
<b class="fc">&nbsp;        Vertex v2 = this.sqlgGraph.addVertex(T.label, &quot;RealWorkspaceElement&quot;, &quot;cmUid&quot;, &quot;b&quot;, &quot;vendorTechnology&quot;, TEST.TEST2.name());</b>
<b class="fc">&nbsp;        Vertex v3 = this.sqlgGraph.addVertex(T.label, &quot;RealWorkspaceElement&quot;, &quot;cmUid&quot;, &quot;c&quot;, &quot;vendorTechnology&quot;, TEST.TEST3.name());</b>
<b class="fc">&nbsp;        this.sqlgGraph.tx().commit();</b>
&nbsp;
<b class="fc">&nbsp;        Vertex northern = this.sqlgGraph.addVertex(T.label, &quot;VirtualGroup&quot;, &quot;name&quot;, &quot;Northern&quot;);</b>
<b class="fc">&nbsp;        Partition partition = edgeLabel.ensureListPartitionExists(</b>
&nbsp;                &quot;Northern&quot;,
<b class="fc">&nbsp;                ((RecordId) northern.id()).getID().getSequenceId().toString()</b>
&nbsp;        );
<b class="fc">&nbsp;        Vertex western = this.sqlgGraph.addVertex(T.label, &quot;VirtualGroup&quot;, &quot;name&quot;, &quot;Western&quot;);</b>
<b class="fc">&nbsp;        partition = edgeLabel.ensureListPartitionExists(</b>
&nbsp;                &quot;Western&quot;,
<b class="fc">&nbsp;                ((RecordId) western.id()).getID().getSequenceId().toString()</b>
&nbsp;        );
<b class="fc">&nbsp;        Edge e = northern.addEdge(&quot;virtualGroup_RealWorkspaceElement&quot;, v1, &quot;uid&quot;, UUID.randomUUID().toString());</b>
<b class="fc">&nbsp;        e.properties(&quot;what&quot;, &quot;this&quot;);</b>
<b class="fc">&nbsp;        e = western.addEdge(&quot;virtualGroup_RealWorkspaceElement&quot;, v1, &quot;uid&quot;, UUID.randomUUID().toString());</b>
<b class="fc">&nbsp;        e.properties(&quot;what&quot;, &quot;this&quot;);</b>
<b class="fc">&nbsp;        this.sqlgGraph.tx().commit();</b>
&nbsp;
<b class="fc">&nbsp;        Assert.assertEquals(1, this.sqlgGraph.traversal().V().hasLabel(&quot;RealWorkspaceElement&quot;).has(&quot;vendorTechnology&quot;, TEST.TEST1.name()).count().next(), 0);</b>
<b class="fc">&nbsp;        Assert.assertEquals(1, this.sqlgGraph.traversal().V().hasLabel(&quot;RealWorkspaceElement&quot;).has(&quot;vendorTechnology&quot;, TEST.TEST2.name()).count().next(), 0);</b>
<b class="fc">&nbsp;        Assert.assertEquals(1, this.sqlgGraph.traversal().V().hasLabel(&quot;RealWorkspaceElement&quot;).has(&quot;vendorTechnology&quot;, TEST.TEST3.name()).count().next(), 0);</b>
<b class="fc">&nbsp;        Assert.assertEquals(3, this.sqlgGraph.traversal().V().hasLabel(&quot;RealWorkspaceElement&quot;).count().next(), 0);</b>
&nbsp;
<b class="fc">&nbsp;        List&lt;Vertex&gt; vertices = this.sqlgGraph.traversal().V(v1).in(&quot;virtualGroup_RealWorkspaceElement&quot;).toList();</b>
<b class="fc">&nbsp;        Assert.assertEquals(2, vertices.size());</b>
<b class="fc">&nbsp;        Assert.assertEquals(northern, vertices.get(0));</b>
<b class="fc">&nbsp;        Assert.assertEquals(western, vertices.get(1));</b>
&nbsp;
<b class="fc">&nbsp;        vertices = this.sqlgGraph.traversal().V(northern).out(&quot;virtualGroup_RealWorkspaceElement&quot;).toList();</b>
<b class="fc">&nbsp;        Assert.assertEquals(1, vertices.size());</b>
<b class="fc">&nbsp;        Assert.assertEquals(v1, vertices.get(0));</b>
&nbsp;    }
&nbsp;
&nbsp;    @Test
&nbsp;    public void testUpdatePropertiesOnEdgeToPartitionedTable() {
<b class="fc">&nbsp;        LinkedHashMap&lt;String, PropertyDefinition&gt; attributeMap = new LinkedHashMap&lt;&gt;();</b>
<b class="fc">&nbsp;        attributeMap.put(&quot;name&quot;, PropertyDefinition.of(PropertyType.STRING));</b>
<b class="fc">&nbsp;        attributeMap.put(&quot;cmUid&quot;, PropertyDefinition.of(PropertyType.STRING));</b>
<b class="fc">&nbsp;        attributeMap.put(&quot;vendorTechnology&quot;, PropertyDefinition.of(PropertyType.STRING));</b>
&nbsp;
<b class="fc">&nbsp;        VertexLabel realWorkspaceElementVertexLabel = sqlgGraph.getTopology().getPublicSchema().ensurePartitionedVertexLabelExist(</b>
&nbsp;                &quot;RealWorkspaceElement&quot;,
&nbsp;                attributeMap,
<b class="fc">&nbsp;                ListOrderedSet.listOrderedSet(List.of(&quot;cmUid&quot;, &quot;vendorTechnology&quot;)),</b>
&nbsp;                PartitionType.LIST,
&nbsp;                &quot;\&quot;vendorTechnology\&quot;&quot;
&nbsp;        );
<b class="fc">&nbsp;        for (TEST test : TEST.values()) {</b>
<b class="fc">&nbsp;            Partition partition = realWorkspaceElementVertexLabel.ensureListPartitionExists(</b>
<b class="fc">&nbsp;                    test.name(),</b>
<b class="fc">&nbsp;                    &quot;&#39;&quot; + test.name() + &quot;&#39;&quot;</b>
&nbsp;            );
&nbsp;        }
<b class="fc">&nbsp;        PropertyColumn propertyColumn = realWorkspaceElementVertexLabel.getProperty(&quot;cmUid&quot;).orElseThrow(IllegalStateException::new);</b>
<b class="fc">&nbsp;        realWorkspaceElementVertexLabel.ensureIndexExists(IndexType.UNIQUE, Collections.singletonList(propertyColumn));</b>
<b class="fc">&nbsp;        this.sqlgGraph.tx().commit();</b>
&nbsp;
<b class="fc">&nbsp;        Vertex v1 = this.sqlgGraph.addVertex(T.label, &quot;RealWorkspaceElement&quot;, &quot;cmUid&quot;, &quot;a&quot;, &quot;vendorTechnology&quot;, TEST.TEST1.name());</b>
<b class="fc">&nbsp;        Vertex v2 = this.sqlgGraph.addVertex(T.label, &quot;RealWorkspaceElement&quot;, &quot;cmUid&quot;, &quot;b&quot;, &quot;vendorTechnology&quot;, TEST.TEST2.name());</b>
<b class="fc">&nbsp;        Vertex v3 = this.sqlgGraph.addVertex(T.label, &quot;RealWorkspaceElement&quot;, &quot;cmUid&quot;, &quot;c&quot;, &quot;vendorTechnology&quot;, TEST.TEST3.name());</b>
<b class="fc">&nbsp;        this.sqlgGraph.tx().commit();</b>
&nbsp;
<b class="fc">&nbsp;        Vertex other = this.sqlgGraph.addVertex(T.label, &quot;Other&quot;, &quot;name&quot;, &quot;other&quot;);</b>
<b class="fc">&nbsp;        Edge e = v1.addEdge(&quot;test&quot;, other);</b>
<b class="fc">&nbsp;        e.properties(&quot;what&quot;, &quot;this&quot;);</b>
<b class="fc">&nbsp;        this.sqlgGraph.tx().commit();</b>
&nbsp;
<b class="fc">&nbsp;        Assert.assertEquals(1, this.sqlgGraph.traversal().V().hasLabel(&quot;RealWorkspaceElement&quot;).has(&quot;vendorTechnology&quot;, TEST.TEST1.name()).count().next(), 0);</b>
<b class="fc">&nbsp;        Assert.assertEquals(1, this.sqlgGraph.traversal().V().hasLabel(&quot;RealWorkspaceElement&quot;).has(&quot;vendorTechnology&quot;, TEST.TEST2.name()).count().next(), 0);</b>
<b class="fc">&nbsp;        Assert.assertEquals(1, this.sqlgGraph.traversal().V().hasLabel(&quot;RealWorkspaceElement&quot;).has(&quot;vendorTechnology&quot;, TEST.TEST3.name()).count().next(), 0);</b>
<b class="fc">&nbsp;        Assert.assertEquals(3, this.sqlgGraph.traversal().V().hasLabel(&quot;RealWorkspaceElement&quot;).count().next(), 0);</b>
&nbsp;
<b class="fc">&nbsp;        List&lt;Vertex&gt; vertices = this.sqlgGraph.traversal().V(v1).out(&quot;test&quot;).toList();</b>
<b class="fc">&nbsp;        Assert.assertEquals(1, vertices.size());</b>
<b class="fc">&nbsp;        Assert.assertEquals(other, vertices.get(0));</b>
&nbsp;
&nbsp;
&nbsp;    }
&nbsp;
&nbsp;    @Test
&nbsp;    public void testPartitionOnColumnWithCapitals() {
<b class="fc">&nbsp;        LinkedHashMap&lt;String, PropertyDefinition&gt; attributeMap = new LinkedHashMap&lt;&gt;();</b>
<b class="fc">&nbsp;        attributeMap.put(&quot;name&quot;, PropertyDefinition.of(PropertyType.STRING));</b>
<b class="fc">&nbsp;        attributeMap.put(&quot;cmUid&quot;, PropertyDefinition.of(PropertyType.STRING));</b>
<b class="fc">&nbsp;        attributeMap.put(&quot;vendorTechnology&quot;, PropertyDefinition.of(PropertyType.STRING));</b>
&nbsp;
<b class="fc">&nbsp;        VertexLabel realWorkspaceElementVertexLabel = sqlgGraph.getTopology().getPublicSchema().ensurePartitionedVertexLabelExist(</b>
&nbsp;                &quot;RealWorkspaceElement&quot;,
&nbsp;                attributeMap,
<b class="fc">&nbsp;                ListOrderedSet.listOrderedSet(List.of(&quot;cmUid&quot;, &quot;vendorTechnology&quot;)),</b>
&nbsp;                PartitionType.LIST,
&nbsp;                &quot;\&quot;vendorTechnology\&quot;&quot;
&nbsp;        );
<b class="fc">&nbsp;        for (TEST test : TEST.values()) {</b>
<b class="fc">&nbsp;            Partition partition = realWorkspaceElementVertexLabel.ensureListPartitionExists(</b>
<b class="fc">&nbsp;                    test.name(),</b>
<b class="fc">&nbsp;                    &quot;&#39;&quot; + test.name() + &quot;&#39;&quot;</b>
&nbsp;            );
&nbsp;        }
<b class="fc">&nbsp;        PropertyColumn propertyColumn = realWorkspaceElementVertexLabel.getProperty(&quot;cmUid&quot;).orElseThrow(IllegalStateException::new);</b>
<b class="fc">&nbsp;        realWorkspaceElementVertexLabel.ensureIndexExists(IndexType.UNIQUE, Collections.singletonList(propertyColumn));</b>
<b class="fc">&nbsp;        sqlgGraph.tx().commit();</b>
<b class="fc">&nbsp;        sqlgGraph.addVertex(T.label, &quot;RealWorkspaceElement&quot;, &quot;cmUid&quot;, &quot;a&quot;, &quot;vendorTechnology&quot;, TEST.TEST1.name());</b>
<b class="fc">&nbsp;        sqlgGraph.addVertex(T.label, &quot;RealWorkspaceElement&quot;, &quot;cmUid&quot;, &quot;b&quot;, &quot;vendorTechnology&quot;, TEST.TEST2.name());</b>
<b class="fc">&nbsp;        sqlgGraph.addVertex(T.label, &quot;RealWorkspaceElement&quot;, &quot;cmUid&quot;, &quot;c&quot;, &quot;vendorTechnology&quot;, TEST.TEST3.name());</b>
<b class="fc">&nbsp;        sqlgGraph.tx().commit();</b>
&nbsp;
<b class="fc">&nbsp;        Assert.assertEquals(1, this.sqlgGraph.traversal().V().hasLabel(&quot;RealWorkspaceElement&quot;).has(&quot;vendorTechnology&quot;, TEST.TEST1.name()).count().next(), 0);</b>
<b class="fc">&nbsp;        Assert.assertEquals(1, this.sqlgGraph.traversal().V().hasLabel(&quot;RealWorkspaceElement&quot;).has(&quot;vendorTechnology&quot;, TEST.TEST2.name()).count().next(), 0);</b>
<b class="fc">&nbsp;        Assert.assertEquals(1, this.sqlgGraph.traversal().V().hasLabel(&quot;RealWorkspaceElement&quot;).has(&quot;vendorTechnology&quot;, TEST.TEST3.name()).count().next(), 0);</b>
<b class="fc">&nbsp;        Assert.assertEquals(3, this.sqlgGraph.traversal().V().hasLabel(&quot;RealWorkspaceElement&quot;).count().next(), 0);</b>
&nbsp;
&nbsp;    }
&nbsp;
&nbsp;    @Test
&nbsp;    public void testReloadVertexLabelWithNoPartitions() {
<b class="fc">&nbsp;        Schema publicSchema = this.sqlgGraph.getTopology().getPublicSchema();</b>
<b class="fc">&nbsp;        publicSchema.ensurePartitionedVertexLabelExist(</b>
&nbsp;                &quot;A&quot;,
<b class="fc">&nbsp;                new LinkedHashMap&lt;&gt;() {{</b>
<b class="fc">&nbsp;                    put(&quot;int1&quot;, PropertyDefinition.of(PropertyType.INTEGER));</b>
<b class="fc">&nbsp;                    put(&quot;int2&quot;, PropertyDefinition.of(PropertyType.INTEGER));</b>
<b class="fc">&nbsp;                    put(&quot;int3&quot;, PropertyDefinition.of(PropertyType.INTEGER));</b>
&nbsp;                }},
<b class="fc">&nbsp;                ListOrderedSet.listOrderedSet(List.of(&quot;int1&quot;, &quot;int2&quot;)),</b>
&nbsp;                PartitionType.RANGE,
&nbsp;                &quot;int1,int2&quot;);
<b class="fc">&nbsp;        this.sqlgGraph.tx().commit();</b>
&nbsp;
&nbsp;        //Delete the topology
<b class="fc">&nbsp;        dropSqlgSchema(this.sqlgGraph);</b>
&nbsp;
<b class="fc">&nbsp;        this.sqlgGraph.tx().commit();</b>
<b class="fc">&nbsp;        this.sqlgGraph.close();</b>
&nbsp;
<b class="fc">&nbsp;        try (SqlgGraph sqlgGraph1 = SqlgGraph.open(configuration)) {</b>
<b class="fc">&nbsp;            VertexLabel a = sqlgGraph1.getTopology().getPublicSchema().getVertexLabel(&quot;A&quot;).orElseThrow();</b>
<b class="fc">&nbsp;            Assert.assertEquals(&quot;int1,int2&quot;, a.getPartitionExpression());</b>
<b class="fc">&nbsp;            Assert.assertEquals(PartitionType.RANGE, a.getPartitionType());</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    @Test
&nbsp;    public void testReloadVertexLabelWithPartitions() {
<b class="fc">&nbsp;        Schema publicSchema = this.sqlgGraph.getTopology().getPublicSchema();</b>
<b class="fc">&nbsp;        VertexLabel a = publicSchema.ensurePartitionedVertexLabelExist(</b>
&nbsp;                &quot;A&quot;,
<b class="fc">&nbsp;                new LinkedHashMap&lt;&gt;() {{</b>
<b class="fc">&nbsp;                    put(&quot;int1&quot;, PropertyDefinition.of(PropertyType.INTEGER));</b>
<b class="fc">&nbsp;                    put(&quot;int2&quot;, PropertyDefinition.of(PropertyType.INTEGER));</b>
<b class="fc">&nbsp;                    put(&quot;int3&quot;, PropertyDefinition.of(PropertyType.INTEGER));</b>
&nbsp;                }},
<b class="fc">&nbsp;                ListOrderedSet.listOrderedSet(List.of(&quot;int1&quot;, &quot;int2&quot;)),</b>
&nbsp;                PartitionType.RANGE,
&nbsp;                &quot;int1,int2&quot;);
<b class="fc">&nbsp;        a.ensureRangePartitionExists(&quot;part1&quot;, &quot;1,1&quot;, &quot;5,5&quot;);</b>
<b class="fc">&nbsp;        a.ensureRangePartitionExists(&quot;part2&quot;, &quot;5,5&quot;, &quot;10,10&quot;);</b>
<b class="fc">&nbsp;        this.sqlgGraph.tx().commit();</b>
&nbsp;
&nbsp;        //Delete the topology
<b class="fc">&nbsp;        dropSqlgSchema(this.sqlgGraph);</b>
&nbsp;
<b class="fc">&nbsp;        this.sqlgGraph.tx().commit();</b>
<b class="fc">&nbsp;        this.sqlgGraph.close();</b>
&nbsp;
<b class="fc">&nbsp;        try (SqlgGraph sqlgGraph1 = SqlgGraph.open(configuration)) {</b>
<b class="fc">&nbsp;            a = sqlgGraph1.getTopology().getPublicSchema().getVertexLabel(&quot;A&quot;).orElseThrow();</b>
<b class="fc">&nbsp;            Assert.assertEquals(&quot;int1,int2&quot;, a.getPartitionExpression());</b>
<b class="fc">&nbsp;            Assert.assertEquals(PartitionType.RANGE, a.getPartitionType());</b>
&nbsp;
<b class="fc">&nbsp;            Optional&lt;Partition&gt; part1 = a.getPartition(&quot;part1&quot;);</b>
<b class="fc">&nbsp;            Assert.assertTrue(part1.isPresent());</b>
<b class="fc">&nbsp;            Assert.assertNull(part1.get().getPartitionExpression());</b>
<b class="fc">&nbsp;            Assert.assertEquals(&quot;1, 1&quot;, part1.get().getFrom());</b>
<b class="fc">&nbsp;            Assert.assertEquals(&quot;5, 5&quot;, part1.get().getTo());</b>
<b class="fc">&nbsp;            Optional&lt;Partition&gt; part2 = a.getPartition(&quot;part2&quot;);</b>
<b class="fc">&nbsp;            Assert.assertTrue(part2.isPresent());</b>
<b class="fc">&nbsp;            Assert.assertNull(part2.get().getPartitionExpression());</b>
<b class="fc">&nbsp;            Assert.assertEquals(&quot;5, 5&quot;, part2.get().getFrom());</b>
<b class="fc">&nbsp;            Assert.assertEquals(&quot;10, 10&quot;, part2.get().getTo());</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    @Test
&nbsp;    public void testReloadVertexLabelWithSubPartitions() {
<b class="fc">&nbsp;        Schema publicSchema = this.sqlgGraph.getTopology().getPublicSchema();</b>
<b class="fc">&nbsp;        VertexLabel a = publicSchema.ensurePartitionedVertexLabelExist(</b>
&nbsp;                &quot;A&quot;,
<b class="fc">&nbsp;                new LinkedHashMap&lt;&gt;() {{</b>
<b class="fc">&nbsp;                    put(&quot;int1&quot;, PropertyDefinition.of(PropertyType.INTEGER));</b>
<b class="fc">&nbsp;                    put(&quot;int2&quot;, PropertyDefinition.of(PropertyType.INTEGER));</b>
<b class="fc">&nbsp;                    put(&quot;int3&quot;, PropertyDefinition.of(PropertyType.INTEGER));</b>
&nbsp;                }},
<b class="fc">&nbsp;                ListOrderedSet.listOrderedSet(Arrays.asList(&quot;int1&quot;, &quot;int2&quot;, &quot;int3&quot;)),</b>
&nbsp;                PartitionType.RANGE,
&nbsp;                &quot;int1,int2&quot;);
<b class="fc">&nbsp;        Partition part1 = a.ensureRangePartitionWithSubPartitionExists(&quot;part1&quot;, &quot;1,1&quot;, &quot;5,5&quot;, PartitionType.RANGE, &quot;int3&quot;);</b>
<b class="fc">&nbsp;        Partition part2 = a.ensureRangePartitionWithSubPartitionExists(&quot;part2&quot;, &quot;5,5&quot;, &quot;10,10&quot;, PartitionType.RANGE, &quot;int3&quot;);</b>
&nbsp;
<b class="fc">&nbsp;        part1.ensureRangePartitionExists(&quot;part11&quot;, &quot;1&quot;, &quot;5&quot;);</b>
<b class="fc">&nbsp;        part2.ensureRangePartitionExists(&quot;part21&quot;, &quot;1&quot;, &quot;5&quot;);</b>
&nbsp;
<b class="fc">&nbsp;        this.sqlgGraph.tx().commit();</b>
&nbsp;
&nbsp;        //Delete the topology
<b class="fc">&nbsp;        dropSqlgSchema(this.sqlgGraph);</b>
&nbsp;
<b class="fc">&nbsp;        this.sqlgGraph.tx().commit();</b>
<b class="fc">&nbsp;        this.sqlgGraph.close();</b>
&nbsp;
<b class="fc">&nbsp;        try (SqlgGraph sqlgGraph1 = SqlgGraph.open(configuration)) {</b>
<b class="fc">&nbsp;            a = sqlgGraph1.getTopology().getPublicSchema().getVertexLabel(&quot;A&quot;).orElseThrow();</b>
<b class="fc">&nbsp;            Assert.assertEquals(&quot;int1,int2&quot;, a.getPartitionExpression());</b>
<b class="fc">&nbsp;            Assert.assertEquals(PartitionType.RANGE, a.getPartitionType());</b>
&nbsp;
<b class="fc">&nbsp;            Optional&lt;Partition&gt; p1 = a.getPartition(&quot;part1&quot;);</b>
<b class="fc">&nbsp;            Assert.assertTrue(p1.isPresent());</b>
<b class="fc">&nbsp;            Assert.assertEquals(&quot;int3&quot;, p1.get().getPartitionExpression());</b>
<b class="fc">&nbsp;            Assert.assertEquals(PartitionType.RANGE, p1.get().getPartitionType());</b>
<b class="fc">&nbsp;            Assert.assertEquals(&quot;1, 1&quot;, p1.get().getFrom());</b>
<b class="fc">&nbsp;            Assert.assertEquals(&quot;5, 5&quot;, p1.get().getTo());</b>
&nbsp;
<b class="fc">&nbsp;            Optional&lt;Partition&gt; p11 = p1.get().getPartition(&quot;part11&quot;);</b>
<b class="fc">&nbsp;            Assert.assertTrue(p11.isPresent());</b>
<b class="fc">&nbsp;            Assert.assertNull(p11.get().getPartitionExpression());</b>
<b class="fc">&nbsp;            Assert.assertEquals(PartitionType.NONE, p11.get().getPartitionType());</b>
<b class="fc">&nbsp;            Assert.assertEquals(&quot;1&quot;, p11.get().getFrom());</b>
<b class="fc">&nbsp;            Assert.assertEquals(&quot;5&quot;, p11.get().getTo());</b>
&nbsp;
<b class="fc">&nbsp;            Optional&lt;Partition&gt; p2 = a.getPartition(&quot;part2&quot;);</b>
<b class="fc">&nbsp;            Assert.assertTrue(p2.isPresent());</b>
<b class="fc">&nbsp;            Assert.assertEquals(&quot;int3&quot;, p2.get().getPartitionExpression());</b>
<b class="fc">&nbsp;            Assert.assertEquals(PartitionType.RANGE, p2.get().getPartitionType());</b>
<b class="fc">&nbsp;            Assert.assertEquals(&quot;5, 5&quot;, p2.get().getFrom());</b>
<b class="fc">&nbsp;            Assert.assertEquals(&quot;10, 10&quot;, p2.get().getTo());</b>
&nbsp;
<b class="fc">&nbsp;            Optional&lt;Partition&gt; p21 = p2.get().getPartition(&quot;part21&quot;);</b>
<b class="fc">&nbsp;            Assert.assertTrue(p21.isPresent());</b>
<b class="fc">&nbsp;            Assert.assertNull(p21.get().getPartitionExpression());</b>
<b class="fc">&nbsp;            Assert.assertEquals(PartitionType.NONE, p21.get().getPartitionType());</b>
<b class="fc">&nbsp;            Assert.assertEquals(&quot;1&quot;, p21.get().getFrom());</b>
<b class="fc">&nbsp;            Assert.assertEquals(&quot;5&quot;, p21.get().getTo());</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    @Test
&nbsp;    public void testReloadEdgeLabelWithNoPartitions() {
<b class="fc">&nbsp;        Schema publicSchema = this.sqlgGraph.getTopology().getPublicSchema();</b>
<b class="fc">&nbsp;        VertexLabel a = publicSchema.ensureVertexLabelExist(</b>
&nbsp;                &quot;A&quot;,
<b class="fc">&nbsp;                Collections.emptyMap()</b>
&nbsp;        );
<b class="fc">&nbsp;        VertexLabel b = publicSchema.ensureVertexLabelExist(</b>
&nbsp;                &quot;B&quot;,
<b class="fc">&nbsp;                Collections.emptyMap()</b>
&nbsp;        );
<b class="fc">&nbsp;        a.ensurePartitionedEdgeLabelExist(</b>
&nbsp;                &quot;ab&quot;,
&nbsp;                b,
<b class="fc">&nbsp;                new LinkedHashMap&lt;&gt;() {{</b>
<b class="fc">&nbsp;                    put(&quot;int1&quot;, PropertyDefinition.of(PropertyType.INTEGER));</b>
<b class="fc">&nbsp;                    put(&quot;int2&quot;, PropertyDefinition.of(PropertyType.INTEGER));</b>
<b class="fc">&nbsp;                    put(&quot;int3&quot;, PropertyDefinition.of(PropertyType.INTEGER));</b>
&nbsp;                }},
<b class="fc">&nbsp;                ListOrderedSet.listOrderedSet(Arrays.asList(&quot;int1&quot;, &quot;int2&quot;)),</b>
&nbsp;                PartitionType.RANGE,
&nbsp;                &quot;int1,int2&quot;
&nbsp;        );
<b class="fc">&nbsp;        this.sqlgGraph.tx().commit();</b>
&nbsp;
&nbsp;        //Delete the topology
<b class="fc">&nbsp;        dropSqlgSchema(this.sqlgGraph);</b>
&nbsp;
<b class="fc">&nbsp;        this.sqlgGraph.tx().commit();</b>
<b class="fc">&nbsp;        this.sqlgGraph.close();</b>
&nbsp;
<b class="fc">&nbsp;        try (SqlgGraph sqlgGraph1 = SqlgGraph.open(configuration)) {</b>
<b class="fc">&nbsp;            EdgeLabel edgeLabel = sqlgGraph1.getTopology()</b>
<b class="fc">&nbsp;                    .getPublicSchema()</b>
<b class="fc">&nbsp;                    .getEdgeLabel(&quot;ab&quot;).orElseThrow();</b>
<b class="fc">&nbsp;            Assert.assertEquals(&quot;int1,int2&quot;, edgeLabel.getPartitionExpression());</b>
<b class="fc">&nbsp;            Assert.assertEquals(PartitionType.RANGE, edgeLabel.getPartitionType());</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    @Test
&nbsp;    public void testReloadEdgeLabelWithPartitions() {
<b class="fc">&nbsp;        Schema publicSchema = this.sqlgGraph.getTopology().getPublicSchema();</b>
<b class="fc">&nbsp;        VertexLabel a = publicSchema.ensureVertexLabelExist(</b>
&nbsp;                &quot;A&quot;,
<b class="fc">&nbsp;                Collections.emptyMap()</b>
&nbsp;        );
<b class="fc">&nbsp;        VertexLabel b = publicSchema.ensureVertexLabelExist(</b>
&nbsp;                &quot;B&quot;,
<b class="fc">&nbsp;                Collections.emptyMap()</b>
&nbsp;        );
<b class="fc">&nbsp;        EdgeLabel ab = a.ensurePartitionedEdgeLabelExist(</b>
&nbsp;                &quot;ab&quot;,
&nbsp;                b,
<b class="fc">&nbsp;                new LinkedHashMap&lt;&gt;() {{</b>
<b class="fc">&nbsp;                    put(&quot;int1&quot;, PropertyDefinition.of(PropertyType.INTEGER));</b>
<b class="fc">&nbsp;                    put(&quot;int2&quot;, PropertyDefinition.of(PropertyType.INTEGER));</b>
<b class="fc">&nbsp;                    put(&quot;int3&quot;, PropertyDefinition.of(PropertyType.INTEGER));</b>
&nbsp;                }},
<b class="fc">&nbsp;                ListOrderedSet.listOrderedSet(Arrays.asList(&quot;int1&quot;, &quot;int2&quot;)),</b>
&nbsp;                PartitionType.LIST,
&nbsp;                &quot;int1&quot;
&nbsp;        );
<b class="fc">&nbsp;        Partition p1 = ab.ensureListPartitionExists(&quot;int1&quot;, &quot;1,2,3,4,5&quot;);</b>
<b class="fc">&nbsp;        Partition p2 = ab.ensureListPartitionExists(&quot;int2&quot;, &quot;6,7,8,9,10&quot;);</b>
&nbsp;
<b class="fc">&nbsp;        this.sqlgGraph.tx().commit();</b>
&nbsp;
&nbsp;        //Delete the topology
<b class="fc">&nbsp;        dropSqlgSchema(this.sqlgGraph);</b>
&nbsp;
<b class="fc">&nbsp;        this.sqlgGraph.tx().commit();</b>
<b class="fc">&nbsp;        this.sqlgGraph.close();</b>
&nbsp;
<b class="fc">&nbsp;        try (SqlgGraph sqlgGraph1 = SqlgGraph.open(configuration)) {</b>
<b class="fc">&nbsp;            EdgeLabel edgeLabel = sqlgGraph1.getTopology()</b>
<b class="fc">&nbsp;                    .getPublicSchema()</b>
<b class="fc">&nbsp;                    .getEdgeLabel(&quot;ab&quot;).orElseThrow();</b>
<b class="fc">&nbsp;            Assert.assertEquals(&quot;int1&quot;, edgeLabel.getPartitionExpression());</b>
<b class="fc">&nbsp;            Assert.assertEquals(PartitionType.LIST, edgeLabel.getPartitionType());</b>
&nbsp;
<b class="fc">&nbsp;            Assert.assertEquals(2, edgeLabel.getPartitions().size());</b>
<b class="fc">&nbsp;            Assert.assertTrue(edgeLabel.getPartitions().containsKey(&quot;int1&quot;));</b>
<b class="fc">&nbsp;            Assert.assertTrue(edgeLabel.getPartitions().containsKey(&quot;int2&quot;));</b>
&nbsp;
<b class="fc">&nbsp;            p1 = edgeLabel.getPartition(&quot;int1&quot;).orElseThrow();</b>
<b class="fc">&nbsp;            Assert.assertEquals(PartitionType.NONE, p1.getPartitionType());</b>
<b class="fc">&nbsp;            Assert.assertEquals(&quot;1, 2, 3, 4, 5&quot;, p1.getIn());</b>
<b class="fc">&nbsp;            p2 = edgeLabel.getPartition(&quot;int2&quot;).orElseThrow();</b>
<b class="fc">&nbsp;            Assert.assertEquals(PartitionType.NONE, p2.getPartitionType());</b>
<b class="fc">&nbsp;            Assert.assertEquals(&quot;6, 7, 8, 9, 10&quot;, p2.getIn());</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    @Test
&nbsp;    public void testReloadEdgeLabelWithSubPartitions() {
<b class="fc">&nbsp;        Schema publicSchema = this.sqlgGraph.getTopology().getPublicSchema();</b>
<b class="fc">&nbsp;        VertexLabel a = publicSchema.ensureVertexLabelExist(</b>
&nbsp;                &quot;A&quot;,
<b class="fc">&nbsp;                Collections.emptyMap()</b>
&nbsp;        );
<b class="fc">&nbsp;        VertexLabel b = publicSchema.ensureVertexLabelExist(</b>
&nbsp;                &quot;B&quot;,
<b class="fc">&nbsp;                Collections.emptyMap()</b>
&nbsp;        );
<b class="fc">&nbsp;        EdgeLabel ab = a.ensurePartitionedEdgeLabelExist(</b>
&nbsp;                &quot;ab&quot;,
&nbsp;                b,
<b class="fc">&nbsp;                new LinkedHashMap&lt;&gt;() {{</b>
<b class="fc">&nbsp;                    put(&quot;int1&quot;, PropertyDefinition.of(PropertyType.INTEGER));</b>
<b class="fc">&nbsp;                    put(&quot;int2&quot;, PropertyDefinition.of(PropertyType.INTEGER));</b>
<b class="fc">&nbsp;                    put(&quot;int3&quot;, PropertyDefinition.of(PropertyType.INTEGER));</b>
&nbsp;                }},
<b class="fc">&nbsp;                ListOrderedSet.listOrderedSet(Arrays.asList(&quot;int1&quot;, &quot;int2&quot;, &quot;int3&quot;)),</b>
&nbsp;                PartitionType.LIST,
&nbsp;                &quot;int1&quot;
&nbsp;        );
<b class="fc">&nbsp;        Partition p1 = ab.ensureListPartitionWithSubPartitionExists(&quot;p11&quot;, &quot;1,2,3,4,5&quot;, PartitionType.RANGE, &quot;int2&quot;);</b>
<b class="fc">&nbsp;        Partition p111 = p1.ensureRangePartitionWithSubPartitionExists(&quot;p111&quot;, &quot;1&quot;, &quot;5&quot;, PartitionType.LIST, &quot;int3&quot;);</b>
<b class="fc">&nbsp;        p111.ensureListPartitionExists(&quot;p1111&quot;, &quot;1,2,3,4,5&quot;);</b>
<b class="fc">&nbsp;        Partition p2 = ab.ensureListPartitionWithSubPartitionExists(&quot;p12&quot;, &quot;6,7,8,9,10&quot;, PartitionType.RANGE, &quot;int2&quot;);</b>
<b class="fc">&nbsp;        Partition p121 = p2.ensureRangePartitionWithSubPartitionExists(&quot;p121&quot;, &quot;1&quot;, &quot;5&quot;, PartitionType.LIST, &quot;int3&quot;);</b>
<b class="fc">&nbsp;        p121.ensureListPartitionExists(&quot;p1211&quot;, &quot;1,2,3,4,10&quot;);</b>
&nbsp;
<b class="fc">&nbsp;        this.sqlgGraph.tx().commit();</b>
&nbsp;
&nbsp;        //Delete the topology
<b class="fc">&nbsp;        dropSqlgSchema(this.sqlgGraph);</b>
&nbsp;
<b class="fc">&nbsp;        this.sqlgGraph.tx().commit();</b>
<b class="fc">&nbsp;        this.sqlgGraph.close();</b>
&nbsp;
<b class="fc">&nbsp;        try (SqlgGraph sqlgGraph1 = SqlgGraph.open(configuration)) {</b>
<b class="fc">&nbsp;            EdgeLabel edgeLabel = sqlgGraph1.getTopology()</b>
<b class="fc">&nbsp;                    .getPublicSchema()</b>
<b class="fc">&nbsp;                    .getEdgeLabel(&quot;ab&quot;).orElseThrow();</b>
<b class="fc">&nbsp;            Assert.assertEquals(&quot;int1&quot;, edgeLabel.getPartitionExpression());</b>
<b class="fc">&nbsp;            Assert.assertEquals(PartitionType.LIST, edgeLabel.getPartitionType());</b>
&nbsp;
<b class="fc">&nbsp;            Assert.assertEquals(2, edgeLabel.getPartitions().size());</b>
<b class="fc">&nbsp;            Assert.assertTrue(edgeLabel.getPartitions().containsKey(&quot;p11&quot;));</b>
<b class="fc">&nbsp;            Assert.assertTrue(edgeLabel.getPartitions().containsKey(&quot;p12&quot;));</b>
&nbsp;
<b class="fc">&nbsp;            p1 = edgeLabel.getPartition(&quot;p11&quot;).orElseThrow();</b>
<b class="fc">&nbsp;            Assert.assertEquals(PartitionType.RANGE, p1.getPartitionType());</b>
<b class="fc">&nbsp;            Assert.assertEquals(&quot;1, 2, 3, 4, 5&quot;, p1.getIn());</b>
<b class="fc">&nbsp;            Assert.assertEquals(1, p1.getPartitions().size());</b>
<b class="fc">&nbsp;            Assert.assertTrue(p1.getPartitions().containsKey(&quot;p111&quot;));</b>
<b class="fc">&nbsp;            p111 = p1.getPartitions().get(&quot;p111&quot;);</b>
<b class="fc">&nbsp;            Assert.assertEquals(PartitionType.LIST, p111.getPartitionType());</b>
<b class="fc">&nbsp;            Assert.assertEquals(&quot;int3&quot;, p111.getPartitionExpression());</b>
<b class="fc">&nbsp;            Assert.assertEquals(&quot;1&quot;, p111.getFrom());</b>
<b class="fc">&nbsp;            Assert.assertEquals(&quot;5&quot;, p111.getTo());</b>
<b class="fc">&nbsp;            Assert.assertTrue(p111.getPartition(&quot;p1111&quot;).isPresent());</b>
<b class="fc">&nbsp;            Partition p1111 = p111.getPartition(&quot;p1111&quot;).get();</b>
<b class="fc">&nbsp;            Assert.assertTrue(p1111.getPartitionType().isNone());</b>
<b class="fc">&nbsp;            Assert.assertNull(p1111.getPartitionExpression());</b>
<b class="fc">&nbsp;            Assert.assertEquals(&quot;1, 2, 3, 4, 5&quot;, p1111.getIn());</b>
&nbsp;
&nbsp;
<b class="fc">&nbsp;            p2 = edgeLabel.getPartition(&quot;p12&quot;).orElseThrow();</b>
<b class="fc">&nbsp;            Assert.assertEquals(PartitionType.RANGE, p2.getPartitionType());</b>
<b class="fc">&nbsp;            Assert.assertEquals(&quot;6, 7, 8, 9, 10&quot;, p2.getIn());</b>
<b class="fc">&nbsp;            Assert.assertEquals(1, p2.getPartitions().size());</b>
<b class="fc">&nbsp;            Assert.assertTrue(p2.getPartitions().containsKey(&quot;p121&quot;));</b>
<b class="fc">&nbsp;            p121 = p2.getPartitions().get(&quot;p121&quot;);</b>
<b class="fc">&nbsp;            Assert.assertEquals(PartitionType.LIST, p121.getPartitionType());</b>
<b class="fc">&nbsp;            Assert.assertEquals(&quot;int3&quot;, p121.getPartitionExpression());</b>
<b class="fc">&nbsp;            Assert.assertEquals(&quot;1&quot;, p121.getFrom());</b>
<b class="fc">&nbsp;            Assert.assertEquals(&quot;5&quot;, p121.getTo());</b>
<b class="fc">&nbsp;            Assert.assertTrue(p121.getPartition(&quot;p1211&quot;).isPresent());</b>
<b class="fc">&nbsp;            Partition p1211 = p121.getPartition(&quot;p1211&quot;).orElseThrow();</b>
<b class="fc">&nbsp;            Assert.assertTrue(p1211.getPartitionType().isNone());</b>
<b class="fc">&nbsp;            Assert.assertNull(p1211.getPartitionExpression());</b>
<b class="fc">&nbsp;            Assert.assertEquals(&quot;1, 2, 3, 4, 10&quot;, p1211.getIn());</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    @Test
&nbsp;    public void testPartitioningRange() {
<b class="fc">&nbsp;        Schema publicSchema = this.sqlgGraph.getTopology().getPublicSchema();</b>
<b class="fc">&nbsp;        VertexLabel partitionedVertexLabel = publicSchema.ensurePartitionedVertexLabelExist(</b>
&nbsp;                &quot;Measurement&quot;,
<b class="fc">&nbsp;                new LinkedHashMap&lt;&gt;() {{</b>
<b class="fc">&nbsp;                    put(&quot;date&quot;, PropertyDefinition.of(PropertyType.LOCALDATE));</b>
<b class="fc">&nbsp;                    put(&quot;temp&quot;, PropertyDefinition.of(PropertyType.INTEGER));</b>
&nbsp;                }},
<b class="fc">&nbsp;                ListOrderedSet.listOrderedSet(Collections.singletonList(&quot;date&quot;)),</b>
&nbsp;                PartitionType.RANGE,
&nbsp;                &quot;date&quot;);
<b class="fc">&nbsp;        partitionedVertexLabel.ensureRangePartitionExists(&quot;measurement1&quot;, &quot;&#39;2016-07-01&#39;&quot;, &quot;&#39;2016-08-01&#39;&quot;);</b>
<b class="fc">&nbsp;        partitionedVertexLabel.ensureRangePartitionExists(&quot;measurement2&quot;, &quot;&#39;2016-08-01&#39;&quot;, &quot;&#39;2016-09-01&#39;&quot;);</b>
<b class="fc">&nbsp;        this.sqlgGraph.tx().commit();</b>
&nbsp;
<b class="fc">&nbsp;        LocalDate localDate1 = LocalDate.of(2016, 7, 1);</b>
<b class="fc">&nbsp;        this.sqlgGraph.addVertex(T.label, &quot;Measurement&quot;, &quot;date&quot;, localDate1);</b>
<b class="fc">&nbsp;        LocalDate localDate2 = LocalDate.of(2016, 8, 1);</b>
<b class="fc">&nbsp;        this.sqlgGraph.addVertex(T.label, &quot;Measurement&quot;, &quot;date&quot;, localDate2);</b>
<b class="fc">&nbsp;        this.sqlgGraph.tx().commit();</b>
&nbsp;
<b class="fc">&nbsp;        Assert.assertEquals(2, this.sqlgGraph.traversal().V().hasLabel(&quot;Measurement&quot;).count().next(), 0);</b>
<b class="fc">&nbsp;        Assert.assertEquals(1, this.sqlgGraph.traversal().V().hasLabel(&quot;Measurement&quot;).has(&quot;date&quot;, localDate1).count().next(), 0);</b>
<b class="fc">&nbsp;        Assert.assertEquals(1, this.sqlgGraph.traversal().V().hasLabel(&quot;Measurement&quot;).has(&quot;date&quot;, localDate2).count().next(), 0);</b>
&nbsp;
<b class="fc">&nbsp;        Partition partition = this.sqlgGraph.getTopology().getPublicSchema().getVertexLabel(&quot;Measurement&quot;).orElseThrow().getPartition(&quot;measurement1&quot;).orElseThrow();</b>
<b class="fc">&nbsp;        partition.remove();</b>
<b class="fc">&nbsp;        this.sqlgGraph.tx().commit();</b>
&nbsp;
<b class="fc">&nbsp;        Assert.assertEquals(1, this.sqlgGraph.traversal().V().hasLabel(&quot;Measurement&quot;).count().next(), 0);</b>
<b class="fc">&nbsp;        Assert.assertEquals(0, this.sqlgGraph.traversal().V().hasLabel(&quot;Measurement&quot;).has(&quot;date&quot;, localDate1).count().next(), 0);</b>
<b class="fc">&nbsp;        Assert.assertEquals(1, this.sqlgGraph.traversal().V().hasLabel(&quot;Measurement&quot;).has(&quot;date&quot;, localDate2).count().next(), 0);</b>
&nbsp;
<b class="fc">&nbsp;        Assert.assertEquals(1, this.sqlgGraph.topology().V().hasLabel(Topology.SQLG_SCHEMA + &quot;.&quot; + Topology.SQLG_SCHEMA_PARTITION).count().next(), 0);</b>
&nbsp;    }
&nbsp;
&nbsp;    //the partitionExpression &#39;left(lower(name), 1)&#39; is to complex for the query planner to optimize.
&nbsp;    //i.e. select * from Cities where name = &#39;asdasd&#39; willscan all partitions.
&nbsp;    @Test
&nbsp;    public void testPartitioningList() {
<b class="fc">&nbsp;        Schema publicSchema = this.sqlgGraph.getTopology().getPublicSchema();</b>
<b class="fc">&nbsp;        VertexLabel partitionedVertexLabel = publicSchema.ensurePartitionedVertexLabelExist(&quot;Cities&quot;,</b>
<b class="fc">&nbsp;                new LinkedHashMap&lt;&gt;() {{</b>
<b class="fc">&nbsp;                    put(&quot;name&quot;, PropertyDefinition.of(PropertyType.STRING));</b>
<b class="fc">&nbsp;                    put(&quot;population&quot;, PropertyDefinition.of(PropertyType.LONG));</b>
&nbsp;                }},
<b class="fc">&nbsp;                ListOrderedSet.listOrderedSet(List.of(&quot;name&quot;)),</b>
&nbsp;                PartitionType.LIST,
&nbsp;                &quot;left(lower(name), 1)&quot;,
&nbsp;                false);
<b class="fc">&nbsp;        partitionedVertexLabel.ensureListPartitionExists(&quot;Cities_a&quot;, &quot;&#39;a&#39;&quot;);</b>
<b class="fc">&nbsp;        partitionedVertexLabel.ensureListPartitionExists(&quot;Cities_b&quot;, &quot;&#39;b&#39;&quot;);</b>
<b class="fc">&nbsp;        partitionedVertexLabel.ensureListPartitionExists(&quot;Cities_c&quot;, &quot;&#39;c&#39;&quot;);</b>
<b class="fc">&nbsp;        partitionedVertexLabel.ensureListPartitionExists(&quot;Cities_d&quot;, &quot;&#39;d&#39;&quot;);</b>
<b class="fc">&nbsp;        this.sqlgGraph.tx().commit();</b>
&nbsp;
<b class="fc">&nbsp;        this.sqlgGraph.tx().normalBatchModeOn();</b>
<b class="fc">&nbsp;        for (int i = 0; i &lt; 100; i++) {</b>
<b class="fc">&nbsp;            this.sqlgGraph.addVertex(T.label, &quot;Cities&quot;, &quot;name&quot;, &quot;aasbc&quot;, &quot;population&quot;, 1000L, &quot;uid&quot;, i);</b>
&nbsp;        }
<b class="fc">&nbsp;        this.sqlgGraph.addVertex(T.label, &quot;Cities&quot;, &quot;name&quot;, &quot;basbc&quot;, &quot;population&quot;, 1000L, &quot;uid&quot;, 1);</b>
<b class="fc">&nbsp;        for (int i = 0; i &lt; 100; i++) {</b>
<b class="fc">&nbsp;            this.sqlgGraph.addVertex(T.label, &quot;Cities&quot;, &quot;name&quot;, &quot;casbc&quot;, &quot;population&quot;, 1000L, &quot;uid&quot;, i);</b>
&nbsp;        }
<b class="fc">&nbsp;        this.sqlgGraph.addVertex(T.label, &quot;Cities&quot;, &quot;name&quot;, &quot;dasbc&quot;, &quot;population&quot;, 1000L, &quot;uid&quot;, 1);</b>
<b class="fc">&nbsp;        this.sqlgGraph.tx().commit();</b>
&nbsp;
<b class="fc">&nbsp;        Assert.assertEquals(202, this.sqlgGraph.traversal().V().hasLabel(&quot;Cities&quot;).count().next(), 0);</b>
<b class="fc">&nbsp;        Assert.assertEquals(100, this.sqlgGraph.traversal().V().hasLabel(&quot;Cities&quot;).has(&quot;name&quot;, &quot;aasbc&quot;).count().next(), 0);</b>
<b class="fc">&nbsp;        Assert.assertEquals(1, this.sqlgGraph.traversal().V().hasLabel(&quot;Cities&quot;).has(&quot;name&quot;, &quot;basbc&quot;).count().next(), 0);</b>
<b class="fc">&nbsp;        Assert.assertEquals(100, this.sqlgGraph.traversal().V().hasLabel(&quot;Cities&quot;).has(&quot;name&quot;, &quot;casbc&quot;).count().next(), 0);</b>
&nbsp;
<b class="fc">&nbsp;        Partition partition = this.sqlgGraph.getTopology().getPublicSchema().getVertexLabel(&quot;Cities&quot;).orElseThrow().getPartition(&quot;Cities_a&quot;).orElseThrow();</b>
<b class="fc">&nbsp;        partition.remove();</b>
<b class="fc">&nbsp;        this.sqlgGraph.tx().commit();</b>
&nbsp;
<b class="fc">&nbsp;        Assert.assertEquals(102, this.sqlgGraph.traversal().V().hasLabel(&quot;Cities&quot;).count().next(), 0);</b>
<b class="fc">&nbsp;        Assert.assertEquals(3, this.sqlgGraph.topology().V().hasLabel(Topology.SQLG_SCHEMA + &quot;.&quot; + Topology.SQLG_SCHEMA_PARTITION).count().next(), 0);</b>
&nbsp;    }
&nbsp;
&nbsp;    //partitionExpression is simple enough for the query planner to optimize the queries.
&nbsp;    @Test
&nbsp;    public void testPartitioningListSimple() {
<b class="fc">&nbsp;        Schema publicSchema = this.sqlgGraph.getTopology().getPublicSchema();</b>
<b class="fc">&nbsp;        VertexLabel partitionedVertexLabel = publicSchema.ensurePartitionedVertexLabelExist(&quot;Cities&quot;,</b>
<b class="fc">&nbsp;                new LinkedHashMap&lt;&gt;() {{</b>
<b class="fc">&nbsp;                    put(&quot;name&quot;, PropertyDefinition.of(PropertyType.STRING));</b>
<b class="fc">&nbsp;                    put(&quot;uid&quot;, PropertyDefinition.of(PropertyType.STRING));</b>
<b class="fc">&nbsp;                    put(&quot;population&quot;, PropertyDefinition.of(PropertyType.LONG));</b>
&nbsp;                }},
<b class="fc">&nbsp;                ListOrderedSet.listOrderedSet(List.of(&quot;name&quot;, &quot;uid&quot;)),</b>
&nbsp;                PartitionType.LIST,
&nbsp;                &quot;name&quot;);
<b class="fc">&nbsp;        partitionedVertexLabel.ensureListPartitionExists(&quot;Cities_a&quot;, &quot;&#39;London&#39;&quot;);</b>
<b class="fc">&nbsp;        partitionedVertexLabel.ensureListPartitionExists(&quot;Cities_b&quot;, &quot;&#39;New York&#39;&quot;);</b>
<b class="fc">&nbsp;        partitionedVertexLabel.ensureListPartitionExists(&quot;Cities_c&quot;, &quot;&#39;Paris&#39;&quot;);</b>
<b class="fc">&nbsp;        partitionedVertexLabel.ensureListPartitionExists(&quot;Cities_d&quot;, &quot;&#39;Johannesburg&#39;&quot;);</b>
<b class="fc">&nbsp;        this.sqlgGraph.tx().commit();</b>
&nbsp;
<b class="fc">&nbsp;        this.sqlgGraph.tx().normalBatchModeOn();</b>
<b class="fc">&nbsp;        for (int i = 0; i &lt; 100; i++) {</b>
<b class="fc">&nbsp;            this.sqlgGraph.addVertex(T.label, &quot;Cities&quot;, &quot;name&quot;, &quot;London&quot;, &quot;population&quot;, 1000L, &quot;uid&quot;, &quot;uid_London_&quot; + i);</b>
&nbsp;        }
<b class="fc">&nbsp;        this.sqlgGraph.addVertex(T.label, &quot;Cities&quot;, &quot;name&quot;, &quot;New York&quot;, &quot;population&quot;, 1000L, &quot;uid&quot;, &quot;uid_NewYork_1&quot;);</b>
<b class="fc">&nbsp;        for (int i = 0; i &lt; 100; i++) {</b>
<b class="fc">&nbsp;            this.sqlgGraph.addVertex(T.label, &quot;Cities&quot;, &quot;name&quot;, &quot;Paris&quot;, &quot;population&quot;, 1000L, &quot;uid&quot;, &quot;uid_Paris_&quot; + i);</b>
&nbsp;        }
<b class="fc">&nbsp;        this.sqlgGraph.addVertex(T.label, &quot;Cities&quot;, &quot;name&quot;, &quot;Johannesburg&quot;, &quot;population&quot;, 1000L, &quot;uid&quot;, &quot;uid_Johannesburg_1&quot;);</b>
<b class="fc">&nbsp;        this.sqlgGraph.tx().commit();</b>
&nbsp;
<b class="fc">&nbsp;        Assert.assertEquals(202, this.sqlgGraph.traversal().V().hasLabel(&quot;Cities&quot;).count().next(), 0);</b>
<b class="fc">&nbsp;        Assert.assertEquals(100, this.sqlgGraph.traversal().V().hasLabel(&quot;Cities&quot;).has(&quot;name&quot;, &quot;London&quot;).count().next(), 0);</b>
<b class="fc">&nbsp;        Assert.assertEquals(1, this.sqlgGraph.traversal().V().hasLabel(&quot;Cities&quot;).has(&quot;name&quot;, &quot;New York&quot;).count().next(), 0);</b>
<b class="fc">&nbsp;        Assert.assertEquals(100, this.sqlgGraph.traversal().V().hasLabel(&quot;Cities&quot;).has(&quot;name&quot;, &quot;Paris&quot;).count().next(), 0);</b>
&nbsp;
<b class="fc">&nbsp;        try (SqlgGraph sqlgGraph1 = SqlgGraph.open(configuration)) {</b>
<b class="fc">&nbsp;            Assert.assertEquals(202, sqlgGraph1.traversal().V().hasLabel(&quot;Cities&quot;).count().next(), 0);</b>
<b class="fc">&nbsp;            Assert.assertEquals(100, sqlgGraph1.traversal().V().hasLabel(&quot;Cities&quot;).has(&quot;name&quot;, &quot;London&quot;).count().next(), 0);</b>
<b class="fc">&nbsp;            Assert.assertEquals(1, sqlgGraph1.traversal().V().hasLabel(&quot;Cities&quot;).has(&quot;name&quot;, &quot;New York&quot;).count().next(), 0);</b>
<b class="fc">&nbsp;            Assert.assertEquals(100, sqlgGraph1.traversal().V().hasLabel(&quot;Cities&quot;).has(&quot;name&quot;, &quot;Paris&quot;).count().next(), 0);</b>
&nbsp;        } catch (Exception e) {
<b class="nc">&nbsp;            Assert.fail(e.getMessage());</b>
&nbsp;        }
&nbsp;
&nbsp;    }
&nbsp;
&nbsp;    @Test
&nbsp;    public void testPartitionRangeInSchema() {
<b class="fc">&nbsp;        Schema testSchema = this.sqlgGraph.getTopology().ensureSchemaExist(&quot;test&quot;);</b>
<b class="fc">&nbsp;        VertexLabel partitionedVertexLabel = testSchema.ensurePartitionedVertexLabelExist(&quot;Measurement&quot;,</b>
<b class="fc">&nbsp;                new LinkedHashMap&lt;&gt;() {{</b>
<b class="fc">&nbsp;                    put(&quot;date&quot;, PropertyDefinition.of(PropertyType.LOCALDATE));</b>
<b class="fc">&nbsp;                    put(&quot;temp&quot;, PropertyDefinition.of(PropertyType.INTEGER));</b>
&nbsp;                }},
<b class="fc">&nbsp;                ListOrderedSet.listOrderedSet(Collections.singletonList(&quot;date&quot;)),</b>
&nbsp;                PartitionType.RANGE,
&nbsp;                &quot;date&quot;);
<b class="fc">&nbsp;        partitionedVertexLabel.ensureRangePartitionExists(&quot;measurement1&quot;, &quot;&#39;2016-07-01&#39;&quot;, &quot;&#39;2016-08-01&#39;&quot;);</b>
<b class="fc">&nbsp;        partitionedVertexLabel.ensureRangePartitionExists(&quot;measurement2&quot;, &quot;&#39;2016-08-01&#39;&quot;, &quot;&#39;2016-09-01&#39;&quot;);</b>
<b class="fc">&nbsp;        this.sqlgGraph.tx().commit();</b>
&nbsp;
<b class="fc">&nbsp;        LocalDate localDate1 = LocalDate.of(2016, 7, 1);</b>
<b class="fc">&nbsp;        this.sqlgGraph.addVertex(T.label, &quot;test.Measurement&quot;, &quot;date&quot;, localDate1);</b>
<b class="fc">&nbsp;        LocalDate localDate2 = LocalDate.of(2016, 8, 1);</b>
<b class="fc">&nbsp;        this.sqlgGraph.addVertex(T.label, &quot;test.Measurement&quot;, &quot;date&quot;, localDate2);</b>
<b class="fc">&nbsp;        this.sqlgGraph.tx().commit();</b>
&nbsp;
<b class="fc">&nbsp;        Assert.assertEquals(2, this.sqlgGraph.traversal().V().hasLabel(&quot;test.Measurement&quot;).count().next(), 0);</b>
<b class="fc">&nbsp;        Assert.assertEquals(1, this.sqlgGraph.traversal().V().hasLabel(&quot;test.Measurement&quot;).has(&quot;date&quot;, localDate1).count().next(), 0);</b>
<b class="fc">&nbsp;        Assert.assertEquals(1, this.sqlgGraph.traversal().V().hasLabel(&quot;test.Measurement&quot;).has(&quot;date&quot;, localDate2).count().next(), 0);</b>
&nbsp;
<b class="fc">&nbsp;        Partition partition = this.sqlgGraph.getTopology().getSchema(&quot;test&quot;).orElseThrow().getVertexLabel(&quot;Measurement&quot;).orElseThrow().getPartition(&quot;measurement1&quot;).orElseThrow();</b>
<b class="fc">&nbsp;        partition.remove();</b>
<b class="fc">&nbsp;        this.sqlgGraph.tx().commit();</b>
&nbsp;
<b class="fc">&nbsp;        Assert.assertEquals(1, this.sqlgGraph.traversal().V().hasLabel(&quot;test.Measurement&quot;).count().next(), 0);</b>
<b class="fc">&nbsp;        Assert.assertEquals(0, this.sqlgGraph.traversal().V().hasLabel(&quot;test.Measurement&quot;).has(&quot;date&quot;, localDate1).count().next(), 0);</b>
<b class="fc">&nbsp;        Assert.assertEquals(1, this.sqlgGraph.traversal().V().hasLabel(&quot;test.Measurement&quot;).has(&quot;date&quot;, localDate2).count().next(), 0);</b>
&nbsp;
<b class="fc">&nbsp;        Assert.assertEquals(1, this.sqlgGraph.topology().V().hasLabel(Topology.SQLG_SCHEMA + &quot;.&quot; + Topology.SQLG_SCHEMA_PARTITION).count().next(), 0);</b>
&nbsp;
<b class="fc">&nbsp;        try (SqlgGraph sqlgGraph1 = SqlgGraph.open(configuration)) {</b>
&nbsp;
<b class="fc">&nbsp;            Assert.assertEquals(1, sqlgGraph1.traversal().V().hasLabel(&quot;test.Measurement&quot;).count().next(), 0);</b>
<b class="fc">&nbsp;            Assert.assertEquals(0, sqlgGraph1.traversal().V().hasLabel(&quot;test.Measurement&quot;).has(&quot;date&quot;, localDate1).count().next(), 0);</b>
<b class="fc">&nbsp;            Assert.assertEquals(1, sqlgGraph1.traversal().V().hasLabel(&quot;test.Measurement&quot;).has(&quot;date&quot;, localDate2).count().next(), 0);</b>
&nbsp;
<b class="fc">&nbsp;            Assert.assertEquals(1, sqlgGraph1.topology().V().hasLabel(Topology.SQLG_SCHEMA + &quot;.&quot; + Topology.SQLG_SCHEMA_PARTITION).count().next(), 0);</b>
&nbsp;        } catch (Exception e) {
<b class="nc">&nbsp;            Assert.fail(e.getMessage());</b>
&nbsp;        }
&nbsp;
&nbsp;    }
&nbsp;
&nbsp;    @Test
&nbsp;    public void testPartitionedEdgesRange() {
<b class="fc">&nbsp;        VertexLabel person = this.sqlgGraph.getTopology().getPublicSchema().ensureVertexLabelExist(&quot;Person&quot;);</b>
<b class="fc">&nbsp;        VertexLabel address = this.sqlgGraph.getTopology().getPublicSchema().ensureVertexLabelExist(&quot;Address&quot;);</b>
<b class="fc">&nbsp;        EdgeLabel livedAt = person.ensurePartitionedEdgeLabelExist(</b>
&nbsp;                &quot;liveAt&quot;,
&nbsp;                address,
<b class="fc">&nbsp;                new LinkedHashMap&lt;&gt;() {{</b>
<b class="fc">&nbsp;                    put(&quot;date&quot;, PropertyDefinition.of(PropertyType.LOCALDATE));</b>
&nbsp;                }},
<b class="fc">&nbsp;                ListOrderedSet.listOrderedSet(Collections.singletonList(&quot;date&quot;)),</b>
&nbsp;                PartitionType.RANGE,
&nbsp;                &quot;date&quot;);
<b class="fc">&nbsp;        Partition p1 = livedAt.ensureRangePartitionExists(&quot;livedAt1&quot;, &quot;&#39;2016-07-01&#39;&quot;, &quot;&#39;2016-08-01&#39;&quot;);</b>
<b class="fc">&nbsp;        Partition p2 = livedAt.ensureRangePartitionExists(&quot;livedAt2&quot;, &quot;&#39;2016-08-01&#39;&quot;, &quot;&#39;2016-09-01&#39;&quot;);</b>
<b class="fc">&nbsp;        this.sqlgGraph.tx().commit();</b>
&nbsp;
<b class="fc">&nbsp;        Vertex person1 = this.sqlgGraph.addVertex(T.label, &quot;Person&quot;);</b>
<b class="fc">&nbsp;        Vertex a1 = this.sqlgGraph.addVertex(T.label, &quot;Address&quot;);</b>
<b class="fc">&nbsp;        Vertex a2 = this.sqlgGraph.addVertex(T.label, &quot;Address&quot;);</b>
<b class="fc">&nbsp;        person1.addEdge(&quot;liveAt&quot;, a1, &quot;date&quot;, LocalDate.of(2016, 7, 1));</b>
<b class="fc">&nbsp;        person1.addEdge(&quot;liveAt&quot;, a2, &quot;date&quot;, LocalDate.of(2016, 8, 2));</b>
<b class="fc">&nbsp;        this.sqlgGraph.tx().commit();</b>
&nbsp;
<b class="fc">&nbsp;        Assert.assertEquals(2, this.sqlgGraph.traversal().E().hasLabel(&quot;liveAt&quot;).count().next(), 0);</b>
<b class="fc">&nbsp;        Assert.assertEquals(1, this.sqlgGraph.traversal().E().hasLabel(&quot;liveAt&quot;).has(&quot;date&quot;, LocalDate.of(2016, 7, 1)).count().next(), 0);</b>
&nbsp;
<b class="fc">&nbsp;        try (SqlgGraph sqlgGraph1 = SqlgGraph.open(configuration)) {</b>
<b class="fc">&nbsp;            Assert.assertEquals(2, this.sqlgGraph.traversal().E().hasLabel(&quot;liveAt&quot;).count().next(), 0);</b>
<b class="fc">&nbsp;            Assert.assertEquals(1, this.sqlgGraph.traversal().E().hasLabel(&quot;liveAt&quot;).has(&quot;date&quot;, LocalDate.of(2016, 7, 1)).count().next(), 0);</b>
<b class="fc">&nbsp;            Assert.assertEquals(2, sqlgGraph1.topology().V().hasLabel(Topology.SQLG_SCHEMA + &quot;.&quot; + Topology.SQLG_SCHEMA_PARTITION).count().next(), 0);</b>
&nbsp;
<b class="fc">&nbsp;            Assert.assertEquals(</b>
&nbsp;                    &quot;date&quot;,
<b class="fc">&nbsp;                    sqlgGraph1.getTopology().getPublicSchema().getEdgeLabel(&quot;liveAt&quot;).orElseThrow().getPartitionExpression()</b>
&nbsp;            );
<b class="fc">&nbsp;            Assert.assertEquals(</b>
&nbsp;                    PartitionType.RANGE,
<b class="fc">&nbsp;                    sqlgGraph1.getTopology().getPublicSchema().getEdgeLabel(&quot;liveAt&quot;).orElseThrow().getPartitionType()</b>
&nbsp;            );
&nbsp;        } catch (Exception e) {
<b class="nc">&nbsp;            Assert.fail(e.getMessage());</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    @Test
&nbsp;    public void testPartitionedEdgesList() {
<b class="fc">&nbsp;        VertexLabel person = this.sqlgGraph.getTopology().getPublicSchema().ensureVertexLabelExist(&quot;Person&quot;);</b>
<b class="fc">&nbsp;        VertexLabel address = this.sqlgGraph.getTopology().getPublicSchema().ensureVertexLabelExist(&quot;Address&quot;);</b>
<b class="fc">&nbsp;        EdgeLabel livedAt = person.ensurePartitionedEdgeLabelExist(</b>
&nbsp;                &quot;liveAt&quot;,
&nbsp;                address,
<b class="fc">&nbsp;                new LinkedHashMap&lt;&gt;() {{</b>
<b class="fc">&nbsp;                    put(&quot;date&quot;, PropertyDefinition.of(PropertyType.LOCALDATE));</b>
&nbsp;                }},
<b class="fc">&nbsp;                ListOrderedSet.listOrderedSet(Collections.singletonList(&quot;date&quot;)),</b>
&nbsp;                PartitionType.LIST,
&nbsp;                &quot;date&quot;);
<b class="fc">&nbsp;        Partition p1 = livedAt.ensureListPartitionExists(&quot;livedAt1&quot;, &quot;&#39;2016-07-01&#39;&quot;);</b>
<b class="fc">&nbsp;        Partition p2 = livedAt.ensureListPartitionExists(&quot;livedAt2&quot;, &quot;&#39;2016-07-02&#39;&quot;);</b>
<b class="fc">&nbsp;        Partition p3 = livedAt.ensureListPartitionExists(&quot;livedAt2&quot;, &quot;&#39;2016-07-03&#39;&quot;);</b>
<b class="fc">&nbsp;        Partition p4 = livedAt.ensureListPartitionExists(&quot;livedAt2&quot;, &quot;&#39;2016-07-04&#39;&quot;);</b>
<b class="fc">&nbsp;        this.sqlgGraph.tx().commit();</b>
&nbsp;
<b class="fc">&nbsp;        Vertex person1 = this.sqlgGraph.addVertex(T.label, &quot;Person&quot;);</b>
<b class="fc">&nbsp;        Vertex a1 = this.sqlgGraph.addVertex(T.label, &quot;Address&quot;);</b>
<b class="fc">&nbsp;        Vertex a2 = this.sqlgGraph.addVertex(T.label, &quot;Address&quot;);</b>
<b class="fc">&nbsp;        person1.addEdge(&quot;liveAt&quot;, a1, &quot;date&quot;, LocalDate.of(2016, 7, 1));</b>
<b class="fc">&nbsp;        person1.addEdge(&quot;liveAt&quot;, a2, &quot;date&quot;, LocalDate.of(2016, 7, 2));</b>
<b class="fc">&nbsp;        this.sqlgGraph.tx().commit();</b>
&nbsp;
<b class="fc">&nbsp;        Assert.assertEquals(2, this.sqlgGraph.traversal().E().hasLabel(&quot;liveAt&quot;).count().next(), 0);</b>
<b class="fc">&nbsp;        Assert.assertEquals(1, this.sqlgGraph.traversal().E().hasLabel(&quot;liveAt&quot;).has(&quot;date&quot;, LocalDate.of(2016, 7, 1)).count().next(), 0);</b>
&nbsp;
<b class="fc">&nbsp;        try (SqlgGraph sqlgGraph1 = SqlgGraph.open(configuration)) {</b>
<b class="fc">&nbsp;            Assert.assertEquals(2, this.sqlgGraph.traversal().E().hasLabel(&quot;liveAt&quot;).count().next(), 0);</b>
<b class="fc">&nbsp;            Assert.assertEquals(1, this.sqlgGraph.traversal().E().hasLabel(&quot;liveAt&quot;).has(&quot;date&quot;, LocalDate.of(2016, 7, 1)).count().next(), 0);</b>
<b class="fc">&nbsp;            Assert.assertEquals(2, sqlgGraph1.topology().V().hasLabel(Topology.SQLG_SCHEMA + &quot;.&quot; + Topology.SQLG_SCHEMA_PARTITION).count().next(), 0);</b>
&nbsp;        } catch (Exception e) {
<b class="nc">&nbsp;            Assert.fail(e.getMessage());</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    @Test
&nbsp;    public void testSubPartitioningRange() {
<b class="fc">&nbsp;        Schema publicSchema = this.sqlgGraph.getTopology().getPublicSchema();</b>
<b class="fc">&nbsp;        VertexLabel measurement = publicSchema.ensurePartitionedVertexLabelExist(&quot;Measurement&quot;,</b>
<b class="fc">&nbsp;                new LinkedHashMap&lt;&gt;() {{</b>
<b class="fc">&nbsp;                    put(&quot;name&quot;, PropertyDefinition.of(PropertyType.STRING));</b>
<b class="fc">&nbsp;                    put(&quot;logdate&quot;, PropertyDefinition.of(PropertyType.LOCALDATE));</b>
<b class="fc">&nbsp;                    put(&quot;peaktemp&quot;, PropertyDefinition.of(PropertyType.INTEGER));</b>
<b class="fc">&nbsp;                    put(&quot;unitsales&quot;, PropertyDefinition.of(PropertyType.INTEGER));</b>
&nbsp;                }},
<b class="fc">&nbsp;                ListOrderedSet.listOrderedSet(List.of(&quot;name&quot;, &quot;logdate&quot;, &quot;peaktemp&quot;)),</b>
&nbsp;                PartitionType.RANGE,
&nbsp;                &quot;logdate&quot;);
&nbsp;
<b class="fc">&nbsp;        Partition p1 = measurement.ensureRangePartitionWithSubPartitionExists(&quot;measurement_y2006m02&quot;, &quot;&#39;2006-02-01&#39;&quot;, &quot;&#39;2006-03-01&#39;&quot;, PartitionType.RANGE, &quot;peaktemp&quot;);</b>
<b class="fc">&nbsp;        Partition p2 = measurement.ensureRangePartitionWithSubPartitionExists(&quot;measurement_y2006m03&quot;, &quot;&#39;2006-03-01&#39;&quot;, &quot;&#39;2006-04-01&#39;&quot;, PartitionType.RANGE, &quot;peaktemp&quot;);</b>
<b class="fc">&nbsp;        p1.ensureRangePartitionExists(&quot;peaktemp1&quot;, &quot;1&quot;, &quot;2&quot;);</b>
<b class="fc">&nbsp;        p1.ensureRangePartitionExists(&quot;peaktemp2&quot;, &quot;2&quot;, &quot;3&quot;);</b>
<b class="fc">&nbsp;        p2.ensureRangePartitionExists(&quot;peaktemp3&quot;, &quot;1&quot;, &quot;2&quot;);</b>
<b class="fc">&nbsp;        p2.ensureRangePartitionExists(&quot;peaktemp4&quot;, &quot;2&quot;, &quot;3&quot;);</b>
<b class="fc">&nbsp;        this.sqlgGraph.tx().commit();</b>
&nbsp;
<b class="fc">&nbsp;        this.sqlgGraph.addVertex(T.label, &quot;Measurement&quot;, &quot;name&quot;, &quot;measurement1&quot;, &quot;logdate&quot;, LocalDate.of(2006, 2, 1),</b>
<b class="fc">&nbsp;                &quot;peaktemp&quot;, 1, &quot;unitsales&quot;, 1);</b>
<b class="fc">&nbsp;        this.sqlgGraph.addVertex(T.label, &quot;Measurement&quot;, &quot;name&quot;, &quot;measurement2&quot;, &quot;logdate&quot;, LocalDate.of(2006, 2, 2),</b>
<b class="fc">&nbsp;                &quot;peaktemp&quot;, 1, &quot;unitsales&quot;, 1);</b>
<b class="fc">&nbsp;        this.sqlgGraph.addVertex(T.label, &quot;Measurement&quot;, &quot;name&quot;, &quot;measurement3&quot;, &quot;logdate&quot;, LocalDate.of(2006, 3, 1),</b>
<b class="fc">&nbsp;                &quot;peaktemp&quot;, 1, &quot;unitsales&quot;, 1);</b>
<b class="fc">&nbsp;        this.sqlgGraph.addVertex(T.label, &quot;Measurement&quot;, &quot;name&quot;, &quot;measurement4&quot;, &quot;logdate&quot;, LocalDate.of(2006, 3, 2),</b>
<b class="fc">&nbsp;                &quot;peaktemp&quot;, 2, &quot;unitsales&quot;, 1);</b>
<b class="fc">&nbsp;        this.sqlgGraph.tx().commit();</b>
&nbsp;
<b class="fc">&nbsp;        List&lt;Vertex&gt; vertexList = this.sqlgGraph.traversal().V()</b>
<b class="fc">&nbsp;                .hasLabel(&quot;Measurement&quot;)</b>
<b class="fc">&nbsp;                .has(&quot;logdate&quot;, LocalDate.of(2006, 2, 1))</b>
<b class="fc">&nbsp;                .has(&quot;peaktemp&quot;, 1)</b>
<b class="fc">&nbsp;                .toList();</b>
<b class="fc">&nbsp;        Assert.assertEquals(1, vertexList.size());</b>
&nbsp;    }
&nbsp;
&nbsp;    @Test
&nbsp;    public void testSubPartitioningList() {
<b class="fc">&nbsp;        Schema publicSchema = this.sqlgGraph.getTopology().getPublicSchema();</b>
<b class="fc">&nbsp;        VertexLabel measurement = publicSchema.ensurePartitionedVertexLabelExist(&quot;Measurement&quot;,</b>
<b class="fc">&nbsp;                new LinkedHashMap&lt;&gt;() {{</b>
<b class="fc">&nbsp;                    put(&quot;name&quot;, PropertyDefinition.of(PropertyType.STRING));</b>
<b class="fc">&nbsp;                    put(&quot;list1&quot;, PropertyDefinition.of(PropertyType.STRING));</b>
<b class="fc">&nbsp;                    put(&quot;list2&quot;, PropertyDefinition.of(PropertyType.INTEGER));</b>
<b class="fc">&nbsp;                    put(&quot;unitsales&quot;, PropertyDefinition.of(PropertyType.INTEGER));</b>
&nbsp;                }},
<b class="fc">&nbsp;                ListOrderedSet.listOrderedSet(List.of(&quot;name&quot;, &quot;list1&quot;, &quot;list2&quot;)),</b>
&nbsp;                PartitionType.LIST,
&nbsp;                &quot;list1&quot;);
&nbsp;
<b class="fc">&nbsp;        Partition p1 = measurement.ensureListPartitionWithSubPartitionExists(&quot;measurement_list1&quot;, &quot;&#39;1&#39;&quot;, PartitionType.LIST, &quot;list2&quot;);</b>
<b class="fc">&nbsp;        Partition p2 = measurement.ensureListPartitionWithSubPartitionExists(&quot;measurement_list2&quot;, &quot;&#39;2&#39;&quot;, PartitionType.LIST, &quot;list2&quot;);</b>
<b class="fc">&nbsp;        p1.ensureListPartitionExists(&quot;measurement_list1_1&quot;, &quot;1&quot;);</b>
<b class="fc">&nbsp;        p1.ensureListPartitionExists(&quot;measurement_list1_2&quot;, &quot;2&quot;);</b>
<b class="fc">&nbsp;        p1.ensureListPartitionExists(&quot;measurement_list1_3&quot;, &quot;3&quot;);</b>
<b class="fc">&nbsp;        p1.ensureListPartitionExists(&quot;measurement_list1_4&quot;, &quot;4&quot;);</b>
&nbsp;
<b class="fc">&nbsp;        p2.ensureListPartitionExists(&quot;measurement_list2_1&quot;, &quot;1&quot;);</b>
<b class="fc">&nbsp;        p2.ensureListPartitionExists(&quot;measurement_list2_2&quot;, &quot;2&quot;);</b>
<b class="fc">&nbsp;        p2.ensureListPartitionExists(&quot;measurement_list2_3&quot;, &quot;3&quot;);</b>
<b class="fc">&nbsp;        p2.ensureListPartitionExists(&quot;measurement_list2_4&quot;, &quot;4&quot;);</b>
<b class="fc">&nbsp;        this.sqlgGraph.tx().commit();</b>
&nbsp;
<b class="fc">&nbsp;        this.sqlgGraph.addVertex(T.label, &quot;Measurement&quot;, &quot;name&quot;, &quot;measurement1&quot;, &quot;list1&quot;, &quot;1&quot;, &quot;list2&quot;, 1, &quot;unitsales&quot;, 1);</b>
<b class="fc">&nbsp;        this.sqlgGraph.addVertex(T.label, &quot;Measurement&quot;, &quot;name&quot;, &quot;measurement2&quot;, &quot;list1&quot;, &quot;1&quot;, &quot;list2&quot;, 2, &quot;unitsales&quot;, 1);</b>
<b class="fc">&nbsp;        this.sqlgGraph.addVertex(T.label, &quot;Measurement&quot;, &quot;name&quot;, &quot;measurement3&quot;, &quot;list1&quot;, &quot;1&quot;, &quot;list2&quot;, 3, &quot;unitsales&quot;, 1);</b>
<b class="fc">&nbsp;        this.sqlgGraph.addVertex(T.label, &quot;Measurement&quot;, &quot;name&quot;, &quot;measurement4&quot;, &quot;list1&quot;, &quot;1&quot;, &quot;list2&quot;, 4, &quot;unitsales&quot;, 1);</b>
<b class="fc">&nbsp;        this.sqlgGraph.addVertex(T.label, &quot;Measurement&quot;, &quot;name&quot;, &quot;measurement5&quot;, &quot;list1&quot;, &quot;1&quot;, &quot;list2&quot;, 4, &quot;unitsales&quot;, 1);</b>
<b class="fc">&nbsp;        this.sqlgGraph.addVertex(T.label, &quot;Measurement&quot;, &quot;name&quot;, &quot;measurement6&quot;, &quot;list1&quot;, &quot;1&quot;, &quot;list2&quot;, 4, &quot;unitsales&quot;, 1);</b>
<b class="fc">&nbsp;        this.sqlgGraph.addVertex(T.label, &quot;Measurement&quot;, &quot;name&quot;, &quot;measurement7&quot;, &quot;list1&quot;, &quot;1&quot;, &quot;list2&quot;, 4, &quot;unitsales&quot;, 1);</b>
&nbsp;
<b class="fc">&nbsp;        this.sqlgGraph.addVertex(T.label, &quot;Measurement&quot;, &quot;name&quot;, &quot;measurement8&quot;, &quot;list1&quot;, &quot;2&quot;, &quot;list2&quot;, 1, &quot;unitsales&quot;, 1);</b>
<b class="fc">&nbsp;        this.sqlgGraph.addVertex(T.label, &quot;Measurement&quot;, &quot;name&quot;, &quot;measurement9&quot;, &quot;list1&quot;, &quot;2&quot;, &quot;list2&quot;, 2, &quot;unitsales&quot;, 1);</b>
<b class="fc">&nbsp;        this.sqlgGraph.addVertex(T.label, &quot;Measurement&quot;, &quot;name&quot;, &quot;measurement10&quot;, &quot;list1&quot;, &quot;2&quot;, &quot;list2&quot;, 3, &quot;unitsales&quot;, 1);</b>
<b class="fc">&nbsp;        this.sqlgGraph.addVertex(T.label, &quot;Measurement&quot;, &quot;name&quot;, &quot;measurement11&quot;, &quot;list1&quot;, &quot;2&quot;, &quot;list2&quot;, 4, &quot;unitsales&quot;, 1);</b>
<b class="fc">&nbsp;        this.sqlgGraph.addVertex(T.label, &quot;Measurement&quot;, &quot;name&quot;, &quot;measurement12&quot;, &quot;list1&quot;, &quot;2&quot;, &quot;list2&quot;, 4, &quot;unitsales&quot;, 1);</b>
<b class="fc">&nbsp;        this.sqlgGraph.addVertex(T.label, &quot;Measurement&quot;, &quot;name&quot;, &quot;measurement13&quot;, &quot;list1&quot;, &quot;2&quot;, &quot;list2&quot;, 4, &quot;unitsales&quot;, 1);</b>
<b class="fc">&nbsp;        this.sqlgGraph.addVertex(T.label, &quot;Measurement&quot;, &quot;name&quot;, &quot;measurement14&quot;, &quot;list1&quot;, &quot;2&quot;, &quot;list2&quot;, 4, &quot;unitsales&quot;, 1);</b>
&nbsp;
<b class="fc">&nbsp;        this.sqlgGraph.tx().commit();</b>
&nbsp;
<b class="fc">&nbsp;        List&lt;Vertex&gt; vertexList = this.sqlgGraph.traversal().V()</b>
<b class="fc">&nbsp;                .hasLabel(&quot;Measurement&quot;)</b>
<b class="fc">&nbsp;                .has(&quot;list1&quot;, &quot;1&quot;)</b>
<b class="fc">&nbsp;                .toList();</b>
<b class="fc">&nbsp;        Assert.assertEquals(7, vertexList.size());</b>
&nbsp;
<b class="fc">&nbsp;        vertexList = this.sqlgGraph.traversal().V()</b>
<b class="fc">&nbsp;                .hasLabel(&quot;Measurement&quot;)</b>
<b class="fc">&nbsp;                .has(&quot;list1&quot;, &quot;2&quot;)</b>
<b class="fc">&nbsp;                .has(&quot;list2&quot;, 4)</b>
<b class="fc">&nbsp;                .toList();</b>
<b class="fc">&nbsp;        Assert.assertEquals(4, vertexList.size());</b>
&nbsp;    }
&nbsp;
&nbsp;    @Test
&nbsp;    public void testEdgeSubPartitioningRange() {
<b class="fc">&nbsp;        Schema publicSchema = this.sqlgGraph.getTopology().getPublicSchema();</b>
<b class="fc">&nbsp;        VertexLabel a = publicSchema.ensureVertexLabelExist(&quot;A&quot;);</b>
<b class="fc">&nbsp;        VertexLabel b = publicSchema.ensureVertexLabelExist(&quot;B&quot;);</b>
<b class="fc">&nbsp;        EdgeLabel ab = a.ensurePartitionedEdgeLabelExist(</b>
&nbsp;                &quot;ab&quot;,
&nbsp;                b,
<b class="fc">&nbsp;                new LinkedHashMap&lt;&gt;() {{</b>
<b class="fc">&nbsp;                    put(&quot;int1&quot;, PropertyDefinition.of(PropertyType.INTEGER));</b>
<b class="fc">&nbsp;                    put(&quot;int2&quot;, PropertyDefinition.of(PropertyType.INTEGER));</b>
&nbsp;                }},
<b class="fc">&nbsp;                ListOrderedSet.listOrderedSet(List.of(&quot;int1&quot;, &quot;int2&quot;)),</b>
&nbsp;                PartitionType.RANGE,
&nbsp;                &quot;int1&quot;);
<b class="fc">&nbsp;        Partition p11 = ab.ensureRangePartitionWithSubPartitionExists(&quot;int1_1_4&quot;, &quot;1&quot;, &quot;4&quot;, PartitionType.RANGE, &quot;int2&quot;);</b>
<b class="fc">&nbsp;        Partition p12 = ab.ensureRangePartitionWithSubPartitionExists(&quot;int1_4_8&quot;, &quot;4&quot;, &quot;8&quot;, PartitionType.RANGE, &quot;int2&quot;);</b>
<b class="fc">&nbsp;        Partition p13 = ab.ensureRangePartitionWithSubPartitionExists(&quot;int1_8_12&quot;, &quot;8&quot;, &quot;12&quot;, PartitionType.RANGE, &quot;int2&quot;);</b>
&nbsp;
<b class="fc">&nbsp;        p11.ensureRangePartitionExists(&quot;int2_1_4&quot;, &quot;1&quot;, &quot;4&quot;);</b>
<b class="fc">&nbsp;        p11.ensureRangePartitionExists(&quot;int2_4_8&quot;, &quot;4&quot;, &quot;8&quot;);</b>
<b class="fc">&nbsp;        p11.ensureRangePartitionExists(&quot;int2_8_12&quot;, &quot;8&quot;, &quot;12&quot;);</b>
<b class="fc">&nbsp;        p11.ensureRangePartitionExists(&quot;int2_12_16&quot;, &quot;12&quot;, &quot;16&quot;);</b>
&nbsp;
<b class="fc">&nbsp;        p12.ensureRangePartitionExists(&quot;int22_1_4&quot;, &quot;1&quot;, &quot;4&quot;);</b>
<b class="fc">&nbsp;        p12.ensureRangePartitionExists(&quot;int22_4_8&quot;, &quot;4&quot;, &quot;8&quot;);</b>
<b class="fc">&nbsp;        p12.ensureRangePartitionExists(&quot;int22_8_12&quot;, &quot;8&quot;, &quot;12&quot;);</b>
<b class="fc">&nbsp;        p12.ensureRangePartitionExists(&quot;int22_12_16&quot;, &quot;12&quot;, &quot;16&quot;);</b>
&nbsp;
<b class="fc">&nbsp;        p13.ensureRangePartitionExists(&quot;int23_1_4&quot;, &quot;1&quot;, &quot;4&quot;);</b>
<b class="fc">&nbsp;        p13.ensureRangePartitionExists(&quot;int23_4_8&quot;, &quot;4&quot;, &quot;8&quot;);</b>
<b class="fc">&nbsp;        p13.ensureRangePartitionExists(&quot;int23_8_12&quot;, &quot;8&quot;, &quot;12&quot;);</b>
<b class="fc">&nbsp;        p13.ensureRangePartitionExists(&quot;int23_12_16&quot;, &quot;12&quot;, &quot;16&quot;);</b>
<b class="fc">&nbsp;        this.sqlgGraph.tx().commit();</b>
&nbsp;
<b class="fc">&nbsp;        try (SqlgGraph sqlgGraph1 = SqlgGraph.open(configuration)) {</b>
<b class="fc">&nbsp;            Vertex a1 = sqlgGraph1.addVertex(T.label, &quot;A&quot;);</b>
<b class="fc">&nbsp;            Vertex b1 = sqlgGraph1.addVertex(T.label, &quot;B&quot;);</b>
<b class="fc">&nbsp;            a1.addEdge(&quot;ab&quot;, b1, &quot;int1&quot;, 2, &quot;int2&quot;, 2);</b>
<b class="fc">&nbsp;            a1.addEdge(&quot;ab&quot;, b1, &quot;int1&quot;, 6, &quot;int2&quot;, 6);</b>
<b class="fc">&nbsp;            a1.addEdge(&quot;ab&quot;, b1, &quot;int1&quot;, 10, &quot;int2&quot;, 10);</b>
<b class="fc">&nbsp;            a1.addEdge(&quot;ab&quot;, b1, &quot;int1&quot;, 11, &quot;int2&quot;, 14);</b>
<b class="fc">&nbsp;            sqlgGraph1.tx().commit();</b>
&nbsp;        } catch (Exception e) {
<b class="nc">&nbsp;            Assert.fail(e.getMessage());</b>
&nbsp;        }
&nbsp;
<b class="fc">&nbsp;        Assert.assertEquals(4, this.sqlgGraph.traversal().V().hasLabel(&quot;A&quot;).out().count().next(), 0);</b>
<b class="fc">&nbsp;        Assert.assertEquals(1, this.sqlgGraph.traversal().V().hasLabel(&quot;A&quot;).outE().has(&quot;int1&quot;, 6).has(&quot;int2&quot;, 6).otherV().count().next(), 0);</b>
&nbsp;
&nbsp;    }
&nbsp;
&nbsp;    @Test
&nbsp;    public void testEdgeSubPartitioningList() {
<b class="fc">&nbsp;        Schema publicSchema = this.sqlgGraph.getTopology().getPublicSchema();</b>
<b class="fc">&nbsp;        VertexLabel a = publicSchema.ensureVertexLabelExist(&quot;A&quot;);</b>
<b class="fc">&nbsp;        VertexLabel b = publicSchema.ensureVertexLabelExist(&quot;B&quot;);</b>
<b class="fc">&nbsp;        EdgeLabel ab = a.ensurePartitionedEdgeLabelExist(</b>
&nbsp;                &quot;ab&quot;,
&nbsp;                b,
<b class="fc">&nbsp;                new LinkedHashMap&lt;&gt;() {{</b>
<b class="fc">&nbsp;                    put(&quot;uid&quot;, PropertyDefinition.of(PropertyType.STRING));</b>
<b class="fc">&nbsp;                    put(&quot;int1&quot;, PropertyDefinition.of(PropertyType.INTEGER));</b>
<b class="fc">&nbsp;                    put(&quot;int2&quot;, PropertyDefinition.of(PropertyType.INTEGER));</b>
&nbsp;                }},
<b class="fc">&nbsp;                ListOrderedSet.listOrderedSet(List.of(&quot;uid&quot;, &quot;int1&quot;, &quot;int2&quot;)),</b>
&nbsp;                PartitionType.LIST,
&nbsp;                &quot;int1&quot;);
<b class="fc">&nbsp;        Partition p11 = ab.ensureListPartitionWithSubPartitionExists(&quot;int1_1_5&quot;, &quot;1,2,3,4,5&quot;, PartitionType.LIST, &quot;int2&quot;);</b>
<b class="fc">&nbsp;        Partition p12 = ab.ensureListPartitionWithSubPartitionExists(&quot;int1_5_10&quot;, &quot;6,7,8,9,10&quot;, PartitionType.LIST, &quot;int2&quot;);</b>
&nbsp;
<b class="fc">&nbsp;        p11.ensureListPartitionExists(&quot;int2_11_15&quot;, &quot;11,12,13,14,15&quot;);</b>
<b class="fc">&nbsp;        p11.ensureListPartitionExists(&quot;int2_16_20&quot;, &quot;16,17,18,19,20&quot;);</b>
&nbsp;
<b class="fc">&nbsp;        p12.ensureListPartitionExists(&quot;int22_11_15&quot;, &quot;11,12,13,14,15&quot;);</b>
<b class="fc">&nbsp;        p12.ensureListPartitionExists(&quot;int22_16_20&quot;, &quot;16,17,18,19,20&quot;);</b>
&nbsp;
<b class="fc">&nbsp;        this.sqlgGraph.tx().commit();</b>
&nbsp;
<b class="fc">&nbsp;        try (SqlgGraph sqlgGraph1 = SqlgGraph.open(configuration)) {</b>
<b class="fc">&nbsp;            Vertex a1 = sqlgGraph1.addVertex(T.label, &quot;A&quot;);</b>
<b class="fc">&nbsp;            Vertex b1 = sqlgGraph1.addVertex(T.label, &quot;B&quot;);</b>
<b class="fc">&nbsp;            a1.addEdge(&quot;ab&quot;, b1, &quot;uid&quot;, UUID.randomUUID().toString(), &quot;int1&quot;, 2, &quot;int2&quot;, 12);</b>
<b class="fc">&nbsp;            a1.addEdge(&quot;ab&quot;, b1, &quot;uid&quot;, UUID.randomUUID().toString(), &quot;int1&quot;, 6, &quot;int2&quot;, 13);</b>
<b class="fc">&nbsp;            a1.addEdge(&quot;ab&quot;, b1, &quot;uid&quot;, UUID.randomUUID().toString(), &quot;int1&quot;, 10, &quot;int2&quot;, 14);</b>
<b class="fc">&nbsp;            a1.addEdge(&quot;ab&quot;, b1, &quot;uid&quot;, UUID.randomUUID().toString(), &quot;int1&quot;, 10, &quot;int2&quot;, 15);</b>
<b class="fc">&nbsp;            sqlgGraph1.tx().commit();</b>
&nbsp;        } catch (Exception e) {
<b class="nc">&nbsp;            Assert.fail(e.getMessage());</b>
&nbsp;        }
&nbsp;
<b class="fc">&nbsp;        Assert.assertEquals(4, this.sqlgGraph.traversal().V().hasLabel(&quot;A&quot;).out().count().next(), 0);</b>
<b class="fc">&nbsp;        Assert.assertEquals(</b>
&nbsp;                1,
<b class="fc">&nbsp;                this.sqlgGraph.traversal()</b>
<b class="fc">&nbsp;                        .V().hasLabel(&quot;A&quot;)</b>
<b class="fc">&nbsp;                        .outE().has(&quot;int1&quot;, 6).has(&quot;int2&quot;, 13)</b>
<b class="fc">&nbsp;                        .otherV().count().next(), 0);</b>
&nbsp;
&nbsp;    }
&nbsp;}
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2025-06-23 10:13</div>
</div>
</body>
</html>
