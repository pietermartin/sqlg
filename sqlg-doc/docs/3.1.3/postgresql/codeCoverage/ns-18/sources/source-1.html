


<!DOCTYPE html>
<html id="htmlId">
<head>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8"> 
  <title>Coverage Report > TestIndex</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope:     <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">org.umlg.sqlg.test.index</a>
</div>

<h1>Coverage Summary for Class: TestIndex (org.umlg.sqlg.test.index)</h1>

<table class="coverageStats">

<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Branch, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">TestIndex</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (19/19)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    66.7%
  </span>
  <span class="absValue">
    (28/42)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    98.6%
  </span>
  <span class="absValue">
    (289/293)
  </span>
</td>
</tr>
  <tr>
    <td class="name">TestIndex$1</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (1/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TestIndex$10</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (1/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TestIndex$11</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (1/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TestIndex$12</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (1/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TestIndex$13</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (1/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TestIndex$14</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (1/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TestIndex$15</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (1/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TestIndex$16</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (1/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TestIndex$17</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (1/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TestIndex$2</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (1/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TestIndex$3</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (1/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (4/4)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TestIndex$4</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (1/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (4/4)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TestIndex$5</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (1/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (4/4)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TestIndex$6</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (1/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TestIndex$7</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (1/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TestIndex$8</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (1/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TestIndex$9</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (1/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
  </tr>
<tr>
  <td class="name"><strong>Total</strong></td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (36/36)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    66.7%
  </span>
  <span class="absValue">
    (28/42)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    98.8%
  </span>
  <span class="absValue">
    (333/337)
  </span>
</td>
</tr>
</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode">&nbsp;package org.umlg.sqlg.test.index;
&nbsp;
&nbsp;import com.fasterxml.jackson.databind.ObjectMapper;
&nbsp;import org.apache.tinkerpop.gremlin.process.traversal.P;
&nbsp;import org.apache.tinkerpop.gremlin.structure.T;
&nbsp;import org.apache.tinkerpop.gremlin.structure.Vertex;
&nbsp;import org.junit.Assert;
&nbsp;import org.junit.Assume;
&nbsp;import org.junit.Test;
&nbsp;import org.umlg.sqlg.structure.PropertyDefinition;
&nbsp;import org.umlg.sqlg.structure.PropertyType;
&nbsp;import org.umlg.sqlg.structure.SchemaTable;
&nbsp;import org.umlg.sqlg.structure.SqlgGraph;
&nbsp;import org.umlg.sqlg.structure.topology.*;
&nbsp;import org.umlg.sqlg.test.BaseTest;
&nbsp;
&nbsp;import java.sql.Connection;
&nbsp;import java.sql.ResultSet;
&nbsp;import java.sql.SQLException;
&nbsp;import java.sql.Statement;
&nbsp;import java.util.*;
&nbsp;
&nbsp;/**
&nbsp; * Date: 2014/08/17
&nbsp; * Time: 2:43 PM
&nbsp; */
&nbsp;@SuppressWarnings(&quot;DuplicatedCode&quot;)
<b class="fc">&nbsp;public class TestIndex extends BaseTest {</b>
&nbsp;
&nbsp;    @Test
&nbsp;    public void testIndexViaTopology() {
<b class="fc">&nbsp;        Assume.assumeTrue(this.sqlgGraph.getSqlDialect().supportsTransactionalSchema());</b>
<b class="fc">&nbsp;        this.sqlgGraph.traversal().V().hasLabel(&quot;Person&quot;).values(T.id.getAccessor());</b>
<b class="fc">&nbsp;        for (int i = 0; i &lt; 5000; i++) {</b>
<b class="fc">&nbsp;            this.sqlgGraph.addVertex(T.label, &quot;Person&quot;, &quot;name&quot;, &quot;john&quot;);</b>
&nbsp;        }
<b class="fc">&nbsp;        this.sqlgGraph.tx().commit();</b>
<b class="fc">&nbsp;        Optional&lt;VertexLabel&gt; personVertexOptional = this.sqlgGraph.getTopology().getVertexLabel(this.sqlgGraph.getSqlDialect().getPublicSchema(), &quot;Person&quot;);</b>
<b class="fc">&nbsp;        Assert.assertTrue(personVertexOptional.isPresent());</b>
<b class="fc">&nbsp;        Optional&lt;PropertyColumn&gt; namePropertyOptional = personVertexOptional.get().getProperty(&quot;name&quot;);</b>
<b class="fc">&nbsp;        Assert.assertTrue(namePropertyOptional.isPresent());</b>
<b class="fc">&nbsp;        Optional&lt;Index&gt; indexOptional = personVertexOptional.get().getIndex(&quot;name&quot;);</b>
<b class="fc">&nbsp;        Assert.assertFalse(indexOptional.isPresent());</b>
&nbsp;
<b class="fc">&nbsp;        this.sqlgGraph.tx().rollback();</b>
&nbsp;
<b class="fc">&nbsp;        indexOptional = personVertexOptional.get().getIndex(&quot;name&quot;);</b>
<b class="fc">&nbsp;        Assert.assertFalse(indexOptional.isPresent());</b>
&nbsp;
<b class="fc">&nbsp;        Index index = personVertexOptional.get().ensureIndexExists(IndexType.NON_UNIQUE, Collections.singletonList(namePropertyOptional.get()));</b>
<b class="fc">&nbsp;        this.sqlgGraph.tx().commit();</b>
<b class="fc">&nbsp;        Assert.assertSame(index.getIndexType(), IndexType.NON_UNIQUE);</b>
&nbsp;
&nbsp;        //Check if the index is being used
<b class="fc">&nbsp;        Connection conn = this.sqlgGraph.tx().getConnection();</b>
<b class="fc">&nbsp;        try (Statement statement = conn.createStatement()) {</b>
<b class="pc">&nbsp;            if (this.sqlgGraph.getSqlDialect().getClass().getSimpleName().contains(&quot;Postgres&quot;)) {</b>
<b class="fc">&nbsp;                ResultSet rs = statement.executeQuery(&quot;explain analyze SELECT * FROM \&quot;public\&quot;.\&quot;V_Person\&quot; a WHERE a.\&quot;name\&quot; = &#39;john&#39;&quot;);</b>
<b class="fc">&nbsp;                Assert.assertTrue(rs.next());</b>
<b class="fc">&nbsp;                String result = rs.getString(1);</b>
<b class="fc">&nbsp;                System.out.println(result);</b>
<b class="pc">&nbsp;                Assert.assertTrue(result.contains(&quot;Index Scan&quot;) || result.contains(&quot;Bitmap Heap Scan&quot;));</b>
&nbsp;            }
&nbsp;        } catch (SQLException e) {
<b class="nc">&nbsp;            Assert.fail(e.getMessage());</b>
&nbsp;        }
<b class="fc">&nbsp;        this.sqlgGraph.tx().rollback();</b>
&nbsp;    }
&nbsp;
&nbsp;    @Test
&nbsp;    public void testUniqueIndexViaTopolgy() {
<b class="fc">&nbsp;        this.sqlgGraph.addVertex(T.label, &quot;Person&quot;, &quot;name&quot;, &quot;john&quot;);</b>
<b class="fc">&nbsp;        this.sqlgGraph.tx().commit();</b>
<b class="fc">&nbsp;        Optional&lt;VertexLabel&gt; personVertexLabelOptional = this.sqlgGraph.getTopology().getVertexLabel(this.sqlgGraph.getSqlDialect().getPublicSchema(), &quot;Person&quot;);</b>
<b class="fc">&nbsp;        Assert.assertTrue(personVertexLabelOptional.isPresent());</b>
<b class="fc">&nbsp;        Optional&lt;PropertyColumn&gt; propertyOptional = personVertexLabelOptional.get().getProperty(&quot;name&quot;);</b>
<b class="fc">&nbsp;        Assert.assertTrue(propertyOptional.isPresent());</b>
&nbsp;
<b class="fc">&nbsp;        personVertexLabelOptional.get().ensureIndexExists(IndexType.UNIQUE, Collections.singletonList(propertyOptional.get()));</b>
<b class="fc">&nbsp;        this.sqlgGraph.tx().commit();</b>
&nbsp;        try {
<b class="fc">&nbsp;            this.sqlgGraph.addVertex(T.label, &quot;Person&quot;, &quot;name&quot;, &quot;john&quot;);</b>
<b class="nc">&nbsp;            Assert.fail(&quot;Unique index did not work.&quot;);</b>
&nbsp;        } catch (RuntimeException ignored) {
&nbsp;
&nbsp;        }
<b class="fc">&nbsp;        this.sqlgGraph.tx().rollback();</b>
&nbsp;    }
&nbsp;
&nbsp;    @Test
&nbsp;    public void testIndexOnInteger() {
<b class="fc">&nbsp;        VertexLabel vertexLabel = this.sqlgGraph.getTopology().ensureVertexLabelExist(&quot;Person&quot;, new LinkedHashMap&lt;&gt;() {{</b>
<b class="fc">&nbsp;            put(&quot;name&quot;, PropertyDefinition.of(PropertyType.STRING));</b>
<b class="fc">&nbsp;            put(&quot;age&quot;, PropertyDefinition.of(PropertyType.INTEGER));</b>
&nbsp;        }});
<b class="fc">&nbsp;        vertexLabel.ensureIndexExists(IndexType.NON_UNIQUE, new ArrayList&lt;&gt;(vertexLabel.getProperties().values()));</b>
&nbsp;
<b class="fc">&nbsp;        this.sqlgGraph.tx().commit();</b>
<b class="fc">&nbsp;        for (int i = 0; i &lt; 5000; i++) {</b>
<b class="fc">&nbsp;            this.sqlgGraph.addVertex(T.label, &quot;Person&quot;, &quot;name&quot;, &quot;john&quot; + i, &quot;age&quot;, i);</b>
&nbsp;        }
<b class="fc">&nbsp;        this.sqlgGraph.tx().commit();</b>
&nbsp;        //Check if the index is being used
<b class="fc">&nbsp;        Connection conn = this.sqlgGraph.tx().getConnection();</b>
<b class="fc">&nbsp;        try (Statement statement = conn.createStatement()) {</b>
<b class="pc">&nbsp;            if (this.sqlgGraph.getSqlDialect().getClass().getSimpleName().contains(&quot;Postgres&quot;)) {</b>
<b class="fc">&nbsp;                ResultSet rs = statement.executeQuery(&quot;explain analyze SELECT * FROM \&quot;public\&quot;.\&quot;V_Person\&quot; a WHERE a.\&quot;name\&quot; = &#39;john50&#39;&quot;);</b>
<b class="fc">&nbsp;                Assert.assertTrue(rs.next());</b>
<b class="fc">&nbsp;                String result = rs.getString(1);</b>
<b class="fc">&nbsp;                System.out.println(result);</b>
<b class="pc">&nbsp;                Assert.assertTrue(result.contains(&quot;Index Scan&quot;) || result.contains(&quot;Bitmap Heap Scan&quot;));</b>
&nbsp;                statement.close();
&nbsp;            }
&nbsp;        } catch (SQLException e) {
<b class="nc">&nbsp;            Assert.fail(e.getMessage());</b>
&nbsp;        }
<b class="fc">&nbsp;        this.sqlgGraph.tx().rollback();</b>
&nbsp;    }
&nbsp;
&nbsp;    @Test
&nbsp;    public void testIndexOnVertex2() throws SQLException {
<b class="fc">&nbsp;        VertexLabel vertexLabel = this.sqlgGraph.getTopology().ensureVertexLabelExist(&quot;Person&quot;, new HashMap&lt;&gt;() {{</b>
<b class="fc">&nbsp;            put(&quot;name&quot;, PropertyDefinition.of(PropertyType.STRING));</b>
&nbsp;        }});
<b class="fc">&nbsp;        vertexLabel.ensureIndexExists(IndexType.NON_UNIQUE, new ArrayList&lt;&gt;(vertexLabel.getProperties().values()));</b>
<b class="fc">&nbsp;        this.sqlgGraph.tx().commit();</b>
<b class="fc">&nbsp;        for (int i = 0; i &lt; 5000; i++) {</b>
<b class="fc">&nbsp;            this.sqlgGraph.addVertex(T.label, &quot;Person&quot;, &quot;name&quot;, &quot;john&quot; + i);</b>
&nbsp;        }
<b class="fc">&nbsp;        this.sqlgGraph.tx().commit();</b>
<b class="fc">&nbsp;        Assert.assertEquals(1, this.sqlgGraph.traversal().V().has(T.label, &quot;Person&quot;).has(&quot;name&quot;, &quot;john50&quot;).count().next(), 0);</b>
<b class="fc">&nbsp;        Assert.assertEquals(1, this.sqlgGraph.traversal().V().has(T.label, &quot;Person&quot;).has(&quot;name&quot;, P.eq(&quot;john50&quot;)).count().next().intValue());</b>
&nbsp;
&nbsp;        //Check if the index is being used
<b class="fc">&nbsp;        Connection conn = this.sqlgGraph.tx().getConnection();</b>
<b class="fc">&nbsp;        Statement statement = conn.createStatement();</b>
<b class="pc">&nbsp;        if (this.sqlgGraph.getSqlDialect().getClass().getSimpleName().contains(&quot;Postgres&quot;)) {</b>
<b class="fc">&nbsp;            ResultSet rs = statement.executeQuery(&quot;explain analyze SELECT * FROM \&quot;public\&quot;.\&quot;V_Person\&quot; a WHERE a.\&quot;name\&quot; = &#39;john50&#39;&quot;);</b>
<b class="fc">&nbsp;            Assert.assertTrue(rs.next());</b>
<b class="fc">&nbsp;            String result = rs.getString(1);</b>
<b class="pc">&nbsp;            Assert.assertTrue(result, result.contains(&quot;Index Scan&quot;) || result.contains(&quot;Bitmap Heap Scan&quot;));</b>
&nbsp;            statement.close();
&nbsp;        }
<b class="fc">&nbsp;        this.sqlgGraph.tx().rollback();</b>
&nbsp;    }
&nbsp;
&nbsp;    @Test
&nbsp;    public void testIndexOnVertex() throws SQLException {
<b class="fc">&nbsp;        VertexLabel vertexLabel = this.sqlgGraph.getTopology().ensureVertexLabelExist(&quot;Person&quot;, new LinkedHashMap&lt;&gt;() {{</b>
<b class="fc">&nbsp;            put(&quot;name1&quot;, PropertyDefinition.of(PropertyType.STRING));</b>
<b class="fc">&nbsp;            put(&quot;name2&quot;, PropertyDefinition.of(PropertyType.STRING));</b>
<b class="fc">&nbsp;            put(&quot;name3&quot;, PropertyDefinition.of(PropertyType.STRING));</b>
&nbsp;        }});
<b class="fc">&nbsp;        PropertyColumn name1 = vertexLabel.getProperty(&quot;name1&quot;).orElseThrow(IllegalStateException::new);</b>
<b class="fc">&nbsp;        PropertyColumn name2 = vertexLabel.getProperty(&quot;name2&quot;).orElseThrow(IllegalStateException::new);</b>
<b class="fc">&nbsp;        PropertyColumn name3 = vertexLabel.getProperty(&quot;name3&quot;).orElseThrow(IllegalStateException::new);</b>
<b class="fc">&nbsp;        vertexLabel.ensureIndexExists(IndexType.NON_UNIQUE, Arrays.asList(name1, name2, name3));</b>
&nbsp;
<b class="fc">&nbsp;        this.sqlgGraph.tx().commit();</b>
<b class="fc">&nbsp;        for (int i = 0; i &lt; 5000; i++) {</b>
<b class="fc">&nbsp;            this.sqlgGraph.addVertex(T.label, &quot;Person&quot;, &quot;name1&quot;, &quot;john&quot; + i, &quot;name2&quot;, &quot;tom&quot; + i, &quot;name3&quot;, &quot;piet&quot; + i);</b>
&nbsp;        }
<b class="fc">&nbsp;        this.sqlgGraph.tx().commit();</b>
<b class="fc">&nbsp;        Assert.assertEquals(1, this.sqlgGraph.traversal().V().has(T.label, &quot;Person&quot;).has(&quot;name1&quot;, &quot;john50&quot;).count().next(), 0);</b>
<b class="fc">&nbsp;        Assert.assertEquals(1, this.sqlgGraph.traversal().V().has(T.label, &quot;Person&quot;).has(&quot;name1&quot;, P.eq(&quot;john50&quot;)).count().next().intValue());</b>
&nbsp;
&nbsp;        //Check if the index is being used
<b class="fc">&nbsp;        Connection conn = this.sqlgGraph.tx().getConnection();</b>
<b class="fc">&nbsp;        Statement statement = conn.createStatement();</b>
<b class="pc">&nbsp;        if (this.sqlgGraph.getSqlDialect().getClass().getSimpleName().contains(&quot;Postgres&quot;)) {</b>
<b class="fc">&nbsp;            ResultSet rs = statement.executeQuery(&quot;explain analyze SELECT * FROM \&quot;public\&quot;.\&quot;V_Person\&quot; a WHERE a.\&quot;name1\&quot; = &#39;john50&#39;&quot;);</b>
<b class="fc">&nbsp;            Assert.assertTrue(rs.next());</b>
<b class="fc">&nbsp;            String result = rs.getString(1);</b>
<b class="pc">&nbsp;            Assert.assertTrue(result, result.contains(&quot;Index Scan&quot;) || result.contains(&quot;Bitmap Heap Scan&quot;));</b>
&nbsp;            statement.close();
&nbsp;        }
<b class="fc">&nbsp;        this.sqlgGraph.tx().rollback();</b>
&nbsp;    }
&nbsp;
&nbsp;    @Test
&nbsp;    public void testIndexOnVertex1() throws SQLException {
&nbsp;        //This is for postgres only
<b class="fc">&nbsp;        Assume.assumeTrue(this.sqlgGraph.getSqlDialect().getClass().getSimpleName().contains(&quot;Postgres&quot;));</b>
<b class="fc">&nbsp;        VertexLabel vertexLabel = this.sqlgGraph.getTopology().ensureVertexLabelExist(&quot;Person&quot;, new LinkedHashMap&lt;&gt;() {{</b>
<b class="fc">&nbsp;            put(&quot;name1&quot;, PropertyDefinition.of(PropertyType.STRING));</b>
<b class="fc">&nbsp;            put(&quot;name2&quot;, PropertyDefinition.of(PropertyType.STRING));</b>
<b class="fc">&nbsp;            put(&quot;name3&quot;, PropertyDefinition.of(PropertyType.STRING));</b>
&nbsp;        }});
<b class="fc">&nbsp;        PropertyColumn name1 = vertexLabel.getProperty(&quot;name1&quot;).orElseThrow(IllegalStateException::new);</b>
<b class="fc">&nbsp;        PropertyColumn name2 = vertexLabel.getProperty(&quot;name2&quot;).orElseThrow(IllegalStateException::new);</b>
<b class="fc">&nbsp;        PropertyColumn name3 = vertexLabel.getProperty(&quot;name3&quot;).orElseThrow(IllegalStateException::new);</b>
<b class="fc">&nbsp;        vertexLabel.ensureIndexExists(IndexType.NON_UNIQUE, Arrays.asList(name1, name2, name3));</b>
&nbsp;
<b class="fc">&nbsp;        this.sqlgGraph.tx().commit();</b>
<b class="fc">&nbsp;        for (int i = 0; i &lt; 5000; i++) {</b>
<b class="fc">&nbsp;            this.sqlgGraph.addVertex(T.label, &quot;Person&quot;, &quot;name1&quot;, &quot;john&quot; + i, &quot;name2&quot;, &quot;tom&quot; + i, &quot;name3&quot;, &quot;piet&quot; + i);</b>
&nbsp;        }
<b class="fc">&nbsp;        this.sqlgGraph.tx().commit();</b>
<b class="fc">&nbsp;        Assert.assertEquals(1, this.sqlgGraph.traversal().V().has(T.label, &quot;Person&quot;).has(&quot;name1&quot;, &quot;john50&quot;).count().next(), 0);</b>
<b class="fc">&nbsp;        Connection conn = this.sqlgGraph.getConnection();</b>
<b class="fc">&nbsp;        Statement statement = conn.createStatement();</b>
<b class="pc">&nbsp;        if (this.sqlgGraph.getSqlDialect().getClass().getSimpleName().contains(&quot;Postgres&quot;)) {</b>
<b class="fc">&nbsp;            ResultSet rs = statement.executeQuery(&quot;explain analyze SELECT * FROM \&quot;public\&quot;.\&quot;V_Person\&quot; a WHERE a.\&quot;name1\&quot; = &#39;john50&#39;&quot;);</b>
<b class="fc">&nbsp;            Assert.assertTrue(rs.next());</b>
<b class="fc">&nbsp;            String result = rs.getString(1);</b>
<b class="pc">&nbsp;            Assert.assertTrue(result, result.contains(&quot;Index Scan&quot;) || result.contains(&quot;Bitmap Heap Scan&quot;));</b>
&nbsp;            statement.close();
&nbsp;            conn.close();
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    @Test
&nbsp;    public void testIndexOnVertex1Schema() throws SQLException {
&nbsp;        //This is for postgres only
<b class="fc">&nbsp;        Assume.assumeTrue(this.sqlgGraph.getSqlDialect().getClass().getSimpleName().contains(&quot;Postgres&quot;));</b>
&nbsp;
<b class="fc">&nbsp;        VertexLabel vertexLabel = this.sqlgGraph.getTopology().ensureSchemaExist(&quot;MySchema&quot;).ensureVertexLabelExist(&quot;Person&quot;, new LinkedHashMap&lt;&gt;() {{</b>
<b class="fc">&nbsp;            put(&quot;name1&quot;, PropertyDefinition.of(PropertyType.STRING));</b>
<b class="fc">&nbsp;            put(&quot;name2&quot;, PropertyDefinition.of(PropertyType.STRING));</b>
<b class="fc">&nbsp;            put(&quot;name3&quot;, PropertyDefinition.of(PropertyType.STRING));</b>
&nbsp;        }});
<b class="fc">&nbsp;        PropertyColumn name1 = vertexLabel.getProperty(&quot;name1&quot;).orElseThrow(IllegalStateException::new);</b>
<b class="fc">&nbsp;        PropertyColumn name2 = vertexLabel.getProperty(&quot;name2&quot;).orElseThrow(IllegalStateException::new);</b>
<b class="fc">&nbsp;        PropertyColumn name3 = vertexLabel.getProperty(&quot;name3&quot;).orElseThrow(IllegalStateException::new);</b>
<b class="fc">&nbsp;        vertexLabel.ensureIndexExists(IndexType.NON_UNIQUE, Arrays.asList(name1, name2, name3));</b>
&nbsp;
<b class="fc">&nbsp;        this.sqlgGraph.tx().commit();</b>
<b class="fc">&nbsp;        for (int i = 0; i &lt; 5000; i++) {</b>
<b class="fc">&nbsp;            this.sqlgGraph.addVertex(T.label, &quot;MySchema.Person&quot;, &quot;name1&quot;, &quot;john&quot; + i, &quot;name2&quot;, &quot;tom&quot; + i, &quot;name3&quot;, &quot;piet&quot; + i);</b>
&nbsp;        }
<b class="fc">&nbsp;        this.sqlgGraph.tx().commit();</b>
<b class="fc">&nbsp;        Assert.assertEquals(1, this.sqlgGraph.traversal().V().has(T.label, &quot;MySchema.Person&quot;).has(&quot;name1&quot;, &quot;john50&quot;).count().next(), 0);</b>
<b class="fc">&nbsp;        Connection conn = this.sqlgGraph.getConnection();</b>
<b class="fc">&nbsp;        Statement statement = conn.createStatement();</b>
<b class="pc">&nbsp;        if (this.sqlgGraph.getSqlDialect().getClass().getSimpleName().contains(&quot;Postgres&quot;)) {</b>
<b class="fc">&nbsp;            ResultSet rs = statement.executeQuery(&quot;explain analyze SELECT * FROM \&quot;MySchema\&quot;.\&quot;V_Person\&quot; a WHERE a.\&quot;name1\&quot; = &#39;john50&#39;&quot;);</b>
<b class="fc">&nbsp;            Assert.assertTrue(rs.next());</b>
<b class="fc">&nbsp;            String result = rs.getString(1);</b>
<b class="pc">&nbsp;            Assert.assertTrue(result, result.contains(&quot;Index Scan&quot;) || result.contains(&quot;Bitmap Heap Scan&quot;));</b>
&nbsp;            statement.close();
&nbsp;            conn.close();
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    @Test
&nbsp;    public void testIndexExist() {
<b class="fc">&nbsp;        VertexLabel vertexLabel = this.sqlgGraph.getTopology().ensureVertexLabelExist(&quot;Person&quot;, new LinkedHashMap&lt;&gt;() {{</b>
<b class="fc">&nbsp;            put(&quot;name&quot;, PropertyDefinition.of(PropertyType.STRING));</b>
&nbsp;        }});
<b class="fc">&nbsp;        PropertyColumn name = vertexLabel.getProperty(&quot;name&quot;).orElseThrow(IllegalStateException::new);</b>
<b class="fc">&nbsp;        vertexLabel.ensureIndexExists(IndexType.NON_UNIQUE, Collections.singletonList(name));</b>
<b class="fc">&nbsp;        this.sqlgGraph.tx().commit();</b>
&nbsp;
<b class="fc">&nbsp;        this.sqlgGraph.getTopology().ensureVertexLabelExist(&quot;Person&quot;, new LinkedHashMap&lt;&gt;() {{</b>
<b class="fc">&nbsp;            put(&quot;name&quot;, PropertyDefinition.of(PropertyType.STRING));</b>
&nbsp;        }});
<b class="fc">&nbsp;        name = vertexLabel.getProperty(&quot;name&quot;).orElseThrow(IllegalStateException::new);</b>
<b class="fc">&nbsp;        vertexLabel.ensureIndexExists(IndexType.NON_UNIQUE, Collections.singletonList(name));</b>
&nbsp;
<b class="fc">&nbsp;        this.sqlgGraph.getTopology().ensureVertexLabelExist(&quot;Person&quot;, new LinkedHashMap&lt;&gt;() {{</b>
<b class="fc">&nbsp;            put(&quot;name&quot;, PropertyDefinition.of(PropertyType.STRING));</b>
&nbsp;        }});
<b class="fc">&nbsp;        name = vertexLabel.getProperty(&quot;name&quot;).orElseThrow(IllegalStateException::new);</b>
<b class="fc">&nbsp;        vertexLabel.ensureIndexExists(IndexType.NON_UNIQUE, Collections.singletonList(name));</b>
<b class="fc">&nbsp;        this.sqlgGraph.tx().commit();</b>
&nbsp;
<b class="fc">&nbsp;        this.sqlgGraph.close();</b>
<b class="fc">&nbsp;        this.sqlgGraph = SqlgGraph.open(configuration);</b>
<b class="fc">&nbsp;        this.sqlgGraph.getTopology().ensureVertexLabelExist(&quot;Person&quot;, new LinkedHashMap&lt;&gt;() {{</b>
<b class="fc">&nbsp;            put(&quot;name&quot;, PropertyDefinition.of(PropertyType.STRING));</b>
&nbsp;        }});
<b class="fc">&nbsp;        name = vertexLabel.getProperty(&quot;name&quot;).orElseThrow(IllegalStateException::new);</b>
<b class="fc">&nbsp;        vertexLabel.ensureIndexExists(IndexType.NON_UNIQUE, Collections.singletonList(name));</b>
&nbsp;    }
&nbsp;
&nbsp;    @Test
&nbsp;    public void testIndexExistSchema() {
<b class="fc">&nbsp;        VertexLabel vertexLabel = this.sqlgGraph.getTopology().ensureSchemaExist(&quot;MySchema&quot;).ensureVertexLabelExist(&quot;Person&quot;, new LinkedHashMap&lt;&gt;() {{</b>
<b class="fc">&nbsp;            put(&quot;name&quot;, PropertyDefinition.of(PropertyType.STRING));</b>
&nbsp;        }});
<b class="fc">&nbsp;        PropertyColumn name = vertexLabel.getProperty(&quot;name&quot;).orElseThrow(IllegalStateException::new);</b>
<b class="fc">&nbsp;        vertexLabel.ensureIndexExists(IndexType.NON_UNIQUE, Collections.singletonList(name));</b>
&nbsp;
<b class="fc">&nbsp;        vertexLabel = this.sqlgGraph.getTopology().ensureVertexLabelExist(&quot;Person&quot;, new LinkedHashMap&lt;&gt;() {{</b>
<b class="fc">&nbsp;            put(&quot;name&quot;, PropertyDefinition.of(PropertyType.STRING));</b>
&nbsp;        }});
<b class="fc">&nbsp;        name = vertexLabel.getProperty(&quot;name&quot;).orElseThrow(IllegalStateException::new);</b>
<b class="fc">&nbsp;        vertexLabel.ensureIndexExists(IndexType.NON_UNIQUE, Collections.singletonList(name));</b>
&nbsp;
<b class="fc">&nbsp;        this.sqlgGraph.tx().commit();</b>
&nbsp;
<b class="fc">&nbsp;        vertexLabel = this.sqlgGraph.getTopology().ensureSchemaExist(&quot;MySchema&quot;).ensureVertexLabelExist(&quot;Person&quot;, new LinkedHashMap&lt;&gt;() {{</b>
<b class="fc">&nbsp;            put(&quot;name&quot;, PropertyDefinition.of(PropertyType.STRING));</b>
&nbsp;        }});
<b class="fc">&nbsp;        name = vertexLabel.getProperty(&quot;name&quot;).orElseThrow(IllegalStateException::new);</b>
<b class="fc">&nbsp;        vertexLabel.ensureIndexExists(IndexType.NON_UNIQUE, Collections.singletonList(name));</b>
&nbsp;
<b class="fc">&nbsp;        vertexLabel = this.sqlgGraph.getTopology().ensureSchemaExist(&quot;MySchema&quot;).ensureVertexLabelExist(&quot;Person&quot;, new LinkedHashMap&lt;&gt;() {{</b>
<b class="fc">&nbsp;            put(&quot;name&quot;, PropertyDefinition.of(PropertyType.STRING));</b>
&nbsp;        }});
<b class="fc">&nbsp;        name = vertexLabel.getProperty(&quot;name&quot;).orElseThrow(IllegalStateException::new);</b>
<b class="fc">&nbsp;        vertexLabel.ensureIndexExists(IndexType.NON_UNIQUE, Collections.singletonList(name));</b>
<b class="fc">&nbsp;        this.sqlgGraph.tx().commit();</b>
&nbsp;
<b class="fc">&nbsp;        this.sqlgGraph.close();</b>
<b class="fc">&nbsp;        this.sqlgGraph = SqlgGraph.open(configuration);</b>
<b class="fc">&nbsp;        vertexLabel = this.sqlgGraph.getTopology().ensureSchemaExist(&quot;MySchema&quot;).ensureVertexLabelExist(&quot;Person&quot;, new LinkedHashMap&lt;&gt;() {{</b>
<b class="fc">&nbsp;            put(&quot;name&quot;, PropertyDefinition.of(PropertyType.STRING));</b>
&nbsp;        }});
<b class="fc">&nbsp;        name = vertexLabel.getProperty(&quot;name&quot;).orElseThrow(IllegalStateException::new);</b>
<b class="fc">&nbsp;        vertexLabel.ensureIndexExists(IndexType.NON_UNIQUE, Collections.singletonList(name));</b>
&nbsp;    }
&nbsp;
&nbsp;    @Test
&nbsp;    public void testIndexOnEdge() throws Exception {
<b class="fc">&nbsp;        Map&lt;String, PropertyDefinition&gt; columns = new HashMap&lt;&gt;();</b>
<b class="fc">&nbsp;        columns.put(&quot;name&quot;, PropertyDefinition.of(PropertyType.STRING));</b>
&nbsp;
<b class="fc">&nbsp;        String publicSchema = this.sqlgGraph.getSqlDialect().getPublicSchema();</b>
<b class="fc">&nbsp;        this.sqlgGraph.getTopology().ensureVertexLabelExist(&quot;Person&quot;, columns);</b>
<b class="fc">&nbsp;        this.sqlgGraph.getTopology().ensureVertexLabelExist(&quot;Address&quot;, columns);</b>
<b class="fc">&nbsp;        this.sqlgGraph.getTopology().ensureEdgeLabelExist(&quot;person_address&quot;, SchemaTable.of(publicSchema, &quot;Person&quot;), SchemaTable.of(publicSchema, &quot;Address&quot;), columns);</b>
<b class="fc">&nbsp;        EdgeLabel edgeLabel = this.sqlgGraph.getTopology().getEdgeLabel(publicSchema, &quot;person_address&quot;).orElseThrow(IllegalStateException::new);</b>
<b class="fc">&nbsp;        edgeLabel.ensureIndexExists(IndexType.UNIQUE, Collections.singletonList(edgeLabel.getProperty(&quot;name&quot;).orElseThrow(IllegalStateException::new)));</b>
<b class="fc">&nbsp;        this.sqlgGraph.tx().commit();</b>
&nbsp;
<b class="fc">&nbsp;        for (int i = 0; i &lt; 5000; i++) {</b>
<b class="fc">&nbsp;            Vertex person1 = this.sqlgGraph.addVertex(T.label, &quot;Person&quot;, &quot;name&quot;, &quot;john&quot;);</b>
<b class="fc">&nbsp;            Vertex address1 = this.sqlgGraph.addVertex(T.label, &quot;Person&quot;, &quot;name&quot;, &quot;john&quot;);</b>
<b class="fc">&nbsp;            person1.addEdge(&quot;person_address&quot;, address1, &quot;name&quot;, &quot;address&quot; + i);</b>
&nbsp;        }
<b class="fc">&nbsp;        this.sqlgGraph.tx().commit();</b>
&nbsp;
<b class="pc">&nbsp;        if (this.sqlgGraph.getSqlDialect().getClass().getSimpleName().contains(&quot;Postgres&quot;)) {</b>
<b class="fc">&nbsp;            Connection conn = this.sqlgGraph.getConnection();</b>
<b class="fc">&nbsp;            Statement statement = conn.createStatement();</b>
<b class="fc">&nbsp;            ResultSet rs = statement.executeQuery(&quot;explain analyze SELECT * FROM \&quot;public\&quot;.\&quot;E_person_address\&quot; a WHERE a.\&quot;name\&quot; = &#39;address1001&#39;&quot;);</b>
<b class="fc">&nbsp;            Assert.assertTrue(rs.next());</b>
<b class="fc">&nbsp;            String result = rs.getString(1);</b>
<b class="pc">&nbsp;            Assert.assertTrue(result, result.contains(&quot;Index Scan&quot;) || result.contains(&quot;Bitmap Heap Scan&quot;));</b>
&nbsp;            statement.close();
&nbsp;            conn.close();
&nbsp;        }
&nbsp;
<b class="fc">&nbsp;        this.sqlgGraph.close();</b>
<b class="fc">&nbsp;        this.sqlgGraph = SqlgGraph.open(configuration);</b>
<b class="fc">&nbsp;        edgeLabel = this.sqlgGraph.getTopology().getEdgeLabel(publicSchema, &quot;person_address&quot;).orElseThrow(IllegalStateException::new);</b>
<b class="fc">&nbsp;        edgeLabel.ensureIndexExists(IndexType.UNIQUE, Collections.singletonList(edgeLabel.getProperty(&quot;name&quot;).orElseThrow(IllegalStateException::new)));</b>
&nbsp;
&nbsp;
&nbsp;    }
&nbsp;
&nbsp;    @Test
&nbsp;    public void testIndexOnEdgeAcrossSchemas() {
<b class="fc">&nbsp;        Vertex aa1 = this.sqlgGraph.addVertex(T.label, &quot;A.A&quot;, &quot;name&quot;, &quot;aa&quot;);</b>
<b class="fc">&nbsp;        Vertex bb1 = this.sqlgGraph.addVertex(T.label, &quot;B.B&quot;, &quot;name&quot;, &quot;bb&quot;);</b>
<b class="fc">&nbsp;        Vertex cc1 = this.sqlgGraph.addVertex(T.label, &quot;C.C&quot;, &quot;name&quot;, &quot;cc&quot;);</b>
<b class="fc">&nbsp;        aa1.addEdge(&quot;test&quot;, bb1, &quot;name&quot;, &quot;ola&quot;);</b>
<b class="fc">&nbsp;        bb1.addEdge(&quot;test&quot;, cc1, &quot;name&quot;, &quot;ola&quot;);</b>
<b class="fc">&nbsp;        this.sqlgGraph.tx().commit();</b>
&nbsp;
<b class="fc">&nbsp;        EdgeLabel edgeLabel = this.sqlgGraph.getTopology().getEdgeLabel(&quot;A&quot;, &quot;test&quot;).orElseThrow(IllegalStateException::new);</b>
<b class="fc">&nbsp;        edgeLabel.ensureIndexExists(IndexType.UNIQUE, Collections.singletonList(edgeLabel.getProperty(&quot;name&quot;).orElseThrow(IllegalStateException::new)));</b>
<b class="fc">&nbsp;        this.sqlgGraph.tx().commit();</b>
&nbsp;
<b class="fc">&nbsp;        Assert.assertEquals(IndexType.UNIQUE, edgeLabel.getIndex(this.sqlgGraph.getSqlDialect().indexName(SchemaTable.of(&quot;A&quot;, &quot;test&quot;), Topology.EDGE_PREFIX, Collections.singletonList(&quot;name&quot;))).orElseThrow(IllegalStateException::new).getIndexType());</b>
<b class="fc">&nbsp;        Assert.assertFalse(edgeLabel.getIndex(this.sqlgGraph.getSqlDialect().indexName(SchemaTable.of(&quot;B&quot;, &quot;test&quot;), Topology.EDGE_PREFIX, Collections.singletonList(&quot;name&quot;))).isPresent());</b>
&nbsp;
&nbsp;        try {
<b class="fc">&nbsp;            aa1.addEdge(&quot;test&quot;, bb1, &quot;name&quot;, &quot;ola&quot;);</b>
<b class="nc">&nbsp;            Assert.fail(&quot;Unique constraint should prevent this from happening&quot;);</b>
&nbsp;        } catch (Exception e) {
&nbsp;            //swallow
&nbsp;        }
<b class="fc">&nbsp;        this.sqlgGraph.tx().rollback();</b>
&nbsp;
&nbsp;        //this one is ok, no unique constraint
<b class="fc">&nbsp;        bb1.addEdge(&quot;test&quot;, cc1, &quot;name&quot;, &quot;ola&quot;);</b>
<b class="fc">&nbsp;        this.sqlgGraph.tx().commit();</b>
&nbsp;    }
&nbsp;
&nbsp;    @Test
&nbsp;    public void testIndexTypeFromJSON() throws Exception {
<b class="fc">&nbsp;        IndexType it1 = IndexType.fromNotifyJson(new ObjectMapper().readTree(&quot;{\&quot;name\&quot;:\&quot;UNIQUE\&quot;}&quot;));</b>
<b class="fc">&nbsp;        Assert.assertEquals(IndexType.UNIQUE, it1);</b>
<b class="fc">&nbsp;        IndexType it2 = IndexType.fromNotifyJson(new ObjectMapper().readTree(&quot;\&quot;UNIQUE\&quot;&quot;));</b>
<b class="fc">&nbsp;        Assert.assertEquals(IndexType.UNIQUE, it2);</b>
&nbsp;
<b class="fc">&nbsp;        it1 = IndexType.fromNotifyJson(new ObjectMapper().readTree(&quot;{\&quot;name\&quot;:\&quot;NON_UNIQUE\&quot;}&quot;));</b>
<b class="fc">&nbsp;        Assert.assertEquals(IndexType.NON_UNIQUE, it1);</b>
<b class="fc">&nbsp;        it2 = IndexType.fromNotifyJson(new ObjectMapper().readTree(&quot;\&quot;NON_UNIQUE\&quot;&quot;));</b>
<b class="fc">&nbsp;        Assert.assertEquals(IndexType.NON_UNIQUE, it2);</b>
&nbsp;
&nbsp;    }
&nbsp;
&nbsp;    @Test
&nbsp;    public void testLongIndexName() {
<b class="fc">&nbsp;        String i1 = buildLongIndex(sqlgGraph);</b>
<b class="fc">&nbsp;        String i2 = buildLongIndex(sqlgGraph);</b>
<b class="fc">&nbsp;        Assert.assertEquals(i1, i2);</b>
<b class="fc">&nbsp;        sqlgGraph.close();</b>
<b class="fc">&nbsp;        sqlgGraph = SqlgGraph.open(getConfigurationClone());</b>
<b class="fc">&nbsp;        String i3 = buildLongIndex(sqlgGraph);</b>
<b class="fc">&nbsp;        Assert.assertEquals(i1, i3);</b>
&nbsp;    }
&nbsp;
&nbsp;    private String buildLongIndex(SqlgGraph g) {
<b class="fc">&nbsp;        Schema sch = g.getTopology().ensureSchemaExist(&quot;longIndex&quot;);</b>
<b class="fc">&nbsp;        Map&lt;String, PropertyDefinition&gt; columns = new HashMap&lt;&gt;();</b>
<b class="fc">&nbsp;        columns.put(&quot;longpropertyname1&quot;, PropertyDefinition.of(PropertyType.STRING));</b>
<b class="fc">&nbsp;        columns.put(&quot;longpropertyname2&quot;, PropertyDefinition.of(PropertyType.STRING));</b>
<b class="fc">&nbsp;        columns.put(&quot;longpropertyname3&quot;, PropertyDefinition.of(PropertyType.STRING));</b>
<b class="fc">&nbsp;        VertexLabel label = sch.ensureVertexLabelExist(&quot;LongIndex&quot;, columns);</b>
<b class="fc">&nbsp;        List&lt;PropertyColumn&gt; properties = Arrays.asList(</b>
<b class="fc">&nbsp;                label.getProperty(&quot;longpropertyname1&quot;).orElseThrow(IllegalStateException::new)</b>
<b class="fc">&nbsp;                , label.getProperty(&quot;longpropertyname2&quot;).orElseThrow(IllegalStateException::new)</b>
<b class="fc">&nbsp;                , label.getProperty(&quot;longpropertyname3&quot;).orElseThrow(IllegalStateException::new));</b>
<b class="fc">&nbsp;        Index idx = label.ensureIndexExists(IndexType.NON_UNIQUE, properties);</b>
&nbsp;
<b class="fc">&nbsp;        g.tx().commit();</b>
<b class="fc">&nbsp;        return idx.getName();</b>
&nbsp;    }
&nbsp;
&nbsp;    @Test
&nbsp;    public void testShortIndexName() {
<b class="fc">&nbsp;        String i1 = buildShortIndex(sqlgGraph);</b>
<b class="fc">&nbsp;        String i2 = buildShortIndex(sqlgGraph);</b>
<b class="fc">&nbsp;        Assert.assertEquals(i1, i2);</b>
<b class="fc">&nbsp;        sqlgGraph.close();</b>
<b class="fc">&nbsp;        sqlgGraph = SqlgGraph.open(getConfigurationClone());</b>
<b class="fc">&nbsp;        String i3 = buildShortIndex(sqlgGraph);</b>
<b class="fc">&nbsp;        Assert.assertEquals(i1, i3);</b>
&nbsp;    }
&nbsp;
&nbsp;    private String buildShortIndex(SqlgGraph g) {
<b class="fc">&nbsp;        Schema sch = g.getTopology().ensureSchemaExist(&quot;longIndex&quot;);</b>
<b class="fc">&nbsp;        Map&lt;String, PropertyDefinition&gt; columns = new HashMap&lt;&gt;();</b>
<b class="fc">&nbsp;        columns.put(&quot;short1&quot;, PropertyDefinition.of(PropertyType.STRING));</b>
<b class="fc">&nbsp;        columns.put(&quot;short2&quot;, PropertyDefinition.of(PropertyType.STRING));</b>
<b class="fc">&nbsp;        columns.put(&quot;short3&quot;, PropertyDefinition.of(PropertyType.STRING));</b>
<b class="fc">&nbsp;        VertexLabel label = sch.ensureVertexLabelExist(&quot;LongIndex&quot;, columns);</b>
<b class="fc">&nbsp;        List&lt;PropertyColumn&gt; properties = Arrays.asList(</b>
<b class="fc">&nbsp;                label.getProperty(&quot;short1&quot;).orElseThrow(IllegalStateException::new)</b>
<b class="fc">&nbsp;                , label.getProperty(&quot;short2&quot;).orElseThrow(IllegalStateException::new)</b>
<b class="fc">&nbsp;                , label.getProperty(&quot;short3&quot;).orElseThrow(IllegalStateException::new));</b>
<b class="fc">&nbsp;        Index idx = label.ensureIndexExists(IndexType.NON_UNIQUE, properties);</b>
&nbsp;
<b class="fc">&nbsp;        g.tx().commit();</b>
<b class="fc">&nbsp;        return idx.getName();</b>
&nbsp;    }
&nbsp;
&nbsp;    @Test
&nbsp;    public void testMultipleIndexesOnLabel() {
&nbsp;
<b class="fc">&nbsp;        VertexLabel vertexLabel = this.sqlgGraph.getTopology().getPublicSchema().ensureVertexLabelExist(</b>
&nbsp;                &quot;Person&quot;,
<b class="fc">&nbsp;                new HashMap&lt;&gt;() {{</b>
<b class="fc">&nbsp;                    put(&quot;name&quot;, PropertyDefinition.of(PropertyType.STRING));</b>
<b class="fc">&nbsp;                    put(&quot;surname&quot;, PropertyDefinition.of(PropertyType.STRING));</b>
&nbsp;                }}
&nbsp;        );
<b class="fc">&nbsp;        PropertyColumn propertyColumn = vertexLabel.getProperty(&quot;name&quot;).orElseThrow(() -&gt; new RuntimeException(&quot;its a bug&quot;));</b>
<b class="fc">&nbsp;        vertexLabel.ensureIndexExists(IndexType.NON_UNIQUE, Collections.singletonList(propertyColumn));</b>
<b class="fc">&nbsp;        this.sqlgGraph.tx().commit();</b>
&nbsp;
<b class="fc">&nbsp;        propertyColumn = vertexLabel.getProperty(&quot;surname&quot;).orElseThrow(() -&gt; new RuntimeException(&quot;its a bug&quot;));</b>
<b class="fc">&nbsp;        vertexLabel.ensureIndexExists(IndexType.NON_UNIQUE, Collections.singletonList(propertyColumn));</b>
<b class="fc">&nbsp;        this.sqlgGraph.tx().commit();</b>
&nbsp;
<b class="fc">&nbsp;        this.sqlgGraph.addVertex(T.label, &quot;Person&quot;, &quot;name&quot;, &quot;John&quot;, &quot;surname&quot;, &quot;Smith&quot;);</b>
<b class="fc">&nbsp;        this.sqlgGraph.tx().commit();</b>
&nbsp;
<b class="fc">&nbsp;        this.sqlgGraph.close();</b>
<b class="fc">&nbsp;        this.sqlgGraph = SqlgGraph.open(configuration);</b>
<b class="fc">&nbsp;        Optional&lt;VertexLabel&gt; vertexLabelOptional = this.sqlgGraph.getTopology().getPublicSchema().getVertexLabel(&quot;Person&quot;);</b>
<b class="fc">&nbsp;        Assert.assertTrue(vertexLabelOptional.isPresent());</b>
<b class="fc">&nbsp;        Map&lt;String, Index&gt; indexMap = vertexLabelOptional.get().getIndexes();</b>
<b class="fc">&nbsp;        Assert.assertEquals(2, indexMap.size());</b>
&nbsp;    }
&nbsp;
&nbsp;    @Test
&nbsp;    public void testDropIndex() {
<b class="fc">&nbsp;        VertexLabel vertexLabel = this.sqlgGraph.getTopology().getPublicSchema().ensureVertexLabelExist(</b>
&nbsp;                &quot;Person&quot;,
<b class="fc">&nbsp;                new HashMap&lt;&gt;() {{</b>
<b class="fc">&nbsp;                    put(&quot;name&quot;, PropertyDefinition.of(PropertyType.STRING));</b>
<b class="fc">&nbsp;                    put(&quot;surname&quot;, PropertyDefinition.of(PropertyType.STRING));</b>
&nbsp;                }}
&nbsp;        );
<b class="fc">&nbsp;        PropertyColumn propertyColumn = vertexLabel.getProperty(&quot;name&quot;).orElseThrow(() -&gt; new RuntimeException(&quot;its a bug&quot;));</b>
<b class="fc">&nbsp;        vertexLabel.ensureIndexExists(IndexType.NON_UNIQUE, Collections.singletonList(propertyColumn));</b>
<b class="fc">&nbsp;        this.sqlgGraph.tx().commit();</b>
&nbsp;
<b class="fc">&nbsp;        Optional&lt;VertexLabel&gt; vertexLabelOptional = this.sqlgGraph.getTopology().getPublicSchema().getVertexLabel(&quot;Person&quot;);</b>
<b class="fc">&nbsp;        Assert.assertTrue(vertexLabelOptional.isPresent());</b>
<b class="fc">&nbsp;        VertexLabel personVertexLabel = vertexLabelOptional.get();</b>
<b class="fc">&nbsp;        Assert.assertEquals(2, personVertexLabel.getProperties().size());</b>
<b class="fc">&nbsp;        Map&lt;String, Index&gt; indexMap = personVertexLabel.getIndexes();</b>
<b class="fc">&nbsp;        Assert.assertEquals(1, indexMap.size());</b>
<b class="fc">&nbsp;        new ArrayList&lt;&gt;(indexMap.values()).get(0).remove();</b>
<b class="fc">&nbsp;        this.sqlgGraph.tx().commit();</b>
&nbsp;
<b class="fc">&nbsp;        vertexLabelOptional = this.sqlgGraph.getTopology().getPublicSchema().getVertexLabel(&quot;Person&quot;);</b>
<b class="fc">&nbsp;        Assert.assertTrue(vertexLabelOptional.isPresent());</b>
<b class="fc">&nbsp;        personVertexLabel = vertexLabelOptional.get();</b>
<b class="fc">&nbsp;        Assert.assertEquals(2, personVertexLabel.getProperties().size());</b>
<b class="fc">&nbsp;        indexMap = personVertexLabel.getIndexes();</b>
<b class="fc">&nbsp;        Assert.assertTrue(indexMap.isEmpty());</b>
&nbsp;
&nbsp;        //Do it again, github issue #400, fails on doing it again.
<b class="fc">&nbsp;        vertexLabel = this.sqlgGraph.getTopology().getPublicSchema().ensureVertexLabelExist(</b>
&nbsp;                &quot;Person&quot;,
<b class="fc">&nbsp;                new HashMap&lt;&gt;() {{</b>
<b class="fc">&nbsp;                    put(&quot;name&quot;, PropertyDefinition.of(PropertyType.STRING));</b>
<b class="fc">&nbsp;                    put(&quot;surname&quot;, PropertyDefinition.of(PropertyType.STRING));</b>
&nbsp;                }}
&nbsp;        );
<b class="fc">&nbsp;        propertyColumn = vertexLabel.getProperty(&quot;name&quot;).orElseThrow(() -&gt; new RuntimeException(&quot;its a bug&quot;));</b>
<b class="fc">&nbsp;        vertexLabel.ensureIndexExists(IndexType.NON_UNIQUE, Collections.singletonList(propertyColumn));</b>
<b class="fc">&nbsp;        this.sqlgGraph.tx().commit();</b>
&nbsp;
<b class="fc">&nbsp;        vertexLabelOptional = this.sqlgGraph.getTopology().getPublicSchema().getVertexLabel(&quot;Person&quot;);</b>
<b class="fc">&nbsp;        Assert.assertTrue(vertexLabelOptional.isPresent());</b>
<b class="fc">&nbsp;        personVertexLabel = vertexLabelOptional.get();</b>
<b class="fc">&nbsp;        Assert.assertEquals(2, personVertexLabel.getProperties().size());</b>
<b class="fc">&nbsp;        indexMap = personVertexLabel.getIndexes();</b>
<b class="fc">&nbsp;        Assert.assertEquals(1, indexMap.size());</b>
&nbsp;
&nbsp;    }
&nbsp;}
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2025-06-23 10:13</div>
</div>
</body>
</html>
